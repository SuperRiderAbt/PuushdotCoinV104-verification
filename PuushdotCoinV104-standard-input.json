{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"./IERC721.sol\";\nimport {IERC721Receiver} from \"./IERC721Receiver.sol\";\nimport {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Strings} from \"../../utils/Strings.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    mapping(uint256 tokenId => address) private _owners;\n\n    mapping(address owner => uint256) private _balances;\n\n    mapping(uint256 tokenId => address) private _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\n     * the `spender` for the specific `tokenId`.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        unchecked {\n            _balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC721} from \"../ERC721.sol\";\nimport {IERC721Enumerable} from \"./IERC721Enumerable.sol\";\nimport {IERC165} from \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds enumerability\n * of all the token ids in the contract as well as all token ids owned by each account.\n *\n * CAUTION: `ERC721` extensions that implement custom `balanceOf` logic, such as `ERC721Consecutive`,\n * interfere with enumerability and should not be used together with `ERC721Enumerable`.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    mapping(address owner => mapping(uint256 index => uint256)) private _ownedTokens;\n    mapping(uint256 tokenId => uint256) private _ownedTokensIndex;\n\n    uint256[] private _allTokens;\n    mapping(uint256 tokenId => uint256) private _allTokensIndex;\n\n    /**\n     * @dev An `owner`'s token query was out of bounds for `index`.\n     *\n     * NOTE: The owner being `address(0)` indicates a global out of bounds index.\n     */\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n\n    /**\n     * @dev Batch mint is not allowed.\n     */\n    error ERC721EnumerableForbiddenBatchMint();\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_update}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n\n        return previousOwner;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = balanceOf(to) - 1;\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n\n    /**\n     * See {ERC721-_increaseBalance}. We need that to account tokens that were minted in batch\n     */\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(\n        uint256 a,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return\n                result +\n                (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(\n        uint256 value,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return\n                result +\n                (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(\n        uint256 value,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return\n                result +\n                (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(\n        uint256 value,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return\n                result +\n                (\n                    unsignedRoundsUp(rounding) && 1 << (result << 3) < value\n                        ? 1\n                        : 0\n                );\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/Airdropper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract Airdropper {\n    function airdrop(\n        IERC20 token,\n        address[] calldata recipients,\n        uint256[] calldata amounts\n    ) external {\n        require(\n            recipients.length == amounts.length,\n            \"Arrays must be of equal length\"\n        );\n\n        for (uint256 i = 0; i < recipients.length; i++) {\n            require(\n                token.transferFrom(msg.sender, recipients[i], amounts[i]),\n                \"Transfer failed\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/ERC20/ERC20BalanceHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract ERC20BalanceHelper {\n    constructor() {}\n\n    /**\n     * @notice Fetch balances for an array of ERC20 tokens for a specific user.\n     * @param tokenContracts Array of ERC20 token contract addresses.\n     * @param user Address of the user whose balances will be fetched.\n     * @return balances Array of balances for each ERC20 token contract.\n     *         If token address is the null address, returns the ETH balance.\n     */\n    function viewUserBalances(\n        address[] calldata tokenContracts,\n        address user\n    ) public view returns (uint256[] memory) {\n        uint256[] memory balances = new uint256[](tokenContracts.length);\n\n        for (uint256 i = 0; i < tokenContracts.length; i++) {\n            if (tokenContracts[i] == address(0)) {\n                // Return ETH balance if token address is the null address\n                balances[i] = user.balance;\n            } else {\n                balances[i] = IERC20(tokenContracts[i]).balanceOf(user);\n            }\n        }\n\n        return balances;\n    }\n\n    /**\n     * @notice Fetch balances for an array of ERC20 tokens for a specific user, with pagination.\n     * @param tokenContracts Array of ERC20 token contract addresses.\n     * @param user Address of the user whose balances will be fetched.\n     * @param page The page number to fetch.\n     * @param pageSize The number of results per page.\n     * @return balances Array of balances for the tokens in the specified page.\n     *         If token address is the null address, returns the ETH balance.\n     */\n    function viewUserBalancesPaginated(\n        address[] calldata tokenContracts,\n        address user,\n        uint256 page,\n        uint256 pageSize\n    ) public view returns (uint256[] memory) {\n        uint256 startIndex = page * pageSize;\n        uint256 endIndex = startIndex + pageSize;\n\n        if (endIndex > tokenContracts.length) {\n            endIndex = tokenContracts.length;\n        }\n\n        if (startIndex >= tokenContracts.length) {\n            return new uint256[](0);\n        }\n\n        uint256 resultSize = endIndex - startIndex;\n        uint256[] memory balances = new uint256[](resultSize);\n\n        for (uint256 i = 0; i < resultSize; i++) {\n            if (tokenContracts[startIndex + i] == address(0)) {\n                // Return ETH balance if token address is the null address\n                balances[i] = user.balance;\n            } else {\n                balances[i] = IERC20(tokenContracts[startIndex + i]).balanceOf(\n                    user\n                );\n            }\n        }\n\n        return balances;\n    }\n}\n"
    },
    "contracts/NFT/Catzuki.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract Catzuki is ERC721Enumerable, Ownable {\n    using Strings for uint256;\n\n    constructor() ERC721(\"Catzuki\", \"CATZUKI\") Ownable(msg.sender) {}\n\n    event itemsMinted(uint256[] tokenIds, address buyer);\n    event CoinSent(address coin, address from, address to, uint256 amount);\n\n    uint256 public maxSupply = 888;\n    uint256 public wlMintPrice = 88 ether;\n    uint256 public mintPrice = 111 ether;\n    uint256 public maxWlMints = 333;\n    uint256 public currentWlMints;\n\n    uint256 public puushDevRoyalty = 10; // 10%\n    address public puushDevWallet;\n    address public projectDevWallet;\n\n    bool public saleState;\n    bool public wlSaleState;\n    string public baseURI;\n\n    // Random token id mint variables\n    uint256 tokenIndex;\n    mapping(uint256 => uint256) private assignOrders;\n    uint256 public remainingToAssign = maxSupply;\n\n    // wl mapping\n    mapping(address => uint256) public wlBalanceOf;\n\n    /******************************************************\n     *                                                    *\n     *                 Owner Functions                    *\n     *                                                    *\n     ******************************************************/\n\n    function setWl(\n        address[] memory _addresses,\n        uint256[] memory _amounts\n    ) external onlyOwner {\n        require(_addresses.length == _amounts.length, \"Array length mismatch\");\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            wlBalanceOf[_addresses[i]] = _amounts[i];\n        }\n    }\n\n    function setPuushDevRoyalty(uint256 _royalty) external onlyOwner {\n        puushDevRoyalty = _royalty;\n    }\n\n    function setPuushDevWallet(address _wallet) external onlyOwner {\n        require(_wallet != address(0), \"Invalid wallet address\");\n        puushDevWallet = _wallet;\n    }\n\n    function setProjectDevWallet(address _wallet) public onlyOwner {\n        require(_wallet != address(0), \"Invalid wallet address\");\n        projectDevWallet = _wallet;\n    }\n\n    function setSaleState(bool state) external onlyOwner {\n        saleState = state;\n    }\n\n    function setWlSaleState(bool state) external onlyOwner {\n        wlSaleState = state;\n    }\n\n    function setPublicMintPrice(uint256 _price) external onlyOwner {\n        mintPrice = _price;\n    }\n\n    function setMintPrice(uint256 _price) external onlyOwner {\n        mintPrice = _price;\n    }\n\n    function setWlMintPrice(uint256 _price) external onlyOwner {\n        wlMintPrice = _price;\n    }\n\n    function setBaseURI(string memory baseURI_) external onlyOwner {\n        baseURI = baseURI_;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseURI;\n    }\n\n    // Override the tokenURI function to add .json at the end\n    function tokenURI(\n        uint256 tokenId\n    ) public view override returns (string memory) {\n        string memory currentBaseURI = _baseURI();\n        return\n            bytes(currentBaseURI).length > 0\n                ? string(\n                    abi.encodePacked(\n                        currentBaseURI,\n                        tokenIdToString(tokenId),\n                        \".json\"\n                    )\n                )\n                : \"\";\n    }\n\n    // Helper function to convert uint256 to string\n    function tokenIdToString(\n        uint256 tokenId\n    ) internal pure returns (string memory) {\n        return Strings.toString(tokenId); // This assumes you're using OpenZeppelin's Strings library\n    }\n\n    function withdraw() public payable onlyOwner {\n        (bool success, ) = payable(msg.sender).call{\n            value: address(this).balance\n        }(\"\");\n        require(success);\n    }\n\n    function withdrawERC20(address _token) public onlyOwner {\n        IERC20 token = IERC20(_token);\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    /******************************************************\n     *                                                    *\n     *                 Mint Functions                     *\n     *                                                    *\n     ******************************************************/\n\n    function adminMint(uint256 _amount, address _to) public onlyOwner {\n        require(_to != address(0), \"null addr\");\n        verifyMintability(_amount);\n\n        // handle mint\n        handleMint(_amount, _to);\n    }\n\n    function wlMint(uint256 _amount) public payable {\n        require(wlSaleState, \"Wl not active\");\n        require(wlBalanceOf[msg.sender] >= _amount, \"Not enough wl balance\");\n        verifyMintability(_amount);\n        require(currentWlMints + _amount <= maxWlMints, \"Max wl mints reached\");\n\n        // increase wl mints\n        currentWlMints += _amount;\n\n        // calculate total price\n        uint256 totalPrice = wlMintPrice * _amount;\n        require(totalPrice == msg.value, \"Payment mismatch\");\n\n        // handle wl balance\n        wlBalanceOf[msg.sender] -= _amount;\n\n        // handle coins\n        handleCro(totalPrice);\n\n        // handle mint\n        handleMint(_amount, msg.sender);\n    }\n\n    function mint(uint256 _amount) public payable {\n        require(saleState, \"Sale not active\");\n        verifyMintability(_amount);\n\n        // calculate total price\n        uint256 totalPrice = mintPrice * _amount;\n        require(totalPrice == msg.value, \"Payment mismatch\");\n\n        // handle CRO\n        handleCro(msg.value);\n\n        // handle mint\n        handleMint(_amount, msg.sender);\n    }\n\n    /******************************************************\n     *                                                    *\n     *                 Internal Functions                 *\n     *                                                    *\n     ******************************************************/\n\n    function handleMint(uint256 _amount, address _to) internal {\n        uint256[] memory tokenIdsBought = new uint256[](_amount);\n        for (uint256 i = 0; i < _amount; i++) {\n            uint256 randIndex = _randomIndex() % remainingToAssign;\n            uint256 tokenId = _fillAssignOrder(--remainingToAssign, randIndex) +\n                1;\n            _safeMint(_to, tokenId);\n            tokenIdsBought[i] = tokenId;\n        }\n        emit itemsMinted(tokenIdsBought, msg.sender);\n    }\n\n    function handleCro(uint256 _totalCost) internal {\n        // deposit puushDevRoyalty to puushDevWallet\n        uint256 puushRoyalty = (_totalCost * puushDevRoyalty) / 100;\n        (bool success2, ) = payable(puushDevWallet).call{value: puushRoyalty}(\n            \"\"\n        );\n        require(success2);\n\n        // deposit rest to Project\n        uint256 projectRoyalty = _totalCost - puushRoyalty;\n        (bool success3, ) = payable(projectDevWallet).call{\n            value: projectRoyalty\n        }(\"\");\n        require(success3);\n    }\n\n    function verifyMintability(uint256 _amount) internal view {\n        require(_amount > 0, \"Must mint more than 0 tokens\");\n        uint256 supply = super.totalSupply();\n        require(\n            (supply + _amount) <= maxSupply,\n            \"Mint would exceed Max Supply\"\n        );\n        require(_amount <= 5, \"Cant mint more than 5\");\n    }\n\n    function _randomIndex() internal view returns (uint256) {\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        block.timestamp,\n                        block.difficulty,\n                        remainingToAssign + 12345,\n                        msg.sender\n                    )\n                )\n            ) % remainingToAssign;\n    }\n\n    function _fillAssignOrder(\n        uint256 orderA,\n        uint256 orderB\n    ) internal returns (uint256) {\n        uint256 temp = orderA;\n        if (assignOrders[orderA] > 0) temp = assignOrders[orderA];\n        assignOrders[orderA] = orderB;\n        if (assignOrders[orderB] > 0)\n            assignOrders[orderA] = assignOrders[orderB];\n        assignOrders[orderB] = temp;\n        return assignOrders[orderA];\n    }\n}\n"
    },
    "contracts/NFT/CroginalCatsHalloween.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract CroginalCatsHalloween is ERC721Enumerable, Ownable {\n    using Strings for uint256; // Use OpenZeppelin's Strings library to convert uint256 to string\n\n    constructor()\n        ERC721(\"Croginal Cats: Halloween\", \"CROGCAT:H\")\n        Ownable(msg.sender)\n    {}\n\n    event itemsMinted(uint256[] tokenIds, address buyer);\n\n    uint256 public maxSupply = 300;\n    uint256 public puushDevRoyalty = 10; // 10%\n    address public puushDevWallet;\n    address public croginalDevWallet;\n    uint256 public mintPrice = 350 ether;\n    bool public saleState;\n    uint256 tokenIndex; // used for random token id mint\n    string public baseURI;\n\n    // Random token id mint variables\n    mapping(uint256 => uint256) private assignOrders;\n    uint256 public remainingToAssign = maxSupply;\n\n    /******************************************************\n     *                                                    *\n     *                 Owner Functions                    *\n     *                                                    *\n     ******************************************************/\n\n    function setPuushDevRoyalty(uint256 _royalty) external onlyOwner {\n        puushDevRoyalty = _royalty;\n    }\n\n    function setPuushDevWallet(address _wallet) external onlyOwner {\n        require(_wallet != address(0), \"Invalid wallet address\");\n        puushDevWallet = _wallet;\n    }\n\n    function setCroginalDevWallet(address _wallet) public onlyOwner {\n        require(_wallet != address(0), \"Invalid wallet address\");\n        croginalDevWallet = _wallet;\n    }\n\n    function setMintPrice(uint256 _mintPrice) public onlyOwner {\n        mintPrice = _mintPrice;\n    }\n\n    function setSaleState(bool state) external onlyOwner {\n        saleState = state;\n    }\n\n    function setBaseURI(string memory baseURI_) external onlyOwner {\n        baseURI = baseURI_;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseURI;\n    }\n\n    // Override the tokenURI function to add .json at the end\n    function tokenURI(\n        uint256 tokenId\n    ) public view override returns (string memory) {\n        string memory currentBaseURI = _baseURI();\n        return\n            bytes(currentBaseURI).length > 0\n                ? string(\n                    abi.encodePacked(\n                        currentBaseURI,\n                        tokenIdToString(tokenId),\n                        \".json\"\n                    )\n                )\n                : \"\";\n    }\n\n    // Helper function to convert uint256 to string\n    function tokenIdToString(\n        uint256 tokenId\n    ) internal pure returns (string memory) {\n        return Strings.toString(tokenId); // This assumes you're using OpenZeppelin's Strings library\n    }\n\n    function withdraw() public payable onlyOwner {\n        (bool success, ) = payable(msg.sender).call{\n            value: address(this).balance\n        }(\"\");\n        require(success);\n    }\n\n    /******************************************************\n     *                                                    *\n     *                 Mint Functions                     *\n     *                                                    *\n     ******************************************************/\n\n    // Must be used prior to public mint. TokenIDs will be minted in sequential order\n    function adminMint(uint256 _amount) public onlyOwner {\n        require(\n            willNotExceedMaxSupply(_amount),\n            \"Mint would exceed Max Supply\"\n        );\n        uint256[] memory tokenIds = new uint256[](_amount);\n        for (uint256 i = 0; i < _amount; i++) {\n            uint256 tokenId = _fillAssignOrder(\n                --remainingToAssign,\n                tokenIndex\n            ) + 1;\n            _safeMint(msg.sender, tokenId);\n            tokenIds[i] = tokenId;\n            tokenIndex++;\n        }\n\n        emit itemsMinted(tokenIds, msg.sender);\n    }\n\n    function mint(uint256 _amount) public payable {\n        require(saleState, \"Sale not active\");\n        require(_amount > 0, \"Must mint more than 0 tokens\");\n        require(\n            willNotExceedMaxSupply(_amount),\n            \"Mint would exceed Max Supply\"\n        );\n        require(_amount <= 5, \"Must mint less than 5 tokens at a time\");\n        uint256 payment = mintPrice * _amount;\n        require(payment == msg.value, \"Payment mismatch\");\n\n        uint256 puushRoyalty = (payment * puushDevRoyalty) / 100;\n        uint256 croginalRoyalty = payment - puushRoyalty;\n\n        (bool success1, ) = address(puushDevWallet).call{value: puushRoyalty}(\n            \"\"\n        );\n        require(success1);\n\n        (bool success2, ) = address(croginalDevWallet).call{\n            value: croginalRoyalty\n        }(\"\");\n        require(success2);\n\n        uint256[] memory tokenIds = new uint256[](_amount);\n\n        for (uint256 i = 0; i < _amount; i++) {\n            uint256 randIndex = _randomIndex();\n            uint256 tokenId = _fillAssignOrder(--remainingToAssign, randIndex) +\n                1;\n\n            _safeMint(msg.sender, tokenId);\n            tokenIds[i] = tokenId;\n        }\n\n        emit itemsMinted(tokenIds, _msgSender());\n    }\n\n    /******************************************************\n     *                                                    *\n     *                 Public View Functions              *\n     *                                                    *\n     ******************************************************/\n\n    function willNotExceedMaxSupply(\n        uint256 _amount\n    ) public view returns (bool) {\n        return super.totalSupply() + _amount <= maxSupply;\n    }\n\n    /******************************************************\n     *                                                    *\n     *                 Internal Functions                 *\n     *                                                    *\n     ******************************************************/\n\n    function _randomIndex() internal view returns (uint256) {\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        block.timestamp,\n                        block.difficulty,\n                        remainingToAssign + 12345,\n                        msg.sender\n                    )\n                )\n            ) % remainingToAssign;\n    }\n\n    function _fillAssignOrder(\n        uint256 orderA,\n        uint256 orderB\n    ) internal returns (uint256) {\n        uint256 temp = orderA;\n        if (assignOrders[orderA] > 0) temp = assignOrders[orderA];\n        assignOrders[orderA] = orderB;\n        if (assignOrders[orderB] > 0)\n            assignOrders[orderA] = assignOrders[orderB];\n        assignOrders[orderB] = temp;\n        return assignOrders[orderA];\n    }\n}\n"
    },
    "contracts/NFT/CROtards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract CROtards is ERC721Enumerable, Ownable {\n    uint256 public maxSupply = 222;\n    uint256 private _currentTokenId = 0; // Track current token ID\n\n    // Constructor to initialize token name, symbol, and maximum supply\n    constructor() ERC721(\"CROtards\", \"RTRD R1\") Ownable(msg.sender) {}\n\n    // Admin-only mint function to mint NFTs without cost\n    function adminMint(address to, uint256 amount) public onlyOwner {\n        require(totalSupply() + amount <= maxSupply, \"Exceeds maximum supply\");\n        for (uint256 i = 0; i < amount; i++) {\n            _currentTokenId += 1; // Increment token ID for each mint\n            _safeMint(to, _currentTokenId); // Mint the new token to the given address\n        }\n    }\n\n    string public baseURI;\n\n    function setBaseURI(string memory baseURI_) external onlyOwner {\n        baseURI = baseURI_;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseURI;\n    }\n}\n"
    },
    "contracts/NFT/CROtardsV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract CROtardsV2 is ERC721Enumerable, Ownable {\n    using Strings for uint256;\n\n    constructor() ERC721(\"CROtardsV2\", \"RTRD R2\") Ownable(msg.sender) {}\n\n    event itemsMinted(uint256[] tokenIds, address buyer);\n    event CoinSent(address coin, address from, address to, uint256 amount);\n\n    uint256 public maxSupply = 167;\n    address public puushDevWallet;\n    uint256 public wlMintPrice = 999999 ether;\n    address public mintCoin = address(0);\n    bool public saleState;\n    uint256 tokenIndex; // used for random token id mint\n    string public baseURI;\n    // Random token id mint variables\n    mapping(uint256 => uint256) private assignOrders;\n    uint256 public remainingToAssign = maxSupply;\n    // wl mapping\n    mapping(address => uint256) public wlBalanceOf;\n\n    /******************************************************\n     *                                                    *\n     *                 Owner Functions                    *\n     *                                                    *\n     ******************************************************/\n\n    function setWl(\n        address[] memory _addresses,\n        uint256[] memory _amounts\n    ) external onlyOwner {\n        require(_addresses.length == _amounts.length, \"Array length mismatch\");\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            wlBalanceOf[_addresses[i]] = _amounts[i];\n        }\n    }\n\n    function setPuushDevWallet(address _wallet) external onlyOwner {\n        require(_wallet != address(0), \"Invalid wallet address\");\n        puushDevWallet = _wallet;\n    }\n\n    function setMintCoin(address _coin) external onlyOwner {\n        mintCoin = _coin;\n    }\n\n    function setSaleState(bool state) external onlyOwner {\n        saleState = state;\n    }\n\n    function setBaseURI(string memory baseURI_) external onlyOwner {\n        baseURI = baseURI_;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseURI;\n    }\n\n    // Override the tokenURI function to add .json at the end\n    function tokenURI(\n        uint256 tokenId\n    ) public view override returns (string memory) {\n        string memory currentBaseURI = _baseURI();\n        return\n            bytes(currentBaseURI).length > 0\n                ? string(\n                    abi.encodePacked(\n                        currentBaseURI,\n                        tokenIdToString(tokenId),\n                        \".json\"\n                    )\n                )\n                : \"\";\n    }\n\n    // Helper function to convert uint256 to string\n    function tokenIdToString(\n        uint256 tokenId\n    ) internal pure returns (string memory) {\n        return Strings.toString(tokenId); // This assumes you're using OpenZeppelin's Strings library\n    }\n\n    function withdraw() public payable onlyOwner {\n        (bool success, ) = payable(msg.sender).call{\n            value: address(this).balance\n        }(\"\");\n        require(success);\n    }\n\n    function withdrawERC20(address _token) public onlyOwner {\n        IERC20 token = IERC20(_token);\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    /******************************************************\n     *                                                    *\n     *                 Mint Functions                     *\n     *                                                    *\n     ******************************************************/\n\n    function adminMint(uint256 _amount, address _to) public onlyOwner {\n        require(_to != address(0), \"null addr\");\n        verifyMintability(_amount);\n\n        // handle mint\n        handleMint(_amount, _to);\n    }\n\n    function wlMint(uint256 _amount) public {\n        require(saleState, \"Sale not active\");\n        require(wlBalanceOf[msg.sender] >= _amount, \"Not enough wl balance\");\n        verifyMintability(_amount);\n\n        uint256 totalPrice = wlMintPrice * _amount; // public mint price\n\n        // handle wl balance\n        wlBalanceOf[msg.sender] -= _amount;\n\n        // handle coins\n        sendCoin(mintCoin, msg.sender, puushDevWallet, totalPrice);\n\n        // handle mint\n        handleMint(_amount, msg.sender);\n    }\n\n    /******************************************************\n     *                                                    *\n     *                 Internal Functions                 *\n     *                                                    *\n     ******************************************************/\n\n    function handleMint(uint256 _amount, address _to) internal {\n        uint256[] memory tokenIdsBought = new uint256[](_amount);\n        for (uint256 i = 0; i < _amount; i++) {\n            uint256 randIndex = _randomIndex() % remainingToAssign;\n            uint256 tokenId = _fillAssignOrder(--remainingToAssign, randIndex) +\n                1;\n            _safeMint(_to, tokenId);\n            tokenIdsBought[i] = tokenId;\n        }\n        emit itemsMinted(tokenIdsBought, msg.sender);\n    }\n\n    function sendCoin(\n        address _coinAddress,\n        address _from,\n        address _to,\n        uint256 _coinAmount\n    ) internal {\n        require(_coinAddress != address(0), \"Invalid coin address\");\n        require(_from != address(0), \"Invalid sender address\");\n        require(_to != address(0), \"Invalid recipient address\");\n        require(_coinAmount > 0, \"Coin amount must be greater than 0\");\n\n        IERC20 coin = IERC20(_coinAddress);\n\n        bool success = coin.transferFrom(_from, _to, _coinAmount);\n        require(success, \"Coin transfer failed\");\n\n        emit CoinSent(_coinAddress, _from, _to, _coinAmount);\n    }\n\n    function verifyMintability(uint256 _amount) internal view {\n        require(_amount > 0, \"Must mint more than 0 tokens\");\n        uint256 supply = super.totalSupply();\n        require(\n            (supply + _amount) <= maxSupply,\n            \"Mint would exceed Max Supply\"\n        );\n        require(_amount <= 5, \"Cant mint more than 5\");\n    }\n\n    function _randomIndex() internal view returns (uint256) {\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        block.timestamp,\n                        block.difficulty,\n                        remainingToAssign + 12345,\n                        msg.sender\n                    )\n                )\n            ) % remainingToAssign;\n    }\n\n    function _fillAssignOrder(\n        uint256 orderA,\n        uint256 orderB\n    ) internal returns (uint256) {\n        uint256 temp = orderA;\n        if (assignOrders[orderA] > 0) temp = assignOrders[orderA];\n        assignOrders[orderA] = orderB;\n        if (assignOrders[orderB] > 0)\n            assignOrders[orderA] = assignOrders[orderB];\n        assignOrders[orderB] = temp;\n        return assignOrders[orderA];\n    }\n}\n"
    },
    "contracts/NFT/DarkCandy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract DarkCandy is ERC721Enumerable, Ownable {\n    using Strings for uint256;\n\n    constructor() ERC721(\"Dark Candy\", \"DCANDY\") Ownable(msg.sender) {}\n\n    event itemsMinted(uint256[] tokenIds, address buyer);\n\n    uint256 public maxSupply = 10_000;\n    uint256 public puushDevRoyalty = 10; // 10%\n    address public puushDevWallet;\n    address public projectDevWallet;\n    uint256 public mintPrice = 55 ether;\n    uint256 public wlMintPrice = 35 ether;\n    bool public saleState;\n\n    uint256 tokenIndex; // used for random token id mint\n    string public baseURI;\n\n    // Random token id mint variables\n    mapping(uint256 => uint256) private assignOrders;\n    uint256 public remainingToAssign = maxSupply;\n\n    // wl mapping\n    mapping(address => bool) public isWl;\n\n    /******************************************************\n     *                                                    *\n     *                 Owner Functions                    *\n     *                                                    *\n     ******************************************************/\n\n    function setWl(address[] memory _wl, bool _bool) external onlyOwner {\n        for (uint256 i = 0; i < _wl.length; i++) {\n            isWl[_wl[i]] = _bool;\n        }\n    }\n\n    function setPuushDevRoyalty(uint256 _royalty) external onlyOwner {\n        puushDevRoyalty = _royalty;\n    }\n\n    function setPuushDevWallet(address _wallet) external onlyOwner {\n        require(_wallet != address(0), \"Invalid wallet address\");\n        puushDevWallet = _wallet;\n    }\n\n    function setProjectDevWallet(address _wallet) public onlyOwner {\n        require(_wallet != address(0), \"Invalid wallet address\");\n        projectDevWallet = _wallet;\n    }\n\n    function setMintPrice(uint256 _price) external onlyOwner {\n        mintPrice = _price;\n    }\n\n    function setWLMintPrice(uint256 _price) external onlyOwner {\n        wlMintPrice = _price;\n    }\n\n    function setSaleState(bool state) external onlyOwner {\n        saleState = state;\n    }\n\n    function setBaseURI(string memory baseURI_) external onlyOwner {\n        baseURI = baseURI_;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseURI;\n    }\n\n    // Override the tokenURI function to add .json at the end\n    function tokenURI(\n        uint256 tokenId\n    ) public view override returns (string memory) {\n        string memory currentBaseURI = _baseURI();\n        return\n            bytes(currentBaseURI).length > 0\n                ? string(\n                    abi.encodePacked(\n                        currentBaseURI,\n                        tokenIdToString(tokenId),\n                        \".json\"\n                    )\n                )\n                : \"\";\n    }\n\n    // Helper function to convert uint256 to string\n    function tokenIdToString(\n        uint256 tokenId\n    ) internal pure returns (string memory) {\n        return Strings.toString(tokenId); // This assumes you're using OpenZeppelin's Strings library\n    }\n\n    function withdraw() public payable onlyOwner {\n        (bool success, ) = payable(msg.sender).call{\n            value: address(this).balance\n        }(\"\");\n        require(success);\n    }\n\n    /******************************************************\n     *                                                    *\n     *                 Mint Functions                     *\n     *                                                    *\n     ******************************************************/\n\n    function adminMint(uint256 _amount, address _to) public onlyOwner {\n        require(_to != address(0), \"null addr\");\n        verifyMintability(_amount);\n\n        // handle mint\n        handleMint(_amount, _to);\n    }\n\n    function mint(uint256 _amount) public payable {\n        require(saleState, \"Sale not active\");\n        verifyMintability(_amount);\n\n        uint256 totalPrice = mintPrice * _amount; // public mint price\n        require(totalPrice == msg.value, \"Payment mismatch\");\n\n        // handle CRO\n        handleCro(msg.value);\n\n        // handle mint\n        handleMint(_amount, msg.sender);\n    }\n\n    function wlMint(uint256 _amount) public payable {\n        require(saleState, \"Sale not active\");\n        require(isWl[msg.sender], \"Not in whitelist\");\n        verifyMintability(_amount);\n\n        uint256 totalPrice = wlMintPrice * _amount; // public mint price\n        require(totalPrice == msg.value, \"Payment mismatch\");\n\n        // handle CRO\n        handleCro(msg.value);\n\n        // handle mint\n        handleMint(_amount, msg.sender);\n    }\n\n    /******************************************************\n     *                                                    *\n     *                 Internal Functions                 *\n     *                                                    *\n     ******************************************************/\n\n    function handleMint(uint256 _amount, address _to) internal {\n        uint256[] memory tokenIdsBought = new uint256[](_amount);\n        for (uint256 i = 0; i < _amount; i++) {\n            uint256 randIndex = _randomIndex() % remainingToAssign;\n            uint256 tokenId = _fillAssignOrder(--remainingToAssign, randIndex) +\n                1;\n            _safeMint(_to, tokenId);\n            tokenIdsBought[i] = tokenId;\n        }\n        emit itemsMinted(tokenIdsBought, msg.sender);\n    }\n\n    function handleCro(uint256 _totalCost) internal {\n        // deposit puushDevRoyalty to puushDevWallet\n        uint256 puushRoyalty = (_totalCost * puushDevRoyalty) / 100;\n        (bool success2, ) = payable(puushDevWallet).call{value: puushRoyalty}(\n            \"\"\n        );\n        require(success2);\n\n        // deposit rest to Project\n        uint256 projectRoyalty = _totalCost - puushRoyalty;\n        (bool success3, ) = payable(projectDevWallet).call{\n            value: projectRoyalty\n        }(\"\");\n        require(success3);\n    }\n\n    function verifyMintability(uint256 _amount) internal view {\n        require(_amount > 0, \"Must mint more than 0 tokens\");\n        uint256 supply = super.totalSupply();\n        require(\n            (supply + _amount) <= maxSupply,\n            \"Mint would exceed Max Supply\"\n        );\n        require(_amount <= 100, \"Cant mint more than 100\");\n    }\n\n    function _randomIndex() internal view returns (uint256) {\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        block.timestamp,\n                        block.difficulty,\n                        remainingToAssign + 12345,\n                        msg.sender\n                    )\n                )\n            ) % remainingToAssign;\n    }\n\n    function _fillAssignOrder(\n        uint256 orderA,\n        uint256 orderB\n    ) internal returns (uint256) {\n        uint256 temp = orderA;\n        if (assignOrders[orderA] > 0) temp = assignOrders[orderA];\n        assignOrders[orderA] = orderB;\n        if (assignOrders[orderB] > 0)\n            assignOrders[orderA] = assignOrders[orderB];\n        assignOrders[orderB] = temp;\n        return assignOrders[orderA];\n    }\n}\n"
    },
    "contracts/NFT/Magic404.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract Magic404 is ERC721Enumerable, Ownable {\n    using Strings for uint256;\n    uint256 public maxSupply = 360;\n    uint256 private _currentTokenId = 0; // Track current token ID\n\n    // Constructor to initialize token name, symbol\n    constructor() ERC721(\"Magic404\", \"MAGIC404\") Ownable(msg.sender) {}\n\n    // Admin-only mint function to mint NFTs without cost\n    function adminMint(address to, uint256 amount) public onlyOwner {\n        require(totalSupply() + amount <= maxSupply, \"Exceeds maximum supply\");\n        for (uint256 i = 0; i < amount; i++) {\n            _currentTokenId += 1; // Increment token ID for each mint\n            _safeMint(to, _currentTokenId); // Mint the new token to the given address\n        }\n    }\n\n    string public baseURI;\n\n    function setBaseURI(string memory baseURI_) external onlyOwner {\n        baseURI = baseURI_;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseURI;\n    }\n\n    // Override the tokenURI function to add .json at the end\n    function tokenURI(\n        uint256 tokenId\n    ) public view override returns (string memory) {\n        string memory currentBaseURI = _baseURI();\n        return\n            bytes(currentBaseURI).length > 0\n                ? string(\n                    abi.encodePacked(\n                        currentBaseURI,\n                        tokenIdToString(tokenId),\n                        \".json\"\n                    )\n                )\n                : \"\";\n    }\n\n    // Helper function to convert uint256 to string\n    function tokenIdToString(\n        uint256 tokenId\n    ) internal pure returns (string memory) {\n        return Strings.toString(tokenId); // This assumes you're using OpenZeppelin's Strings library\n    }\n}\n"
    },
    "contracts/NFT/MCGA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MCGA is ERC721Enumerable, Ownable {\n    using Strings for uint256;\n\n    constructor() ERC721(\"MCGA\", \"MCGA\") Ownable(msg.sender) {}\n\n    event itemsMinted(uint256[] tokenIds, address buyer);\n    event CoinSent(address coin, address from, address to, uint256 amount);\n\n    uint256 public maxSupply = 330;\n    uint256 public mintPriceCRO = 250 ether;\n    uint256 public mintPriceERC20 = 1660026560000000000000000;\n    uint256 public puushDevRoyalty = 10; // 10%\n\n    address public puushDevWallet;\n    address public projectDevWallet;\n    address public erc20Contract;\n\n    bool public saleState;\n    string public baseURI;\n\n    // Random token id mint variables\n    uint256 tokenIndex;\n    mapping(uint256 => uint256) private assignOrders;\n    uint256 public remainingToAssign = maxSupply;\n\n    /******************************************************\n     *                                                    *\n     *                 Owner Functions                    *\n     *                                                    *\n     ******************************************************/\n\n    function setErc20Contract(address _erc20Contract) external onlyOwner {\n        erc20Contract = _erc20Contract;\n    }\n\n    function setPuushDevRoyalty(uint256 _royalty) external onlyOwner {\n        puushDevRoyalty = _royalty;\n    }\n\n    function setPuushDevWallet(address _wallet) external onlyOwner {\n        require(_wallet != address(0), \"Invalid wallet address\");\n        puushDevWallet = _wallet;\n    }\n\n    function setProjectDevWallet(address _wallet) public onlyOwner {\n        require(_wallet != address(0), \"Invalid wallet address\");\n        projectDevWallet = _wallet;\n    }\n\n    function setSaleState(bool state) external onlyOwner {\n        saleState = state;\n    }\n\n    function setMintPriceCRO(uint256 _price) external onlyOwner {\n        mintPriceCRO = _price;\n    }\n\n    function setMintPriceERC20(uint256 _price) external onlyOwner {\n        mintPriceERC20 = _price;\n    }\n\n    function setBaseURI(string memory baseURI_) external onlyOwner {\n        baseURI = baseURI_;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseURI;\n    }\n\n    // Override the tokenURI function to add .json at the end\n    function tokenURI(\n        uint256 tokenId\n    ) public view override returns (string memory) {\n        string memory currentBaseURI = _baseURI();\n        return\n            bytes(currentBaseURI).length > 0\n                ? string(\n                    abi.encodePacked(\n                        currentBaseURI,\n                        tokenIdToString(tokenId),\n                        \".json\"\n                    )\n                )\n                : \"\";\n    }\n\n    // Helper function to convert uint256 to string\n    function tokenIdToString(\n        uint256 tokenId\n    ) internal pure returns (string memory) {\n        return Strings.toString(tokenId); // This assumes you're using OpenZeppelin's Strings library\n    }\n\n    function withdraw() public payable onlyOwner {\n        (bool success, ) = payable(msg.sender).call{\n            value: address(this).balance\n        }(\"\");\n        require(success);\n    }\n\n    function withdrawERC20(address _token) public onlyOwner {\n        IERC20 token = IERC20(_token);\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    /******************************************************\n     *                                                    *\n     *                 Mint Functions                     *\n     *                                                    *\n     ******************************************************/\n\n    function adminMintSpecificTokenIds(\n        uint256[] memory _tokenIds,\n        address _to\n    ) public onlyOwner {\n        require(_to != address(0), \"null addr\");\n        require(_tokenIds.length > 0, \"Must mint more than 0 tokens\");\n        uint256 supply = super.totalSupply();\n        require(\n            (supply + _tokenIds.length) <= maxSupply,\n            \"Mint would exceed Max Supply\"\n        );\n\n        uint256[] memory mintedTokenIds = new uint256[](_tokenIds.length);\n\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            uint256 tokenIdToMint = _tokenIds[i];\n            require(\n                tokenIdToMint > 0 && tokenIdToMint <= maxSupply,\n                \"Invalid tokenId\"\n            );\n\n            // Decrement remainingToAssign to get the orderA index\n            // Note: tokenIdToMint - 1 (zero-based) is used as orderB\n            uint256 chosenTokenZeroBased = _fillAssignOrder(\n                --remainingToAssign,\n                tokenIdToMint - 1\n            );\n            uint256 finalTokenId = chosenTokenZeroBased + 1;\n\n            require(\n                finalTokenId == tokenIdToMint,\n                \"Token ID mismatch; shuffle state altered.\"\n            );\n\n            _safeMint(_to, finalTokenId);\n            mintedTokenIds[i] = finalTokenId;\n        }\n\n        emit itemsMinted(mintedTokenIds, msg.sender);\n    }\n\n    function adminMint(uint256 _amount, address _to) public onlyOwner {\n        require(_to != address(0), \"null addr\");\n        verifyMintability(_amount);\n\n        // handle mint\n        handleMint(_amount, _to);\n    }\n\n    function mint(uint256 _amount) public payable {\n        require(saleState, \"Sale not active\");\n        verifyMintability(_amount);\n\n        // calculate total price CRO\n        uint256 totalPriceCRO = mintPriceCRO * _amount;\n        require(totalPriceCRO == msg.value, \"Payment mismatch\");\n\n        // calculate total price ERC20\n        uint256 totalPriceERC20 = mintPriceERC20 * _amount;\n        IERC20 token = IERC20(erc20Contract);\n\n        // handle ERC20\n        require(\n            token.transferFrom(msg.sender, puushDevWallet, totalPriceERC20),\n            \"ERC20 transfer failed\"\n        );\n\n        // handle CRO\n        handleCro(msg.value);\n\n        // handle mint\n        handleMint(_amount, msg.sender);\n    }\n\n    /******************************************************\n     *                                                    *\n     *                 Internal Functions                 *\n     *                                                    *\n     ******************************************************/\n\n    function handleMint(uint256 _amount, address _to) internal {\n        uint256[] memory tokenIdsBought = new uint256[](_amount);\n        for (uint256 i = 0; i < _amount; i++) {\n            uint256 randIndex = _randomIndex() % remainingToAssign;\n            uint256 tokenId = _fillAssignOrder(--remainingToAssign, randIndex) +\n                1;\n            _safeMint(_to, tokenId);\n            tokenIdsBought[i] = tokenId;\n        }\n        emit itemsMinted(tokenIdsBought, msg.sender);\n    }\n\n    function handleCro(uint256 _totalCost) internal {\n        // deposit puushDevRoyalty to puushDevWallet\n        uint256 puushRoyalty = (_totalCost * puushDevRoyalty) / 100;\n        (bool success2, ) = payable(puushDevWallet).call{value: puushRoyalty}(\n            \"\"\n        );\n        require(success2);\n\n        // deposit rest to Project\n        uint256 projectRoyalty = _totalCost - puushRoyalty;\n        (bool success3, ) = payable(projectDevWallet).call{\n            value: projectRoyalty\n        }(\"\");\n        require(success3);\n    }\n\n    function handleCoin(uint256 _totalCost) internal {\n        // Take all the ERC20 tokens\n        IERC20 token = IERC20(erc20Contract);\n        require(\n            token.transfer(puushDevWallet, _totalCost),\n            \"ERC20 transfer failed\"\n        );\n    }\n\n    function verifyMintability(uint256 _amount) internal view {\n        require(_amount > 0, \"Must mint more than 0 tokens\");\n        uint256 supply = super.totalSupply();\n        require(\n            (supply + _amount) <= maxSupply,\n            \"Mint would exceed Max Supply\"\n        );\n        require(_amount <= 5, \"Cant mint more than 5\");\n    }\n\n    function _randomIndex() internal view returns (uint256) {\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        block.timestamp,\n                        block.difficulty,\n                        remainingToAssign + 12345,\n                        msg.sender\n                    )\n                )\n            ) % remainingToAssign;\n    }\n\n    function _fillAssignOrder(\n        uint256 orderA,\n        uint256 orderB\n    ) internal returns (uint256) {\n        uint256 temp = orderA;\n        if (assignOrders[orderA] > 0) temp = assignOrders[orderA];\n        assignOrders[orderA] = orderB;\n        if (assignOrders[orderB] > 0)\n            assignOrders[orderA] = assignOrders[orderB];\n        assignOrders[orderB] = temp;\n        return assignOrders[orderA];\n    }\n}\n"
    },
    "contracts/NFT/NFTEnumHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\ncontract NFTEnumHelper {\n    constructor() {}\n\n    function viewUserNFTs(\n        address nftContract,\n        address user\n    ) public view returns (uint256[] memory) {\n        uint256 userBalance = IERC721Enumerable(nftContract).balanceOf(user);\n        uint256[] memory tokenIds = new uint256[](userBalance);\n        for (uint256 i = 0; i < userBalance; i++) {\n            tokenIds[i] = IERC721Enumerable(nftContract).tokenOfOwnerByIndex(\n                user,\n                i\n            );\n        }\n        return tokenIds;\n    }\n\n    function viewUserNFTsPaginated(\n        address nftContract,\n        address user,\n        uint256 page,\n        uint256 pageSize\n    ) public view returns (uint256[] memory) {\n        uint256 userBalance = IERC721Enumerable(nftContract).balanceOf(user);\n\n        // Calculate start and end index based on page and page size\n        uint256 startIndex = page * pageSize;\n        uint256 endIndex = startIndex + pageSize;\n\n        // Ensure end index does not exceed user's balance\n        if (endIndex > userBalance) {\n            endIndex = userBalance;\n        }\n\n        // Handle case when startIndex exceeds total balance\n        if (startIndex >= userBalance) {\n            return new uint256[](0); // Return an empty array\n        }\n\n        // Calculate the actual size of the resulting array\n        uint256 resultSize = endIndex - startIndex;\n        uint256[] memory tokenIds = new uint256[](resultSize);\n\n        // Populate tokenIds array\n        for (uint256 i = 0; i < resultSize; i++) {\n            tokenIds[i] = IERC721Enumerable(nftContract).tokenOfOwnerByIndex(\n                user,\n                startIndex + i\n            );\n        }\n\n        return tokenIds;\n    }\n}\n"
    },
    "contracts/NFT/Retro404NFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract Retro404NFT is ERC721Enumerable, Ownable {\n    using Strings for uint256;\n\n    uint256 public maxSupply;\n\n    // Constructor to initialize token name, symbol, and maximum supply\n    constructor(\n        uint256 _maxSupply,\n        string memory _name,\n        string memory _ticker\n    ) ERC721(_name, _ticker) Ownable(msg.sender) {\n        maxSupply = _maxSupply;\n    }\n\n    // Admin-only mint function to mint NFTs without cost\n    function adminMint(address to, uint256 amount) public onlyOwner {\n        require(totalSupply() + amount <= maxSupply, \"Exceeds maximum supply\");\n        for (uint256 i = 0; i < amount; i++) {\n            _safeMint(to, totalSupply() + 1);\n        }\n    }\n\n    string public baseURI;\n\n    function setBaseURI(string memory baseURI_) external onlyOwner {\n        baseURI = baseURI_;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseURI;\n    }\n\n    // Override the tokenURI function to add .json at the end\n    function tokenURI(\n        uint256 tokenId\n    ) public view override returns (string memory) {\n        string memory currentBaseURI = _baseURI();\n        return\n            bytes(currentBaseURI).length > 0\n                ? string(\n                    abi.encodePacked(\n                        currentBaseURI,\n                        tokenIdToString(tokenId),\n                        \".json\"\n                    )\n                )\n                : \"\";\n    }\n\n    // Helper function to convert uint256 to string\n    function tokenIdToString(\n        uint256 tokenId\n    ) internal pure returns (string memory) {\n        return Strings.toString(tokenId);\n    }\n}\n"
    },
    "contracts/PlaygroundMeme.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\ncontract PlaygroundMeme is ERC721Enumerable, Ownable, IERC721Receiver {\n    address public trashCan;\n    address public devWallet;\n\n    constructor(\n        address _trashCan,\n        address _devWallet\n    ) ERC721(\"PlaygroundMeme\", \"PGM\") Ownable(msg.sender) {\n        trashCan = _trashCan;\n        devWallet = _devWallet;\n    }\n\n    /**\n        Events :O\n    */\n\n    event LifeMinted(address minter, address toPlayer, uint256 lifeId);\n    event LifeDestroyed(address owner, uint256 lifeId, uint256 roundsSurvived);\n    event LifeRewarded(address owner, uint256 lifeId, uint256 roundsSurvived);\n    event LifeRegistered(address owner, uint256 lifeId);\n    event CoinSent(\n        address coinAddress,\n        address from,\n        address to,\n        uint256 amount\n    );\n\n    /**\n        Structs ;)\n    */\n\n    uint256 public eliminationRate; // Rate at which Lives get destroyed\n    uint256 public roundTime; // Seconds in between rounds\n    uint256 public roundCount; // Amount of rounds\n    uint256 public lastRoundStartTime; // Last round start time\n    bool public isInProgress; // Playground in progress or not\n    uint256 public devMintFee = 30; // 30% baseline mint fee\n    address public playgroundWinner; // Winner of the Playground\n    uint256 private seed = 8008; // Seed for random function\n    uint256 private lifeCap = 15000; // Maximum amount of Lives\n\n    mapping(address => uint256) public CoinMintPriceMap;\n    mapping(address => uint256) public CoinPrizePoolMap;\n    address[] public Coins;\n\n    struct Life {\n        uint256 roundsSurvived;\n        address owner;\n    }\n\n    /**\n        onlyOwner functions >:]\n    */\n\n    // Setters\n    bool public mintState;\n    mapping(address => bool) public gameMasters;\n\n    function setMintState(bool _state) external onlyOwner {\n        mintState = _state;\n    }\n\n    function setGameMaster(address _add, bool _auth) external onlyOwner {\n        require(_add != address(0), \"null addr\");\n        gameMasters[_add] = _auth;\n    }\n\n    function setPlaygroundSettings(\n        uint256 _eliminationRate, // Lives destroyed every round ex: 50 = 2%, 100 = 1%, 200 = 0.5%\n        uint256 _roundTime // Seconds before next round can begin\n    ) external onlyOwner {\n        isNotStarted(); // Playground must not be in progress\n\n        eliminationRate = _eliminationRate;\n        roundTime = _roundTime;\n    }\n\n    // Used to set the minting using specific coins\n    // Must be used on a coin already added to list using addCoin\n    function setCoinMintPrice(\n        address _coinAddress,\n        uint256 _coinMintPrice\n    ) external onlyOwner {\n        require(_coinMintPrice > 0, \"_coinMintPrice must be greater than 0\");\n        require(_coinAddress != address(0), \"_coinAddress must not be null\");\n        require(\n            CoinMintPriceMap[_coinAddress] > 0,\n            \"_coinAddress must already exist in map\"\n        );\n        // Add price to mapping\n        CoinMintPriceMap[_coinAddress] = _coinMintPrice;\n    }\n\n    function addCoin(\n        address _coinAddress,\n        uint256 _coinMintPrice\n    ) external onlyOwner {\n        require(_coinMintPrice > 0, \"_coinMintPrice must be greater than 0\");\n        require(_coinAddress != address(0), \"_coinAddress must not be null\");\n        require(\n            CoinMintPriceMap[_coinAddress] == 0,\n            \"_coinAddress must be new\"\n        );\n        // Add _coinAddress to mapping\n        CoinMintPriceMap[_coinAddress] = _coinMintPrice;\n        // Add _coinAddress to list of available coins\n        Coins.push(_coinAddress);\n    }\n\n    function removeCoin(address _coinAddress) external onlyOwner {\n        require(CoinMintPriceMap[_coinAddress] > 0, \"_coinAddress must exist\");\n        // Remove _coinAddress from mapping\n        delete CoinMintPriceMap[_coinAddress];\n        // Remove _coinAddress from list of available coins\n        for (uint256 i = 0; i < Coins.length; i++) {\n            if (Coins[i] == _coinAddress) {\n                Coins[i] = Coins[Coins.length - 1];\n                Coins.pop();\n                break;\n            }\n        }\n    }\n\n    function emergencyWithdrawERC20(address _token) external onlyOwner {\n        IERC20 token = IERC20(_token);\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    /**\n        Game Master Functions ^.^\n    */\n\n    function startPlayground() external {\n        isGameMaster(); // must be a game master\n        isNotStarted(); // Playground must not be in progress\n\n        require(roundTime > 0, \"Round time must be set\");\n        require(eliminationRate > 0, \"Elimination rate must be set\");\n\n        // enter starts at current block time\n        lastRoundStartTime = block.timestamp;\n\n        // Playground becomes in progress\n        isInProgress = true;\n\n        // reset round count for potential re-use\n        roundCount = 0;\n    }\n\n    function destroyLives() external {\n        isGameMaster(); // must be a game master\n        isStarted(); // Playground must be in progress\n\n        // must be at least roundtime before next round starts\n        require(\n            block.timestamp >= (lastRoundStartTime + roundTime),\n            \"Must wait until round is over\"\n        );\n\n        uint256 totalLives = balanceOf(address(this));\n        require(totalLives > 1, \"Must not destroy Champion\");\n\n        // calculate amount of Lives to destroy\n        uint256 amountToDestroy = totalLives / eliminationRate;\n\n        // if would destroy less than 1 life, instead destroy 1 life\n        if (amountToDestroy == 0) {\n            amountToDestroy = 1;\n        }\n\n        // to be considerate of upper gas cost, destroy max of 100 at a time\n        if (amountToDestroy > 100) {\n            amountToDestroy = 100;\n        }\n\n        // loop through amount\n        for (uint256 i = 0; i < amountToDestroy; i++) {\n            // select a random number between 0 and totalBalance\n            uint256 randIndex = random(msg.sender, seed + i * 100) %\n                (totalLives - i);\n            // get a random lifeId that is currently in the Playground\n            uint randomLifeId = tokenOfOwnerByIndex(address(this), randIndex);\n            // save rounds survived\n            Lives[randomLifeId].roundsSurvived = roundCount;\n            // burn life\n            _transfer(address(this), trashCan, randomLifeId);\n            emit LifeDestroyed(\n                Lives[randomLifeId].owner,\n                randomLifeId,\n                roundCount\n            );\n        }\n\n        // make lastRoundTime current block\n        lastRoundStartTime = block.timestamp;\n        // increment round count\n        roundCount++;\n    }\n\n    function payChampion() external {\n        isGameMaster(); // must be a game master\n        isStarted(); // Playground must be in progress\n        require(balanceOf(address(this)) == 1, \"Must only be 1 life left\");\n\n        // get champion lifeId\n        uint256 championLifeId = tokenOfOwnerByIndex(address(this), 0);\n        address championAddress = Lives[championLifeId].owner;\n        // Go through list of available tokens and pay out the remaining pot\n        for (uint256 i = 0; i < Coins.length; i++) {\n            address coinAddress = Coins[i];\n            uint256 coinPrizePool = CoinPrizePoolMap[coinAddress];\n            sendCoin(\n                coinAddress,\n                address(this),\n                championAddress,\n                coinPrizePool\n            );\n        }\n\n        // remove life from Playground\n        removeFromPlayground(championLifeId);\n        // record winner\n        playgroundWinner = championAddress;\n        // end Playground\n        isInProgress = false;\n    }\n\n    /**\n        Public Function $.$\n    */\n\n    function exitPlayground(uint256[] memory _lifeIds) public {\n        require(isInProgress, \"Playground must be in progress\");\n        require(_lifeIds.length < 21, \"Must leave with 20 or less at a time\");\n        require(_lifeIds.length > 0, \"Must leave with at least 1\");\n\n        // must be at least roundtime before next round starts\n        require(\n            block.timestamp <= (lastRoundStartTime + roundTime),\n            \"Must wait until next round starts\"\n        );\n\n        for (uint256 i = 0; i < _lifeIds.length; i++) {\n            uint256 _lifeId = _lifeIds[i];\n            require(msg.sender == Lives[_lifeId].owner, \"Must own Life\");\n            executeRemoval(_lifeId);\n        }\n    }\n\n    function mintLife(\n        address _toPlayer,\n        address _coinAddress,\n        uint256 _lifeAmount\n    ) public payable {\n        // Get total mint price based on _coinAddress and _lifeAmount\n        uint256 mintPrice = CoinMintPriceMap[_coinAddress];\n        uint256 totalMintPrice = mintPrice * _lifeAmount;\n\n        // verify mintability\n        verifyMintability(_coinAddress, totalMintPrice, _lifeAmount);\n\n        // Handle ERC20 coin retrieval\n        handleMintFee(_coinAddress, totalMintPrice);\n\n        // Handle life minting\n        executeMint(_toPlayer, _lifeAmount);\n    }\n\n    /**\n        Internal Functions ._.\n    */\n\n    function executeRemoval(uint256 _lifeId) internal {\n        uint256 totalLives = balanceOf(address(this));\n        require(totalLives > 1, \"Must Not Be Champion\");\n        address player = Lives[_lifeId].owner;\n\n        handleExitReward(player);\n\n        // remove lifeId from Playground\n        removeFromPlayground(_lifeId);\n    }\n\n    function executeMint(address _toPlayer, uint256 _lifeAmount) internal {\n        for (uint i = 0; i < _lifeAmount; i++) {\n            uint256 lifeId = (super.totalSupply() + 1);\n            // mint to Playground\n            _safeMint(address(this), lifeId);\n            registerLife(lifeId, _toPlayer);\n\n            emit LifeMinted(msg.sender, _toPlayer, lifeId);\n        }\n    }\n\n    mapping(uint256 => Life) public Lives;\n\n    function registerLife(uint256 _lifeId, address _add) internal {\n        Lives[_lifeId].owner = _add;\n        emit LifeRegistered(_add, _lifeId);\n    }\n\n    function removeFromPlayground(uint256 _lifeId) internal {\n        _transfer(address(this), trashCan, _lifeId);\n        address oldOwner = Lives[_lifeId].owner;\n        Lives[_lifeId].roundsSurvived = roundCount;\n        Lives[_lifeId].owner = address(0);\n\n        emit LifeRewarded(oldOwner, _lifeId, roundCount);\n    }\n\n    function sendCoin(\n        address _coinAddress,\n        address _from,\n        address _to,\n        uint256 _coinAmount\n    ) internal {\n        require(_coinAddress != address(0), \"Invalid coin address\");\n        require(_from != address(0), \"Invalid sender address\");\n        require(_to != address(0), \"Invalid recipient address\");\n        require(_coinAmount > 0, \"Coin amount must be greater than 0\");\n\n        IERC20 coin = IERC20(_coinAddress);\n\n        if (_from == address(this)) {\n            require(\n                coin.balanceOf(address(this)) >= _coinAmount,\n                \"Not enough tokens in contract\"\n            );\n\n            bool success = coin.transfer(_to, _coinAmount);\n            require(success, \"Coin transfer failed\");\n        } else {\n            uint256 allowance = coin.allowance(_from, address(this));\n            require(allowance >= _coinAmount, \"Coin allowance too low\");\n\n            bool success = coin.transferFrom(_from, _to, _coinAmount);\n            require(success, \"Coin transfer failed\");\n        }\n\n        emit CoinSent(_coinAddress, _from, _to, _coinAmount);\n    }\n\n    function verifyMintability(\n        address _coinAddress,\n        uint256 _totalMintPrice,\n        uint256 _lifeAmount\n    ) internal view {\n        require(mintState, \"Mint must be on\");\n        require(_lifeAmount > 0, \"Must mint more than 0\");\n        require(_lifeAmount <= 100, \"Must mint less than 100\");\n        require(_totalMintPrice > 0, \"Coin must have a price\");\n        uint256 userCoinBalance = IERC20(_coinAddress).balanceOf(msg.sender);\n        require(userCoinBalance >= _totalMintPrice, \"Must have enough tokens\");\n        require(\n            super.totalSupply() + _lifeAmount <= lifeCap,\n            \"Must not exceed life cap\"\n        );\n        isNotStarted();\n    }\n\n    // Ensure only game masters can call\n    function isGameMaster() internal view {\n        require(gameMasters[msg.sender] == true, \"Must be game master\");\n    }\n\n    // Ensure Playground is in progress\n    function isStarted() internal view {\n        require(isInProgress, \"Playground must be in progress\");\n    }\n\n    // Ensure Playground is not in progress\n    function isNotStarted() internal view {\n        require(isInProgress == false, \"Playground must not be in progress\");\n    }\n\n    function handleMintFee(\n        address _coinAddress,\n        uint256 _totalMintPrice\n    ) internal {\n        // Calculate tokens to send to dev\n        uint256 toDevAmount = (_totalMintPrice * devMintFee) / 100;\n\n        // Calculate tokens to send to Playground\n        uint256 toPrizePool = _totalMintPrice - toDevAmount;\n        increaseCoinPrizePool(_coinAddress, toPrizePool);\n\n        // Send tokens to dev and contract\n        sendCoin(_coinAddress, msg.sender, devWallet, toDevAmount);\n        sendCoin(_coinAddress, msg.sender, address(this), toPrizePool);\n    }\n\n    function handleExitReward(address _player) internal {\n        // Get player rewards per coin\n        uint256[] memory playerRewards = viewPlayerRewards();\n\n        for (uint i = 0; i < Coins.length; i++) {\n            address coinAddress = Coins[i];\n            uint256 toPlayerAmount = playerRewards[i];\n            // reduce coin prize pool\n            reduceCoinPrizePool(coinAddress, toPlayerAmount);\n            // Send player rewards\n            sendCoin(coinAddress, address(this), _player, toPlayerAmount);\n        }\n    }\n\n    function reduceCoinPrizePool(\n        address _coinAddress,\n        uint256 _amount\n    ) internal {\n        CoinPrizePoolMap[_coinAddress] -= _amount;\n    }\n\n    function increaseCoinPrizePool(\n        address _coinAddress,\n        uint256 _amount\n    ) internal {\n        CoinPrizePoolMap[_coinAddress] += _amount;\n    }\n\n    /**\n        View functions O.O\n    */\n\n    function viewLife(uint256 _lifeId) external view returns (Life memory) {\n        return Lives[_lifeId];\n    }\n\n    struct Playground {\n        uint256[] CoinPrizePoolList;\n        uint256 eliminationRate;\n        uint256 roundTime;\n        uint256 roundCount;\n        uint256 lastRoundStartTime;\n        bool isInProgress;\n    }\n\n    function viewPlayground() external view returns (Playground memory) {\n        // Generate CoinPrizePoolList\n        uint256[] memory CoinPrizePoolList = new uint256[](Coins.length);\n        for (uint256 i = 0; i < Coins.length; i++) {\n            CoinPrizePoolList[i] = CoinPrizePoolMap[Coins[i]];\n        }\n\n        Playground memory playgroundInfo = Playground(\n            CoinPrizePoolList,\n            eliminationRate,\n            roundTime,\n            roundCount,\n            lastRoundStartTime,\n            isInProgress\n        );\n        return playgroundInfo;\n    }\n\n    function viewPlayerRewards() public view returns (uint256[] memory) {\n        uint256 totalLives = balanceOf(address(this));\n\n        // Loop through all Coins and calculate the individual rewards\n        uint256[] memory playerRewards = new uint256[](Coins.length);\n\n        // If no lives are left, return 0 rewards\n        if (totalLives == 0) {\n            return playerRewards;\n        }\n\n        for (uint256 i = 0; i < Coins.length; i++) {\n            address coinAddress = Coins[i];\n            uint256 coinPrizePool = CoinPrizePoolMap[coinAddress];\n            uint256 coinReward = coinPrizePool / totalLives;\n            // Player gets rewarded 90%, other 10% stays in Playground\n            playerRewards[i] = (coinReward * 90) / 100;\n        }\n\n        return playerRewards;\n    }\n\n    function viewCanExit() external view returns (bool) {\n        return block.timestamp <= (lastRoundStartTime + roundTime);\n    }\n\n    uint256 private nonce = 0; // Nonce to ensure different results for subsequent calls\n\n    function random(address addr, uint256 input) internal returns (uint256) {\n        nonce++; // Increment nonce for each call to ensure different results\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        block.timestamp, // Current block timestamp\n                        block.number, // Current block number\n                        block.gaslimit, // Current block gas limit\n                        input, // Additional input provided by the caller\n                        addr, // Address calling the function\n                        nonce // Nonce to ensure different results for subsequent calls\n                    )\n                )\n            );\n    }\n\n    uint256 public amountReceived; // FOR TESTING\n\n    // // Able to recieve ERC721\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        require(\n            msg.sender == address(this),\n            \"This contract can only receive Lives from itself\"\n        );\n        require(!isInProgress, \"Cant deposit Lives when Arena is in progress\");\n        amountReceived++; // FOR TESTING\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/PlaygroundMemeV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\ncontract PlaygroundMemeV2 is ERC721Enumerable, Ownable, IERC721Receiver {\n    address public trashCan;\n    address public devWallet;\n\n    constructor(\n        address _trashCan,\n        address _devWallet\n    ) ERC721(\"PlaygroundMeme\", \"PGM\") Ownable(msg.sender) {\n        trashCan = _trashCan;\n        devWallet = _devWallet;\n    }\n\n    /**\n        Events :O\n    */\n\n    event LifeMinted(address minter, address toPlayer, uint256 lifeId);\n    event LifeDestroyed(address owner, uint256 lifeId, uint256 roundsSurvived);\n    event LifeRewarded(address owner, uint256 lifeId, uint256 roundsSurvived);\n    event LifeRegistered(address owner, uint256 lifeId);\n    event CoinSent(\n        address coinAddress,\n        address from,\n        address to,\n        uint256 amount\n    );\n\n    /**\n        Structs ;)\n    */\n\n    uint256 public eliminationRate; // Rate at which Lives get destroyed\n    uint256 public roundTime; // Seconds in between rounds\n    uint256 public roundCount; // Amount of rounds\n    uint256 public lastRoundStartTime; // Last round start time\n    bool public isInProgress; // Playground in progress or not\n    uint256 public devMintFee = 30; // 30% baseline mint fee\n    address public playgroundWinner; // Winner of the Playground\n    uint256 private seed = 8008; // Seed for random function\n    uint256 private lifeCap = 15000; // Maximum amount of Lives\n\n    mapping(address => uint256) public CoinMintPriceMap;\n    mapping(address => uint256) public CoinPrizePoolMap;\n    address[] public Coins;\n\n    struct Life {\n        uint256 roundsSurvived;\n        address owner;\n    }\n\n    /**\n        onlyOwner functions >:]\n    */\n\n    // Setters\n    bool public mintState;\n    mapping(address => bool) public gameMasters;\n\n    function setMintState(bool _state) external onlyOwner {\n        mintState = _state;\n    }\n\n    function setGameMaster(address _add, bool _auth) external onlyOwner {\n        require(_add != address(0), \"null addr\");\n        gameMasters[_add] = _auth;\n    }\n\n    function setPlaygroundSettings(\n        uint256 _eliminationRate, // Lives destroyed every round ex: 50 = 2%, 100 = 1%, 200 = 0.5%\n        uint256 _roundTime // Seconds before next round can begin\n    ) external onlyOwner {\n        isNotStarted(); // Playground must not be in progress\n\n        eliminationRate = _eliminationRate;\n        roundTime = _roundTime;\n    }\n\n    // Used to set the minting using specific coins\n    // Must be used on a coin already added to list using addCoin\n    function setCoinMintPrice(\n        address _coinAddress,\n        uint256 _coinMintPrice\n    ) external onlyOwner {\n        require(_coinMintPrice > 0, \"_coinMintPrice must be greater than 0\");\n        require(_coinAddress != address(0), \"_coinAddress must not be null\");\n        require(\n            CoinMintPriceMap[_coinAddress] > 0,\n            \"_coinAddress must already exist in map\"\n        );\n        // Add price to mapping\n        CoinMintPriceMap[_coinAddress] = _coinMintPrice;\n    }\n\n    function addCoin(\n        address _coinAddress,\n        uint256 _coinMintPrice\n    ) external onlyOwner {\n        require(_coinMintPrice > 0, \"_coinMintPrice must be greater than 0\");\n        require(_coinAddress != address(0), \"_coinAddress must not be null\");\n        require(\n            CoinMintPriceMap[_coinAddress] == 0,\n            \"_coinAddress must be new\"\n        );\n        // Add _coinAddress to mapping\n        CoinMintPriceMap[_coinAddress] = _coinMintPrice;\n        // Add _coinAddress to list of available coins\n        Coins.push(_coinAddress);\n    }\n\n    function removeCoin(address _coinAddress) external onlyOwner {\n        require(CoinMintPriceMap[_coinAddress] > 0, \"_coinAddress must exist\");\n        // Remove _coinAddress from mapping\n        delete CoinMintPriceMap[_coinAddress];\n        // Remove _coinAddress from list of available coins\n        for (uint256 i = 0; i < Coins.length; i++) {\n            if (Coins[i] == _coinAddress) {\n                Coins[i] = Coins[Coins.length - 1];\n                Coins.pop();\n                break;\n            }\n        }\n    }\n\n    function emergencyWithdrawERC20(address _token) external onlyOwner {\n        IERC20 token = IERC20(_token);\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    /**\n        Game Master Functions ^.^\n    */\n\n    function startPlayground() external {\n        isGameMaster(); // must be a game master\n        isNotStarted(); // Playground must not be in progress\n\n        require(roundTime > 0, \"Round time must be set\");\n        require(eliminationRate > 0, \"Elimination rate must be set\");\n\n        // enter starts at current block time\n        lastRoundStartTime = block.timestamp;\n\n        // Playground becomes in progress\n        isInProgress = true;\n\n        // reset round count for potential re-use\n        roundCount = 0;\n    }\n\n    function destroyLives() external {\n        isGameMaster(); // must be a game master\n        isStarted(); // Playground must be in progress\n\n        // must be at least roundtime before next round starts\n        require(\n            block.timestamp >= (lastRoundStartTime + roundTime),\n            \"Must wait until round is over\"\n        );\n\n        uint256 totalLives = balanceOf(address(this));\n        require(totalLives > 1, \"Must not destroy Champion\");\n\n        // calculate amount of Lives to destroy\n        uint256 amountToDestroy = totalLives / eliminationRate;\n\n        // if would destroy less than 1 life, instead destroy 1 life\n        if (amountToDestroy == 0) {\n            amountToDestroy = 1;\n        }\n\n        // to be considerate of upper gas cost, destroy max of 100 at a time\n        if (amountToDestroy > 100) {\n            amountToDestroy = 100;\n        }\n\n        // loop through amount\n        for (uint256 i = 0; i < amountToDestroy; i++) {\n            // select a random number between 0 and totalBalance\n            uint256 randIndex = random(msg.sender, seed + i * 100) %\n                (totalLives - i);\n            // get a random lifeId that is currently in the Playground\n            uint randomLifeId = tokenOfOwnerByIndex(address(this), randIndex);\n            // save rounds survived\n            Lives[randomLifeId].roundsSurvived = roundCount;\n            // burn life\n            _transfer(address(this), trashCan, randomLifeId);\n            emit LifeDestroyed(\n                Lives[randomLifeId].owner,\n                randomLifeId,\n                roundCount\n            );\n        }\n\n        // make lastRoundTime current block\n        lastRoundStartTime = block.timestamp;\n        // increment round count\n        roundCount++;\n    }\n\n    function payChampion() external {\n        isGameMaster(); // must be a game master\n        isStarted(); // Playground must be in progress\n        require(balanceOf(address(this)) == 1, \"Must only be 1 life left\");\n\n        // get champion lifeId\n        uint256 championLifeId = tokenOfOwnerByIndex(address(this), 0);\n        address championAddress = Lives[championLifeId].owner;\n        // Go through list of available tokens and pay out the remaining pot\n        for (uint256 i = 0; i < Coins.length; i++) {\n            address coinAddress = Coins[i];\n            uint256 coinPrizePool = CoinPrizePoolMap[coinAddress];\n            sendCoin(\n                coinAddress,\n                address(this),\n                championAddress,\n                coinPrizePool\n            );\n        }\n\n        // remove life from Playground\n        removeFromPlayground(championLifeId);\n        // record winner\n        playgroundWinner = championAddress;\n        // end Playground\n        isInProgress = false;\n    }\n\n    /**\n        Public Function $.$\n    */\n\n    function exitPlayground(uint256[] memory _lifeIds) public {\n        require(isInProgress, \"Playground must be in progress\");\n        require(_lifeIds.length < 21, \"Must leave with 20 or less at a time\");\n        require(_lifeIds.length > 0, \"Must leave with at least 1\");\n\n        // must be at least roundtime before next round starts\n        require(\n            block.timestamp <= (lastRoundStartTime + roundTime),\n            \"Must wait until next round starts\"\n        );\n\n        for (uint256 i = 0; i < _lifeIds.length; i++) {\n            uint256 _lifeId = _lifeIds[i];\n            require(msg.sender == Lives[_lifeId].owner, \"Must own Life\");\n            executeRemoval(_lifeId);\n        }\n    }\n\n    function mintLife(\n        address _toPlayer,\n        address _coinAddress,\n        uint256 _lifeAmount\n    ) public {\n        // Get total mint price based on _coinAddress and _lifeAmount\n        uint256 mintPrice = CoinMintPriceMap[_coinAddress];\n        uint256 totalMintPrice = mintPrice * _lifeAmount;\n\n        // verify mintability\n        verifyMintability(_coinAddress, totalMintPrice, _lifeAmount);\n\n        // Handle ERC20 coin retrieval\n        handleMintFee(_coinAddress, totalMintPrice);\n\n        // Handle life minting\n        executeMint(_toPlayer, _lifeAmount);\n    }\n\n    /**\n        Internal Functions ._.\n    */\n\n    function executeRemoval(uint256 _lifeId) internal {\n        uint256 totalLives = balanceOf(address(this));\n        require(totalLives > 1, \"Must Not Be Champion\");\n        address player = Lives[_lifeId].owner;\n\n        handleExitReward(player);\n\n        // remove lifeId from Playground\n        removeFromPlayground(_lifeId);\n    }\n\n    function executeMint(address _toPlayer, uint256 _lifeAmount) internal {\n        for (uint i = 0; i < _lifeAmount; i++) {\n            uint256 lifeId = (super.totalSupply() + 1);\n            // mint to Playground\n            _safeMint(address(this), lifeId);\n            registerLife(lifeId, _toPlayer);\n\n            emit LifeMinted(msg.sender, _toPlayer, lifeId);\n        }\n    }\n\n    mapping(uint256 => Life) public Lives;\n\n    function registerLife(uint256 _lifeId, address _add) internal {\n        Lives[_lifeId].owner = _add;\n        emit LifeRegistered(_add, _lifeId);\n    }\n\n    function removeFromPlayground(uint256 _lifeId) internal {\n        _transfer(address(this), trashCan, _lifeId);\n        address oldOwner = Lives[_lifeId].owner;\n        Lives[_lifeId].roundsSurvived = roundCount;\n        Lives[_lifeId].owner = address(0);\n\n        emit LifeRewarded(oldOwner, _lifeId, roundCount);\n    }\n\n    function sendCoin(\n        address _coinAddress,\n        address _from,\n        address _to,\n        uint256 _coinAmount\n    ) internal {\n        require(_coinAddress != address(0), \"Invalid coin address\");\n        require(_from != address(0), \"Invalid sender address\");\n        require(_to != address(0), \"Invalid recipient address\");\n        require(_coinAmount > 0, \"Coin amount must be greater than 0\");\n\n        IERC20 coin = IERC20(_coinAddress);\n\n        if (_from == address(this)) {\n            require(\n                coin.balanceOf(address(this)) >= _coinAmount,\n                \"Not enough tokens in contract\"\n            );\n\n            bool success = coin.transfer(_to, _coinAmount);\n            require(success, \"Coin transfer failed\");\n        } else {\n            uint256 allowance = coin.allowance(_from, address(this));\n            require(allowance >= _coinAmount, \"Coin allowance too low\");\n\n            bool success = coin.transferFrom(_from, _to, _coinAmount);\n            require(success, \"Coin transfer failed\");\n        }\n\n        emit CoinSent(_coinAddress, _from, _to, _coinAmount);\n    }\n\n    function verifyMintability(\n        address _coinAddress,\n        uint256 _totalMintPrice,\n        uint256 _lifeAmount\n    ) internal view {\n        require(mintState, \"Mint must be on\");\n        require(_lifeAmount > 0, \"Must mint more than 0\");\n        require(_lifeAmount <= 100, \"Must mint less than 100\");\n        require(_totalMintPrice > 0, \"Coin must have a price\");\n        uint256 userCoinBalance = IERC20(_coinAddress).balanceOf(msg.sender);\n        require(userCoinBalance >= _totalMintPrice, \"Must have enough tokens\");\n        require(\n            super.totalSupply() + _lifeAmount <= lifeCap,\n            \"Must not exceed life cap\"\n        );\n        isNotStarted();\n    }\n\n    // Ensure only game masters can call\n    function isGameMaster() internal view {\n        require(gameMasters[msg.sender] == true, \"Must be game master\");\n    }\n\n    // Ensure Playground is in progress\n    function isStarted() internal view {\n        require(isInProgress, \"Playground must be in progress\");\n    }\n\n    // Ensure Playground is not in progress\n    function isNotStarted() internal view {\n        require(isInProgress == false, \"Playground must not be in progress\");\n    }\n\n    function handleMintFee(\n        address _coinAddress,\n        uint256 _totalMintPrice\n    ) internal {\n        // Calculate tokens to send to dev\n        uint256 toDevAmount = (_totalMintPrice * devMintFee) / 100;\n\n        // Calculate tokens to send to Playground\n        uint256 toPrizePool = _totalMintPrice - toDevAmount;\n        increaseCoinPrizePool(_coinAddress, toPrizePool);\n\n        // Send tokens to dev and contract\n        sendCoin(_coinAddress, msg.sender, devWallet, toDevAmount);\n        sendCoin(_coinAddress, msg.sender, address(this), toPrizePool);\n    }\n\n    function handleExitReward(address _player) internal {\n        // Get player rewards per coin\n        uint256[] memory playerRewards = viewPlayerRewards();\n\n        for (uint i = 0; i < Coins.length; i++) {\n            address coinAddress = Coins[i];\n            uint256 toPlayerAmount = playerRewards[i];\n            // reduce coin prize pool\n            reduceCoinPrizePool(coinAddress, toPlayerAmount);\n            // Send player rewards\n            sendCoin(coinAddress, address(this), _player, toPlayerAmount);\n        }\n    }\n\n    function reduceCoinPrizePool(\n        address _coinAddress,\n        uint256 _amount\n    ) internal {\n        CoinPrizePoolMap[_coinAddress] -= _amount;\n    }\n\n    function increaseCoinPrizePool(\n        address _coinAddress,\n        uint256 _amount\n    ) internal {\n        CoinPrizePoolMap[_coinAddress] += _amount;\n    }\n\n    /**\n        View functions O.O\n    */\n\n    function viewLife(uint256 _lifeId) external view returns (Life memory) {\n        return Lives[_lifeId];\n    }\n\n    struct Playground {\n        uint256[] CoinPrizePoolList;\n        uint256 eliminationRate;\n        uint256 roundTime;\n        uint256 roundCount;\n        uint256 lastRoundStartTime;\n        bool isInProgress;\n    }\n\n    function viewPlayground() external view returns (Playground memory) {\n        // Generate CoinPrizePoolList\n        uint256[] memory CoinPrizePoolList = new uint256[](Coins.length);\n        for (uint256 i = 0; i < Coins.length; i++) {\n            CoinPrizePoolList[i] = CoinPrizePoolMap[Coins[i]];\n        }\n\n        Playground memory playgroundInfo = Playground(\n            CoinPrizePoolList,\n            eliminationRate,\n            roundTime,\n            roundCount,\n            lastRoundStartTime,\n            isInProgress\n        );\n        return playgroundInfo;\n    }\n\n    function viewPlayerRewards() public view returns (uint256[] memory) {\n        uint256 totalLives = balanceOf(address(this));\n\n        // Loop through all Coins and calculate the individual rewards\n        uint256[] memory playerRewards = new uint256[](Coins.length);\n\n        // If no lives are left, return 0 rewards\n        if (totalLives == 0) {\n            return playerRewards;\n        }\n\n        for (uint256 i = 0; i < Coins.length; i++) {\n            address coinAddress = Coins[i];\n            uint256 coinPrizePool = CoinPrizePoolMap[coinAddress];\n            uint256 coinReward = coinPrizePool / totalLives;\n            // Player gets rewarded 90%, other 10% stays in Playground\n            playerRewards[i] = (coinReward * 90) / 100;\n        }\n\n        return playerRewards;\n    }\n\n    function viewCanExit() external view returns (bool) {\n        return block.timestamp <= (lastRoundStartTime + roundTime);\n    }\n\n    uint256 private nonce = 0; // Nonce to ensure different results for subsequent calls\n\n    function random(address addr, uint256 input) internal returns (uint256) {\n        nonce++; // Increment nonce for each call to ensure different results\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        block.timestamp, // Current block timestamp\n                        block.number, // Current block number\n                        block.gaslimit, // Current block gas limit\n                        input, // Additional input provided by the caller\n                        addr, // Address calling the function\n                        nonce // Nonce to ensure different results for subsequent calls\n                    )\n                )\n            );\n    }\n\n    uint256 public amountReceived; // FOR TESTING\n\n    // // Able to recieve ERC721\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        require(\n            msg.sender == address(this),\n            \"This contract can only receive Lives from itself\"\n        );\n        require(!isInProgress, \"Cant deposit Lives when Arena is in progress\");\n        amountReceived++; // FOR TESTING\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/PlaygroundMemeV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\ncontract PlaygroundMemeV3 is ERC721Enumerable, Ownable, IERC721Receiver {\n    address public trashCan;\n    address public devWallet;\n\n    constructor(\n        address _trashCan,\n        address _devWallet\n    ) ERC721(\"PlaygroundMeme\", \"PGM\") Ownable(msg.sender) {\n        trashCan = _trashCan;\n        devWallet = _devWallet;\n    }\n\n    /**\n        Events :O\n    */\n\n    event LifeMinted(address minter, address toPlayer, uint256 lifeId);\n    event LifeDestroyed(address owner, uint256 lifeId, uint256 roundsSurvived);\n    event LifeRewarded(address owner, uint256 lifeId, uint256 roundsSurvived);\n    event LifeRegistered(address owner, uint256 lifeId);\n    event CoinSent(\n        address coinAddress,\n        address from,\n        address to,\n        uint256 amount\n    );\n\n    /**\n        Structs ;)\n    */\n\n    uint256 public eliminationRate; // Rate at which Lives get destroyed\n    uint256 public roundTime; // Seconds in between rounds\n    uint256 public roundCount; // Amount of rounds\n    uint256 public lastRoundStartTime; // Last round start time\n    bool public isInProgress; // Playground in progress or not\n    uint256 public devMintFee = 30; // 30% baseline mint fee\n    address public playgroundWinner; // Winner of the Playground\n    uint256 private seed = 8008; // Seed for random function\n    uint256 private lifeCap = 15000; // Maximum amount of Lives\n\n    mapping(address => uint256) public CoinMintPriceMap;\n    mapping(address => uint256) public CoinPrizePoolMap;\n    address[] public Coins;\n\n    struct Life {\n        uint256 roundsSurvived;\n        address owner;\n    }\n\n    /**\n        onlyOwner functions >:]\n    */\n\n    // Setters\n    bool public mintState;\n    mapping(address => bool) public gameMasters;\n\n    function setMintState(bool _state) external onlyOwner {\n        mintState = _state;\n    }\n\n    function setGameMaster(address _add, bool _auth) external onlyOwner {\n        require(_add != address(0), \"null addr\");\n        gameMasters[_add] = _auth;\n    }\n\n    // 30 = 30%\n    // 10 = 10%\n    function setDevMintFee(uint256 _fee) external onlyOwner {\n        require(_fee >= 0, \"Fee must be greater than 0\");\n        devMintFee = _fee;\n    }\n\n    function setLifeCap(uint256 _cap) external onlyOwner {\n        require(_cap > 0, \"Cap must be greater than 0\");\n        lifeCap = _cap;\n    }\n\n    function setPlaygroundSettings(\n        uint256 _eliminationRate, // Lives destroyed every round ex: 50 = 2%, 100 = 1%, 200 = 0.5%\n        uint256 _roundTime // Seconds before next round can begin\n    ) external onlyOwner {\n        isNotStarted(); // Playground must not be in progress\n\n        eliminationRate = _eliminationRate;\n        roundTime = _roundTime;\n    }\n\n    // Used to set the minting using specific coins\n    // Must be used on a coin already added to list using addCoin\n    function setCoinMintPrice(\n        address _coinAddress,\n        uint256 _coinMintPrice\n    ) external onlyOwner {\n        require(_coinMintPrice > 0, \"_coinMintPrice must be greater than 0\");\n        require(_coinAddress != address(0), \"_coinAddress must not be null\");\n        require(\n            CoinMintPriceMap[_coinAddress] > 0,\n            \"_coinAddress must already exist in map\"\n        );\n        // Add price to mapping\n        CoinMintPriceMap[_coinAddress] = _coinMintPrice;\n    }\n\n    function addCoin(\n        address _coinAddress,\n        uint256 _coinMintPrice\n    ) external onlyOwner {\n        require(_coinMintPrice > 0, \"_coinMintPrice must be greater than 0\");\n        require(_coinAddress != address(0), \"_coinAddress must not be null\");\n        require(\n            CoinMintPriceMap[_coinAddress] == 0,\n            \"_coinAddress must be new\"\n        );\n        // Add _coinAddress to mapping\n        CoinMintPriceMap[_coinAddress] = _coinMintPrice;\n        // Add _coinAddress to list of available coins\n        Coins.push(_coinAddress);\n    }\n\n    function removeCoin(address _coinAddress) external onlyOwner {\n        require(CoinMintPriceMap[_coinAddress] > 0, \"_coinAddress must exist\");\n        // Remove _coinAddress from mapping\n        delete CoinMintPriceMap[_coinAddress];\n        // Remove _coinAddress from list of available coins\n        for (uint256 i = 0; i < Coins.length; i++) {\n            if (Coins[i] == _coinAddress) {\n                Coins[i] = Coins[Coins.length - 1];\n                Coins.pop();\n                break;\n            }\n        }\n    }\n\n    function emergencyWithdrawERC20(address _token) external onlyOwner {\n        IERC20 token = IERC20(_token);\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    /**\n        Game Master Functions ^.^\n    */\n\n    function startPlayground() external {\n        isGameMaster(); // must be a game master\n        isNotStarted(); // Playground must not be in progress\n\n        require(roundTime > 0, \"Round time must be set\");\n        require(eliminationRate > 0, \"Elimination rate must be set\");\n\n        // enter starts at current block time\n        lastRoundStartTime = block.timestamp;\n\n        // Playground becomes in progress\n        isInProgress = true;\n\n        // reset round count for potential re-use\n        roundCount = 0;\n    }\n\n    function destroyLives() external {\n        isGameMaster(); // must be a game master\n        isStarted(); // Playground must be in progress\n\n        // must be at least roundtime before next round starts\n        require(\n            block.timestamp >= (lastRoundStartTime + roundTime),\n            \"Must wait until round is over\"\n        );\n\n        uint256 totalLives = balanceOf(address(this));\n        require(totalLives > 1, \"Must not destroy Champion\");\n\n        // calculate amount of Lives to destroy\n        uint256 amountToDestroy = totalLives / eliminationRate;\n\n        // if would destroy less than 1 life, instead destroy 1 life\n        if (amountToDestroy == 0) {\n            amountToDestroy = 1;\n        }\n\n        // to be considerate of upper gas cost, destroy max of 100 at a time\n        if (amountToDestroy > 100) {\n            amountToDestroy = 100;\n        }\n\n        // loop through amount\n        for (uint256 i = 0; i < amountToDestroy; i++) {\n            // select a random number between 0 and totalBalance\n            uint256 randIndex = random(msg.sender, seed + i * 100) %\n                (totalLives - i);\n            // get a random lifeId that is currently in the Playground\n            uint randomLifeId = tokenOfOwnerByIndex(address(this), randIndex);\n            // save rounds survived\n            Lives[randomLifeId].roundsSurvived = roundCount;\n            // burn life\n            _transfer(address(this), trashCan, randomLifeId);\n            emit LifeDestroyed(\n                Lives[randomLifeId].owner,\n                randomLifeId,\n                roundCount\n            );\n        }\n\n        // make lastRoundTime current block\n        lastRoundStartTime = block.timestamp;\n        // increment round count\n        roundCount++;\n    }\n\n    function payChampion() external {\n        isGameMaster(); // must be a game master\n        isStarted(); // Playground must be in progress\n        require(balanceOf(address(this)) == 1, \"Must only be 1 life left\");\n\n        // get champion lifeId\n        uint256 championLifeId = tokenOfOwnerByIndex(address(this), 0);\n        address championAddress = Lives[championLifeId].owner;\n        // Go through list of available tokens and pay out the remaining pot\n        for (uint256 i = 0; i < Coins.length; i++) {\n            address coinAddress = Coins[i];\n            uint256 coinPrizePool = CoinPrizePoolMap[coinAddress];\n            sendCoin(\n                coinAddress,\n                address(this),\n                championAddress,\n                coinPrizePool\n            );\n        }\n\n        // remove life from Playground\n        removeFromPlayground(championLifeId);\n        // record winner\n        playgroundWinner = championAddress;\n        // end Playground\n        isInProgress = false;\n    }\n\n    /**\n        Public Function $.$\n    */\n\n    function exitPlayground(uint256[] memory _lifeIds) public {\n        require(isInProgress, \"Playground must be in progress\");\n        require(_lifeIds.length < 21, \"Must leave with 20 or less at a time\");\n        require(_lifeIds.length > 0, \"Must leave with at least 1\");\n\n        // must be at least roundtime before next round starts\n        require(\n            block.timestamp <= (lastRoundStartTime + roundTime),\n            \"Must wait until next round starts\"\n        );\n\n        for (uint256 i = 0; i < _lifeIds.length; i++) {\n            uint256 _lifeId = _lifeIds[i];\n            require(msg.sender == Lives[_lifeId].owner, \"Must own Life\");\n            executeRemoval(_lifeId);\n        }\n    }\n\n    function mintLife(\n        address _toPlayer,\n        address _coinAddress,\n        uint256 _lifeAmount\n    ) public {\n        // Get total mint price based on _coinAddress and _lifeAmount\n        uint256 mintPrice = CoinMintPriceMap[_coinAddress];\n        uint256 totalMintPrice = mintPrice * _lifeAmount;\n\n        // verify mintability\n        verifyMintability(_coinAddress, totalMintPrice, _lifeAmount);\n\n        // Handle ERC20 coin retrieval\n        handleMintFee(_coinAddress, totalMintPrice);\n\n        // Handle life minting\n        executeMint(_toPlayer, _lifeAmount);\n    }\n\n    /**\n        Internal Functions ._.\n    */\n\n    function executeRemoval(uint256 _lifeId) internal {\n        uint256 totalLives = balanceOf(address(this));\n        require(totalLives > 1, \"Must Not Be Champion\");\n        address player = Lives[_lifeId].owner;\n\n        handleExitReward(player);\n\n        // remove lifeId from Playground\n        removeFromPlayground(_lifeId);\n    }\n\n    function executeMint(address _toPlayer, uint256 _lifeAmount) internal {\n        for (uint i = 0; i < _lifeAmount; i++) {\n            uint256 lifeId = (super.totalSupply() + 1);\n            // mint to Playground\n            _safeMint(address(this), lifeId);\n            registerLife(lifeId, _toPlayer);\n\n            emit LifeMinted(msg.sender, _toPlayer, lifeId);\n        }\n    }\n\n    mapping(uint256 => Life) public Lives;\n\n    function registerLife(uint256 _lifeId, address _add) internal {\n        Lives[_lifeId].owner = _add;\n        emit LifeRegistered(_add, _lifeId);\n    }\n\n    function removeFromPlayground(uint256 _lifeId) internal {\n        _transfer(address(this), trashCan, _lifeId);\n        address oldOwner = Lives[_lifeId].owner;\n        Lives[_lifeId].roundsSurvived = roundCount;\n        Lives[_lifeId].owner = address(0);\n\n        emit LifeRewarded(oldOwner, _lifeId, roundCount);\n    }\n\n    function sendCoin(\n        address _coinAddress,\n        address _from,\n        address _to,\n        uint256 _coinAmount\n    ) internal {\n        require(_coinAddress != address(0), \"Invalid coin address\");\n        require(_from != address(0), \"Invalid sender address\");\n        require(_to != address(0), \"Invalid recipient address\");\n        require(_coinAmount > 0, \"Coin amount must be greater than 0\");\n\n        IERC20 coin = IERC20(_coinAddress);\n\n        if (_from == address(this)) {\n            require(\n                coin.balanceOf(address(this)) >= _coinAmount,\n                \"Not enough tokens in contract\"\n            );\n\n            bool success = coin.transfer(_to, _coinAmount);\n            require(success, \"Coin transfer failed\");\n        } else {\n            uint256 allowance = coin.allowance(_from, address(this));\n            require(allowance >= _coinAmount, \"Coin allowance too low\");\n\n            bool success = coin.transferFrom(_from, _to, _coinAmount);\n            require(success, \"Coin transfer failed\");\n        }\n\n        emit CoinSent(_coinAddress, _from, _to, _coinAmount);\n    }\n\n    function verifyMintability(\n        address _coinAddress,\n        uint256 _totalMintPrice,\n        uint256 _lifeAmount\n    ) internal view {\n        require(mintState, \"Mint must be on\");\n        require(_lifeAmount > 0, \"Must mint more than 0\");\n        require(_lifeAmount <= 100, \"Must mint less than 100\");\n        require(_totalMintPrice > 0, \"Coin must have a price\");\n        uint256 userCoinBalance = IERC20(_coinAddress).balanceOf(msg.sender);\n        require(userCoinBalance >= _totalMintPrice, \"Must have enough tokens\");\n        require(\n            super.totalSupply() + _lifeAmount <= lifeCap,\n            \"Must not exceed life cap\"\n        );\n        isNotStarted();\n    }\n\n    // Ensure only game masters can call\n    function isGameMaster() internal view {\n        require(gameMasters[msg.sender] == true, \"Must be game master\");\n    }\n\n    // Ensure Playground is in progress\n    function isStarted() internal view {\n        require(isInProgress, \"Playground must be in progress\");\n    }\n\n    // Ensure Playground is not in progress\n    function isNotStarted() internal view {\n        require(isInProgress == false, \"Playground must not be in progress\");\n    }\n\n    function handleMintFee(\n        address _coinAddress,\n        uint256 _totalMintPrice\n    ) internal {\n        // Calculate tokens to send to dev\n        uint256 toDevAmount = (_totalMintPrice * devMintFee) / 100;\n\n        // Calculate tokens to send to Playground\n        uint256 toPrizePool = _totalMintPrice - toDevAmount;\n        increaseCoinPrizePool(_coinAddress, toPrizePool);\n\n        // Send tokens to dev and contract\n        sendCoin(_coinAddress, msg.sender, devWallet, toDevAmount);\n        sendCoin(_coinAddress, msg.sender, address(this), toPrizePool);\n    }\n\n    function handleExitReward(address _player) internal {\n        // Get player rewards per coin\n        uint256[] memory playerRewards = viewPlayerRewards();\n\n        for (uint i = 0; i < Coins.length; i++) {\n            address coinAddress = Coins[i];\n            uint256 toPlayerAmount = playerRewards[i];\n            // reduce coin prize pool\n            reduceCoinPrizePool(coinAddress, toPlayerAmount);\n            // Send player rewards\n            sendCoin(coinAddress, address(this), _player, toPlayerAmount);\n        }\n    }\n\n    function reduceCoinPrizePool(\n        address _coinAddress,\n        uint256 _amount\n    ) internal {\n        CoinPrizePoolMap[_coinAddress] -= _amount;\n    }\n\n    function increaseCoinPrizePool(\n        address _coinAddress,\n        uint256 _amount\n    ) internal {\n        CoinPrizePoolMap[_coinAddress] += _amount;\n    }\n\n    /**\n        View functions O.O\n    */\n\n    function viewLife(uint256 _lifeId) external view returns (Life memory) {\n        return Lives[_lifeId];\n    }\n\n    struct Playground {\n        uint256[] CoinPrizePoolList;\n        uint256 eliminationRate;\n        uint256 roundTime;\n        uint256 roundCount;\n        uint256 lastRoundStartTime;\n        bool isInProgress;\n    }\n\n    function viewPlayground() external view returns (Playground memory) {\n        // Generate CoinPrizePoolList\n        uint256[] memory CoinPrizePoolList = new uint256[](Coins.length);\n        for (uint256 i = 0; i < Coins.length; i++) {\n            CoinPrizePoolList[i] = CoinPrizePoolMap[Coins[i]];\n        }\n\n        Playground memory playgroundInfo = Playground(\n            CoinPrizePoolList,\n            eliminationRate,\n            roundTime,\n            roundCount,\n            lastRoundStartTime,\n            isInProgress\n        );\n        return playgroundInfo;\n    }\n\n    function viewPlayerRewards() public view returns (uint256[] memory) {\n        uint256 totalLives = balanceOf(address(this));\n\n        // Loop through all Coins and calculate the individual rewards\n        uint256[] memory playerRewards = new uint256[](Coins.length);\n\n        // If no lives are left, return 0 rewards\n        if (totalLives == 0) {\n            return playerRewards;\n        }\n\n        for (uint256 i = 0; i < Coins.length; i++) {\n            address coinAddress = Coins[i];\n            uint256 coinPrizePool = CoinPrizePoolMap[coinAddress];\n            uint256 coinReward = coinPrizePool / totalLives;\n            // Player gets rewarded 90%, other 10% stays in Playground\n            playerRewards[i] = (coinReward * 90) / 100;\n        }\n\n        return playerRewards;\n    }\n\n    function viewCanExit() external view returns (bool) {\n        return block.timestamp <= (lastRoundStartTime + roundTime);\n    }\n\n    uint256 private nonce = 0; // Nonce to ensure different results for subsequent calls\n\n    function random(address addr, uint256 input) internal returns (uint256) {\n        nonce++; // Increment nonce for each call to ensure different results\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        block.timestamp, // Current block timestamp\n                        block.number, // Current block number\n                        block.gaslimit, // Current block gas limit\n                        input, // Additional input provided by the caller\n                        addr, // Address calling the function\n                        nonce // Nonce to ensure different results for subsequent calls\n                    )\n                )\n            );\n    }\n\n    uint256 public amountReceived; // FOR TESTING\n\n    // // Able to recieve ERC721\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        require(\n            msg.sender == address(this),\n            \"This contract can only receive Lives from itself\"\n        );\n        require(!isInProgress, \"Cant deposit Lives when Arena is in progress\");\n        amountReceived++; // FOR TESTING\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/PumpCoin/PumpCoin.sol": {
      "content": "// FILE: PumpCoin.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract PumpCoin is ERC20 {\n    /**\n     * @dev Constructor that gives msg.sender all of existing tokens.\n     */\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _mint(msg.sender, 1000000000000000000000000000); // 1 Billion tokens\n    }\n}\n"
    },
    "contracts/PumpCoin/PumpFactory.sol": {
      "content": "// FILE: PumpFactory.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./PumpCoin.sol\";\nimport \"./PumpRouter.sol\";\n\ncontract PumpFactory is Ownable {\n    // PumpRouter public pumpRouter;\n    uint256 public ethCoinCreationCost = 300 ether; // Locked at 300 ETH\n    address payable public feeWallet;\n    address public pumpRouterAddress;\n    mapping(address => address) public pumpFundsMap;\n\n    event CoinCreated(\n        address coinAddress,\n        address fundsAddress,\n        address coinCreator,\n        uint256 coinToFunds,\n        uint256 ethToFunds,\n        string metaURI\n    );\n\n    constructor(address payable _feeWallet) Ownable(msg.sender) {\n        feeWallet = _feeWallet;\n    }\n\n    function setPumpRouter(address _pumpRouterAddress) public onlyOwner {\n        pumpRouterAddress = _pumpRouterAddress;\n    }\n\n    function setEthCoinCreationCost(\n        uint256 _ethCoinCreationCost\n    ) public onlyOwner {\n        ethCoinCreationCost = _ethCoinCreationCost;\n    }\n\n    function createPumpCoinAndAddLiquidity(\n        string memory name,\n        string memory symbol,\n        string memory metaURI\n    ) public payable {\n        require(msg.value == ethCoinCreationCost, \"Incorrect ETH amount\");\n        require(pumpRouterAddress != address(0), \"PumpRouter not set\");\n\n        // Require checks for name and symbol length\n        require(\n            bytes(name).length > 0 && bytes(name).length <= 32,\n            \"Name must be between 1 and 32 characters\"\n        );\n        require(\n            bytes(symbol).length > 0 && bytes(symbol).length <= 10,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n        require(\n            bytes(metaURI).length > 0 && bytes(metaURI).length <= 200,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n\n        // Calculate the fee and the amount to add as liquidity\n        uint256 ethFee = ethCoinCreationCost / 20;\n        uint256 ethToFunds = ethCoinCreationCost - ethFee;\n\n        // Transfer the fee to the PumpWallet\n        feeWallet.transfer(ethFee);\n\n        PumpCoin coin = new PumpCoin(name, symbol);\n\n        // Allow Dev to take up to 5% of the total supply\n        uint256 coinToFunds = coin.totalSupply();\n\n        // Create the PumpFunds contract and add liquidity\n        PumpFunds funds = new PumpFunds(pumpRouterAddress, address(coin));\n        pumpFundsMap[address(coin)] = address(funds);\n\n        // Give funds contract allowance to transfer coins\n        coin.approve(address(funds), coinToFunds);\n\n        // Use the addInitialFunds function to transfer coins and ETH to the funds contract\n        funds.addInitialFunds(coinToFunds);\n\n        emit CoinCreated(\n            address(coin),\n            address(funds),\n            msg.sender,\n            coinToFunds,\n            ethToFunds,\n            metaURI\n        );\n    }\n\n    function getFunds(\n        address coinAddress\n    ) external view returns (address funds) {\n        return pumpFundsMap[coinAddress];\n    }\n}\n"
    },
    "contracts/PumpCoin/PumpFunds.sol": {
      "content": "// FILE: PumpFunds.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\"; // Importing the Math library from OpenZeppelin\n\ncontract PumpFunds {\n    using Math for uint256; // Using the Math library for uint256\n\n    address public factory;\n    address public router;\n    IERC20 public coin;\n    uint256 public ethReserve;\n    uint256 public coinReserve;\n    uint256 public retentionPercentage = 50; // 50% of the fees will be retained\n\n    constructor(address _router, address _coinAddress) {\n        factory = msg.sender;\n        router = _router;\n        coin = IERC20(_coinAddress);\n    }\n\n    modifier onlyFactory() {\n        require(\n            msg.sender == factory,\n            \"Only the factory can call this function\"\n        );\n        _;\n    }\n\n    modifier onlyRouter() {\n        require(\n            msg.sender == router,\n            \"Only the factory can call this function\"\n        );\n        _;\n    }\n\n    function addInitialFunds(uint256 amountCoinDesired) external onlyFactory {\n        require(coin.balanceOf(address(this)) == 0, \"Funds already added\");\n        coinReserve = amountCoinDesired;\n        coin.transferFrom(msg.sender, address(this), amountCoinDesired);\n    }\n\n    function retrieveFunds() external onlyRouter {\n        uint256 ethToTransfer = ethReserve;\n        uint256 coinToTransfer = coinReserve;\n        ethReserve = 0;\n        coinReserve = 0;\n        coin.transfer(msg.sender, coinToTransfer);\n        payable(msg.sender).transfer(ethToTransfer);\n    }\n\n    function emergencyWithdraw() external onlyFactory {\n        uint256 ethToTransfer = payable(address(this)).balance;\n        uint256 coinToTransfer = coin.balanceOf(address(this));\n        coin.transfer(msg.sender, coinToTransfer);\n        payable(msg.sender).transfer(ethToTransfer);\n    }\n\n    function swapETHForCoins(\n        uint256 amountETH,\n        uint256 amountCoinsOutMin,\n        address to,\n        address devWallet\n    ) external payable onlyRouter returns (uint256, uint256, uint256) {\n        require(msg.value == amountETH, \"Incorrect ETH amount\");\n\n        (uint256 coinsOut, uint256 ethFee) = getOutputAmount(amountETH, true);\n        require(coinsOut >= amountCoinsOutMin, \"Insufficient output amount\");\n\n        uint256 retentionFee = ethFee.mulDiv(retentionPercentage, 100);\n        uint256 devFee = ethFee - retentionFee;\n\n        ethReserve += (amountETH - devFee);\n        coinReserve -= coinsOut;\n\n        payable(devWallet).transfer(devFee);\n        // Retain the retentionFee in the contract\n\n        coin.transfer(to, coinsOut);\n\n        return (coinsOut, ethReserve, coinReserve);\n    }\n\n    function swapCoinsForETH(\n        uint256 amountCoins,\n        uint256 amountETHOutMin,\n        address to,\n        address devWallet\n    ) external onlyRouter returns (uint256, uint256, uint256) {\n        (uint256 ethOut, uint256 coinFee) = getOutputAmount(amountCoins, false);\n        require(ethOut >= amountETHOutMin, \"Insufficient output amount\");\n\n        // Ensure the user has sufficient balance before proceeding\n        require(coin.balanceOf(to) >= amountCoins, \"Insufficient user balance\");\n\n        // Ensure the user has allowed the contract to transfer the tokens\n        require(\n            coin.allowance(to, address(this)) >= amountCoins,\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n\n        uint256 retentionFee = coinFee.mulDiv(retentionPercentage, 100);\n        uint256 devFee = coinFee - retentionFee;\n\n        ethReserve -= ethOut;\n        coinReserve += (amountCoins - devFee);\n\n        coin.transferFrom(to, address(this), amountCoins);\n\n        coin.transfer(devWallet, devFee);\n        // Retain the retentionFee in the contract\n\n        payable(to).transfer(ethOut);\n\n        return (ethOut, ethReserve, coinReserve);\n    }\n\n    function getFunds() public view returns (uint256, uint256) {\n        return (coinReserve, ethReserve);\n    }\n\n    // Polynomial coefficients\n    int256[4] public polynomialCoeffs = [\n        int256(1760279),\n        int256(-343392869),\n        int256(25534984100),\n        int256(35749527100)\n    ];\n\n    function getOutputAmount(\n        uint256 inputAmount,\n        bool isBuying\n    ) public view returns (uint256, uint256) {\n        uint256 inputFee = inputAmount.mulDiv(10, 1000); // 1% fee\n        uint256 inputAmountMinusFee = inputAmount - inputFee;\n\n        uint256 outputAmount;\n        if (isBuying) {\n            outputAmount = calculatePolynomialPrice(inputAmountMinusFee);\n        } else {\n            outputAmount = reversePolynomialPrice(inputAmountMinusFee);\n        }\n\n        return (outputAmount, inputFee);\n    }\n\n    function calculatePolynomialPrice(\n        uint256 x\n    ) internal view returns (uint256) {\n        int256 result = polynomialCoeffs[3];\n        result = (result * int256(x)) / 1e6 + polynomialCoeffs[2];\n        result = (result * int256(x)) / 1e6 + polynomialCoeffs[1];\n        result = (result * int256(x)) / 1e6 + polynomialCoeffs[0];\n        return uint256(result);\n    }\n\n    function reversePolynomialPrice(uint256 x) internal view returns (uint256) {\n        // Implement a function to reverse the polynomial calculation.\n        // This could involve numerical methods or solving the polynomial equation.\n        // For simplicity, let's assume the polynomial is in the form ax^3 + bx^2 + cx + d = y.\n        // Given y, we want to solve for x.\n        // Note: This might require more complex math libraries or iterative methods.\n\n        // Placeholder implementation (should be replaced with actual logic):\n        int256 y = int256(x);\n        int256 result = polynomialCoeffs[3];\n        result = (result * y) / 1e6 + polynomialCoeffs[2];\n        result = (result * y) / 1e6 + polynomialCoeffs[1];\n        result = (result * y) / 1e6 + polynomialCoeffs[0];\n        return uint256(result);\n    }\n\n    // function getOutputAmount(\n    //     uint256 inputAmount,\n    //     uint256 inputReserve,\n    //     uint256 outputReserve\n    // ) public pure returns (uint256, uint256) {\n    //     uint256 feeMultiplier = getFeeMultiplier(inputAmount, inputReserve);\n    //     uint256 inputFee = inputAmount.mulDiv(feeMultiplier, 1000); // Dynamic fee\n    //     uint256 inputAmountMinusFee = inputAmount - inputFee;\n\n    //     // Artificially increase the inputReserve to reduce the output amount for early purchases\n    //     uint256 artificialAdjustment = inputAmountMinusFee.mulDiv(\n    //         1000,\n    //         inputReserve\n    //     );\n    //     uint256 adjustedInputReserve = inputReserve + artificialAdjustment;\n\n    //     uint256 numerator = inputAmountMinusFee * outputReserve;\n    //     uint256 denominator = adjustedInputReserve + inputAmountMinusFee;\n    //     return (numerator / denominator, inputFee);\n    // }\n\n    // function getFeeMultiplier(\n    //     uint256 inputAmount,\n    //     uint256 inputReserve\n    // ) internal pure returns (uint256) {\n    //     uint256 baseFee = 10; // 1% base fee (10 / 1000)\n    //     uint256 dynamicFee = (inputAmount.mulDiv(100, inputReserve)) * 3; // Increase fee based on trade size\n    //     if (dynamicFee > 1000) {\n    //         dynamicFee = 890; // Cap the fee at 90%\n    //     }\n    //     return baseFee + dynamicFee;\n    // }\n}\n"
    },
    "contracts/PumpCoin/PumpRouter.sol": {
      "content": "// FILE: PumpRouter.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./PumpFactory.sol\";\nimport \"./PumpFunds.sol\";\n\ncontract PumpRouter is Ownable {\n    using Math for uint256;\n\n    event CoinSwapped(\n        address coinAddress,\n        address userAddress,\n        address coinIn,\n        address coinOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 newEthReserve,\n        uint256 newCoinReserve\n    );\n\n    event GraduatedAndBurned(\n        address coinAddress,\n        address fundsAddress,\n        address graduatePairAddress,\n        uint256 amountCoinsGraduated,\n        uint256 amountEthGraduated,\n        uint256 amountPairBurned\n    );\n\n    PumpFactory private pumpFactory;\n    address public pumpFactoryAddress;\n    IRouter01 public graduateRouter;\n    IFactory public graduateFactory;\n    uint256 public targetMarketCap;\n    address public feeWallet;\n    address public deadAddress = 0x000000000000000000000000000000000000dEaD;\n\n    modifier onlyFactory() {\n        require(\n            msg.sender == address(pumpFactory),\n            \"Only the PumpFactory can call this function\"\n        );\n        _;\n    }\n\n    constructor(\n        uint256 _targetMarketCap,\n        address _graduateRouter,\n        address _graduateFactory,\n        address _feeWallet\n    ) Ownable(msg.sender) {\n        targetMarketCap = _targetMarketCap;\n        graduateRouter = IRouter01(_graduateRouter);\n        graduateFactory = IFactory(_graduateFactory);\n        feeWallet = _feeWallet;\n    }\n\n    function setPumpFactory(address _pumpFactory) public onlyOwner {\n        pumpFactory = PumpFactory(_pumpFactory);\n        pumpFactoryAddress = _pumpFactory;\n    }\n\n    function swapCoins(\n        address coinIn,\n        address coinOut,\n        uint256 amountIn,\n        uint256 amountOutMin\n    ) public payable {\n        if (coinIn == address(0)) {\n            address funds = pumpFactory.getFunds(coinOut);\n            require(funds != address(0), \"Funds do not exist\");\n            // Handling ETH to Coin swap\n            (\n                uint256 amountOut,\n                uint256 newEthReserve,\n                uint256 newCoinReserve\n            ) = PumpFunds(funds).swapETHForCoins{value: amountIn}(\n                    amountIn,\n                    amountOutMin,\n                    msg.sender,\n                    feeWallet\n                );\n            // Monitor market cap after the swap\n            monitorMarketCapAndGraduateCoin(coinOut);\n            emit CoinSwapped(\n                coinOut,\n                msg.sender,\n                address(0),\n                coinOut,\n                amountIn,\n                amountOut,\n                newEthReserve,\n                newCoinReserve\n            );\n        } else if (coinOut == address(0)) {\n            address funds = pumpFactory.getFunds(coinIn);\n            require(funds != address(0), \"Funds do not exist\");\n            // Handling Coin to ETH swap\n            (\n                uint256 amountOut,\n                uint256 newEthReserve,\n                uint256 newCoinReserve\n            ) = PumpFunds(funds).swapCoinsForETH(\n                    amountIn,\n                    amountOutMin,\n                    msg.sender,\n                    feeWallet\n                );\n            // Monitor market cap after the swap\n            monitorMarketCapAndGraduateCoin(coinIn);\n            emit CoinSwapped(\n                coinIn,\n                msg.sender,\n                coinIn,\n                address(0),\n                amountIn,\n                amountOut,\n                newEthReserve,\n                newCoinReserve\n            );\n        } else {\n            revert(\"Invalid coin swap. Must involve ETH.\");\n        }\n    }\n\n    function monitorMarketCapAndGraduateCoin(address coinAddress) internal {\n        uint256 marketCap = getMarketCap(coinAddress);\n        if (marketCap >= targetMarketCap) {\n            address funds = pumpFactory.getFunds(coinAddress);\n            // Get eth and coin balance of funds\n            uint256 fundsEthBalance = address(funds).balance;\n            uint256 fundsCoinBalance = IERC20(coinAddress).balanceOf(funds);\n\n            // Take 5% of both eth and coin from the funds\n            uint256 ethToTake = fundsEthBalance / 20;\n            uint256 coinToTake = fundsCoinBalance / 20;\n\n            uint256 amountEthToGraduate = fundsEthBalance - ethToTake;\n            uint256 amountCoinsToGraduate = fundsCoinBalance - coinToTake;\n\n            // Take all liquidity from the PumpPair\n            PumpFunds(funds).retrieveFunds();\n\n            // Send 10% of the eth and coin to the feeWallet\n            IERC20(coinAddress).transfer(feeWallet, coinToTake);\n            payable(feeWallet).transfer(ethToTake);\n\n            // Add new liquidity on graduate platform\n            graduateAndBurn(\n                coinAddress,\n                amountCoinsToGraduate,\n                amountEthToGraduate\n            );\n        }\n    }\n\n    function graduateAndBurn(\n        address coin,\n        uint256 amountCoin,\n        uint256 amountETH\n    ) internal {\n        address pair = graduateFactory.getPair(coin, address(0));\n        if (pair == address(0)) {\n            // Create the pair if it doesn't exist\n            graduateFactory.createPair(coin, address(0));\n            pair = graduateFactory.getPair(coin, address(0));\n        }\n\n        IERC20(coin).approve(address(graduateRouter), amountCoin);\n\n        graduateRouter.addLiquidityETH{value: amountETH}(\n            coin,\n            amountCoin,\n            0, // Slippage is unavoidable\n            0, // Slippage is unavoidable\n            address(this),\n            block.timestamp\n        );\n\n        // Burn liquidity tokens\n        IERC20(pair).transfer(\n            deadAddress,\n            IERC20(pair).balanceOf(address(this))\n        );\n\n        emit GraduatedAndBurned(\n            coin,\n            pumpFactory.getFunds(coin),\n            pair,\n            amountCoin,\n            amountETH,\n            IERC20(pair).balanceOf(address(this))\n        );\n    }\n\n    function getMarketCap(address coinAddress) public view returns (uint256) {\n        PumpFunds funds = PumpFunds(pumpFactory.getFunds(coinAddress));\n\n        (uint256 coinReserve, uint256 ethReserve) = funds.getFunds();\n\n        require(coinReserve > 0, \"Coin balance must be greater than 0\");\n\n        // Use Math.mulDiv to handle the calculation with full precision\n        uint256 precisionFactor = 10 ** 18; // Use a reasonable precision factor\n        uint256 coinPriceInETH = ethReserve.mulDiv(\n            precisionFactor,\n            coinReserve\n        );\n\n        uint256 totalSupply = IERC20(coinAddress).totalSupply();\n        uint256 marketCap = totalSupply.mulDiv(coinPriceInETH, precisionFactor);\n\n        return marketCap;\n    }\n\n    // To receive ETH from funds contract\n    receive() external payable {}\n}\n\ninterface IFactory {\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair);\n}\n\ninterface IRouter01 {\n    function factory() external pure returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint amountToken, uint amountETH, uint liquidity);\n}\n"
    },
    "contracts/PuushDaButton.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract PuushDaButton is ERC20 {\n    /**\n     * @dev Constructor that gives msg.sender all of existing tokens.\n     */\n    constructor() ERC20(\"Puush Da Button\", \"PUUSH\") {\n        _mint(msg.sender, 8000000000008000000000000000000);\n    }\n}\n"
    },
    "contracts/Puushdot/Agg/IAggFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IAggFactory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n\n    function allPairs(uint) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint);\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/Puushdot/Agg/IAggPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IAggPair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint);\n\n    function permit(\n        address owner,\n        address spender,\n        uint value,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(\n        address indexed sender,\n        uint amount0,\n        uint amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function price0CumulativeLast() external view returns (uint);\n\n    function price1CumulativeLast() external view returns (uint);\n\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n\n    function burn(address to) external returns (uint amount0, uint amount1);\n\n    function swap(\n        uint amount0Out,\n        uint amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/Puushdot/Agg/IAggRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IAggRouter {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint amountOut,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function quote(\n        uint amountA,\n        uint reserveA,\n        uint reserveB\n    ) external pure returns (uint amountB);\n\n    function getAmountOut(\n        uint amountIn,\n        uint reserveIn,\n        uint reserveOut\n    ) external pure returns (uint amountOut);\n\n    function getAmountIn(\n        uint amountOut,\n        uint reserveIn,\n        uint reserveOut\n    ) external pure returns (uint amountIn);\n\n    function getAmountsOut(\n        uint amountIn,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function getAmountsIn(\n        uint amountOut,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/Puushdot/Agg/PuushdotAgg.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IAggRouter.sol\";\nimport \"./IAggFactory.sol\";\nimport \"./IAggPair.sol\";\n\ncontract PuushdotAgg is Ownable {\n    address[] public routers; // Array of all routers\n    address public feeAddress; // Address to receive fees\n    uint256 public feePercentage; // Fee percentage in basis points (e.g., 100 = 1%)\n    address public WCRO; // WCRO token address\n    bool public paused; // Pause flag\n\n    enum SwapType {\n        SwapExactTokensForTokens,\n        SwapTokensForExactTokens,\n        SwapExactTokensForETH,\n        SwapTokensForExactETH,\n        SwapExactETHForTokens,\n        SwapETHForExactTokens\n    }\n\n    // Event to notify users about the swap details\n    event SwapExecuted(\n        address indexed user,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 feeAmount,\n        address indexed bestDex\n    );\n\n    constructor(\n        address _feeAddress,\n        uint256 _feePercentage,\n        address _WCRO\n    ) Ownable(msg.sender) {\n        require(_feePercentage <= 10000, \"Fee too high\"); // Max 100% fee\n        feeAddress = _feeAddress;\n        feePercentage = _feePercentage;\n        WCRO = _WCRO;\n    }\n\n    function emergencyWithdrawERC20(address token) external onlyOwner {\n        IERC20(token).transfer(\n            msg.sender,\n            IERC20(token).balanceOf(address(this))\n        );\n    }\n\n    function emergencyWithdrawETH() external onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function setPaused(bool _paused) external onlyOwner {\n        paused = _paused;\n    }\n\n    // Update fee address\n    function setFeeAddress(address _feeAddress) external onlyOwner {\n        feeAddress = _feeAddress;\n    }\n\n    // Update fee percentage (in basis points)\n    function setFeePercentage(uint256 _feePercentage) external onlyOwner {\n        require(_feePercentage <= 10000, \"Fee too high\");\n        feePercentage = _feePercentage;\n    }\n\n    // Update the WCRO address\n    function setWCRO(address _WCRO) external onlyOwner {\n        WCRO = _WCRO;\n    }\n\n    // Add a new router to the list\n    function addRouter(address router) external onlyOwner {\n        routers.push(router);\n    }\n\n    // Remove a router from the list\n    function removeRouter(address router) external onlyOwner {\n        for (uint256 i = 0; i < routers.length; i++) {\n            if (routers[i] == router) {\n                routers[i] = routers[routers.length - 1];\n                routers.pop();\n                break;\n            }\n        }\n    }\n\n    struct SwapData {\n        uint256 feeAmount;\n        uint256 amountAfterFee;\n        uint256 amountOut;\n        address bestDex;\n    }\n\n    // Calculate fee and return the final amount after deducting the fee for a given exact input amount\n    function calculateFeeExactIn(\n        uint256 amount // Amount before fee\n    ) internal view returns (uint256, uint256) {\n        uint256 feeAmount = (amount * feePercentage) / 10000;\n        uint256 amountAfterFee = amount - feeAmount;\n        return (feeAmount, amountAfterFee);\n    }\n\n    // Calculate fee and return the total amount needed for a given exact output amount\n    function calculateFeeExactOut(\n        uint256 amount // Amount after fee\n    ) internal view returns (uint256, uint256) {\n        // Increase the target output to include the aggregator fee\n        uint256 adjustedAmountIn = (amount * 10000) / (10000 - feePercentage);\n        uint256 feeAmount = adjustedAmountIn - amount;\n        return (feeAmount, adjustedAmountIn);\n    }\n\n    function viewBestSwap(\n        address token1,\n        address token2,\n        uint256 amountSpecified,\n        SwapType swapType\n    )\n        external\n        view\n        returns (address[] memory bestPath, address bestDex, uint256 bestPrice)\n    {\n        require(\n            token1 != address(0) && token2 != address(0),\n            \"Invalid token addresses\"\n        );\n        require(amountSpecified > 0, \"Invalid amount specified\");\n\n        // Initialize variables\n        bestPrice = (swapType == SwapType.SwapExactTokensForTokens ||\n            swapType == SwapType.SwapExactTokensForETH ||\n            swapType == SwapType.SwapExactETHForTokens)\n            ? 0 // Lowest for \"best price out\" searches\n            : type(uint256).max; // Highest for \"best price in\" searches\n        bestDex = address(0);\n\n        // Paths to evaluate\n        address[] memory directPath = new address[](2);\n        directPath[0] = token1;\n        directPath[1] = token2;\n\n        address[] memory indirectPath = new address[](3);\n        indirectPath[0] = token1;\n        indirectPath[1] = WCRO;\n        indirectPath[2] = token2;\n\n        // Evaluate direct path\n        (uint256 directPrice, address directDex) = evaluatePath(\n            directPath,\n            amountSpecified,\n            swapType\n        );\n        if (isBetterPrice(directPrice, bestPrice, swapType)) {\n            bestPrice = directPrice;\n            bestDex = directDex;\n            bestPath = directPath;\n        }\n\n        // Evaluate indirect path\n        (uint256 indirectPrice, address indirectDex) = evaluatePath(\n            indirectPath,\n            amountSpecified,\n            swapType\n        );\n        if (isBetterPrice(indirectPrice, bestPrice, swapType)) {\n            bestPrice = indirectPrice;\n            bestDex = indirectDex;\n            bestPath = indirectPath;\n        }\n\n        require(bestDex != address(0), \"No valid path found\");\n    }\n\n    // Helper function to evaluate a path for the given swap type\n    function evaluatePath(\n        address[] memory path,\n        uint256 amountSpecified,\n        SwapType swapType\n    ) internal view returns (uint256 price, address dex) {\n        if (\n            swapType == SwapType.SwapExactTokensForTokens ||\n            swapType == SwapType.SwapExactTokensForETH ||\n            swapType == SwapType.SwapExactETHForTokens\n        ) {\n            (price, dex) = getBestPriceOut(path, amountSpecified);\n        } else if (\n            swapType == SwapType.SwapTokensForExactTokens ||\n            swapType == SwapType.SwapTokensForExactETH ||\n            swapType == SwapType.SwapETHForExactTokens\n        ) {\n            (price, , dex) = getBestPriceIn(path, amountSpecified);\n        } else {\n            revert(\"Unsupported swap type\");\n        }\n    }\n\n    // Helper function to compare prices\n    function isBetterPrice(\n        uint256 newPrice,\n        uint256 currentBestPrice,\n        SwapType swapType\n    ) internal pure returns (bool) {\n        if (\n            swapType == SwapType.SwapExactTokensForTokens ||\n            swapType == SwapType.SwapExactTokensForETH ||\n            swapType == SwapType.SwapExactETHForTokens\n        ) {\n            return newPrice > currentBestPrice; // Higher is better for \"best price out\"\n        } else {\n            return newPrice < currentBestPrice; // Lower is better for \"best price in\"\n        }\n    }\n\n    // Get the best price for a swap with exact input (getAmountsOut scenario)\n    function getBestPriceOut(\n        address[] memory path,\n        uint256 amountIn\n    ) public view returns (uint256 bestAmountOut, address bestDex) {\n        bestAmountOut = 0;\n        bestDex = address(0);\n\n        // Use calculateFee to get the fee and amount after fee\n        (, uint256 amountAfterFee) = calculateFeeExactIn(amountIn);\n\n        for (uint256 i = 0; i < routers.length; i++) {\n            uint256 amountOut = getAmountsOut(\n                IAggRouter(routers[i]),\n                amountAfterFee,\n                path\n            );\n\n            if (amountOut > bestAmountOut) {\n                bestAmountOut = amountOut;\n                bestDex = routers[i];\n            }\n        }\n    }\n\n    // Get the best price for a swap with exact output (getAmountsIn scenario)\n    function getBestPriceIn(\n        address[] memory path,\n        uint256 amountOut\n    )\n        public\n        view\n        returns (uint256 bestAmountIn, uint256 bestFee, address bestDex)\n    {\n        bestAmountIn = type(uint256).max;\n        bestFee = 0;\n        bestDex = address(0);\n\n        for (uint256 i = 0; i < routers.length; i++) {\n            // Calculate input required for the adjusted output amount\n            uint256 baseAmountIn = getAmountsIn(\n                IAggRouter(routers[i]),\n                amountOut,\n                path\n            );\n\n            // Check if getAmountsIn returned a valid amount\n            if (baseAmountIn == type(uint256).max) {\n                continue;\n            }\n\n            // Adjust the amount in based on the fee\n            (uint256 totalFee, uint256 totalAmountIn) = calculateFeeExactOut(\n                baseAmountIn\n            );\n\n            // Compare against the best input found so far\n            if (totalAmountIn < bestAmountIn) {\n                bestAmountIn = totalAmountIn;\n                bestFee = totalFee;\n                bestDex = routers[i];\n            }\n        }\n    }\n\n    // Main swap function that routes to specific swap functions based on SwapType enum\n    function swap(\n        address[] memory path,\n        uint256 amountSpecified,\n        uint256 amountLimit,\n        address to,\n        SwapType swapFunctionSelector\n    ) external payable {\n        require(!paused, \"Aggregator: Paused\");\n        require(path.length > 1, \"Aggregator: Invalid path\");\n        require(amountSpecified > 0, \"Aggregator: Invalid amount specified\");\n\n        if (swapFunctionSelector == SwapType.SwapExactTokensForTokens) {\n            swapExactTokensForTokens(path, amountSpecified, amountLimit, to);\n        } else if (swapFunctionSelector == SwapType.SwapTokensForExactTokens) {\n            swapTokensForExactTokens(path, amountSpecified, amountLimit, to);\n        } else if (swapFunctionSelector == SwapType.SwapExactTokensForETH) {\n            swapExactTokensForETH(path, amountSpecified, amountLimit, to);\n        } else if (swapFunctionSelector == SwapType.SwapTokensForExactETH) {\n            swapTokensForExactETH(path, amountSpecified, amountLimit, to);\n        } else if (swapFunctionSelector == SwapType.SwapExactETHForTokens) {\n            swapExactETHForTokens(path, amountLimit, to); // Only need amountOutMin here\n        } else if (swapFunctionSelector == SwapType.SwapETHForExactTokens) {\n            swapETHForExactTokens(path, amountSpecified, to); // Only need amountOut here\n        } else {\n            revert(\"Unsupported swap function selector\");\n        }\n    }\n\n    function swapExactTokensForTokens(\n        address[] memory path,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address to\n    ) internal {\n        (uint256 amountOut, address bestDex) = getBestPriceOut(path, amountIn);\n        // Ensure the best DEX is valid\n        require(bestDex != address(0), \"Aggregator: No valid DEX found\");\n        require(amountOut >= amountOutMin, \"Aggregator: Insufficient output\");\n        require(msg.value == 0, \"Aggregator: ETH sent with token swap\");\n\n        (uint256 feeAmount, uint256 amountAfterFee) = calculateFeeExactIn(\n            amountIn\n        );\n        // Transfer fee to fee address\n        IERC20(path[0]).transferFrom(msg.sender, feeAddress, feeAmount);\n\n        // Transfer the remaining amount to the contract for the swap\n        IERC20(path[0]).transferFrom(msg.sender, address(this), amountAfterFee);\n\n        // Approve the best DEX to spend the token\n        IERC20(path[0]).approve(bestDex, amountAfterFee);\n\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(\n                keccak256(\n                    \"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\"\n                )\n            ),\n            amountAfterFee,\n            amountOutMin,\n            path,\n            to,\n            block.timestamp\n        );\n\n        (bool success, bytes memory returnData) = bestDex.call(data);\n        require(success, \"Swap failed\");\n\n        uint256[] memory amounts = abi.decode(returnData, (uint256[]));\n        emit SwapExecuted(\n            msg.sender,\n            amountIn,\n            amounts[amounts.length - 1],\n            feeAmount,\n            bestDex\n        );\n    }\n\n    function swapTokensForExactTokens(\n        address[] memory path,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address to\n    ) internal {\n        require(msg.value == 0, \"Aggregator: ETH sent with token swap\");\n\n        (uint256 amountIn, uint256 feeAmount, address bestDex) = getBestPriceIn(\n            path,\n            amountOut\n        );\n        uint256 amountAfterFee = amountIn - feeAmount;\n        // Ensure the best DEX is valid\n        require(bestDex != address(0), \"Aggregator: No valid DEX found\");\n        require(amountIn <= amountInMax, \"Aggregator: Excessive input\");\n\n        // Transfer fee to fee address\n        IERC20(path[0]).transferFrom(msg.sender, feeAddress, feeAmount);\n\n        // Transfer the remaining amount to the contract for the swap\n        IERC20(path[0]).transferFrom(msg.sender, address(this), amountAfterFee);\n\n        // Approve the best DEX to spend the token\n        IERC20(path[0]).approve(bestDex, amountAfterFee);\n\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(\n                keccak256(\n                    \"swapTokensForExactTokens(uint256,uint256,address[],address,uint256)\"\n                )\n            ),\n            amountOut,\n            amountInMax,\n            path,\n            to,\n            block.timestamp\n        );\n\n        (bool success, bytes memory returnData) = bestDex.call(data);\n        require(success, \"Swap failed\");\n\n        uint256[] memory amounts = abi.decode(returnData, (uint256[]));\n        emit SwapExecuted(\n            msg.sender,\n            amountIn,\n            amounts[amounts.length - 1],\n            feeAmount,\n            bestDex\n        );\n    }\n\n    function swapExactTokensForETH(\n        address[] memory path,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address to\n    ) internal {\n        require(msg.value == 0, \"Aggregator: ETH sent with token swap\");\n\n        (uint256 amountOut, address bestDex) = getBestPriceOut(path, amountIn);\n        // Ensure the best DEX is valid\n        require(bestDex != address(0), \"Aggregator: No valid DEX found\");\n        require(amountOut >= amountOutMin, \"Aggregator: Insufficient output\");\n\n        (uint256 feeAmount, uint256 amountAfterFee) = calculateFeeExactIn(\n            amountIn\n        );\n\n        // Transfer fee to fee address\n        IERC20(path[0]).transferFrom(msg.sender, feeAddress, feeAmount);\n\n        // Transfer the remaining amount to the contract for the swap\n        IERC20(path[0]).transferFrom(msg.sender, address(this), amountAfterFee);\n\n        // Approve the best DEX to spend the token\n        IERC20(path[0]).approve(bestDex, amountAfterFee);\n\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(\n                keccak256(\n                    \"swapExactTokensForETH(uint256,uint256,address[],address,uint256)\"\n                )\n            ),\n            amountAfterFee,\n            amountOutMin,\n            path,\n            to,\n            block.timestamp\n        );\n\n        (bool success, bytes memory returnData) = bestDex.call(data);\n        require(success, \"Swap failed\");\n\n        uint256[] memory amounts = abi.decode(returnData, (uint256[]));\n        emit SwapExecuted(\n            msg.sender,\n            amountIn,\n            amounts[amounts.length - 1],\n            feeAmount,\n            bestDex\n        );\n    }\n\n    function swapTokensForExactETH(\n        address[] memory path,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address to\n    ) internal {\n        require(msg.value == 0, \"Aggregator: ETH sent with token swap\");\n\n        // Get the best DEX and required total input amount to achieve exact ETH output\n        (uint256 amountIn, uint256 feeAmount, address bestDex) = getBestPriceIn(\n            path,\n            amountOut\n        );\n        // Ensure the best DEX is valid\n        require(bestDex != address(0), \"Aggregator: No valid DEX found\");\n\n        // Ensure the calculated input doesn't exceed the specified max input\n        require(amountIn <= amountInMax, \"Aggregator: Excessive input\");\n\n        // Calculate the amount after the aggregator's fee\n        uint256 amountAfterFee = amountIn - feeAmount;\n\n        // Transfer the fee amount to the fee address\n        IERC20(path[0]).transferFrom(msg.sender, feeAddress, feeAmount);\n\n        // Transfer the remaining amount to the contract for the swap\n        IERC20(path[0]).transferFrom(msg.sender, address(this), amountAfterFee);\n\n        // Approve the best DEX to spend the token\n        IERC20(path[0]).approve(bestDex, amountAfterFee);\n\n        // Prepare the swap data\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(\n                keccak256(\n                    \"swapTokensForExactETH(uint256,uint256,address[],address,uint256)\"\n                )\n            ),\n            amountOut,\n            amountInMax,\n            path,\n            to,\n            block.timestamp\n        );\n\n        // Execute the swap on the best DEX\n        (bool success, bytes memory returnData) = bestDex.call(data);\n        require(success, \"Swap failed\");\n\n        // Decode and emit the swap details\n        uint256[] memory amounts = abi.decode(returnData, (uint256[]));\n        emit SwapExecuted(\n            msg.sender,\n            amountIn,\n            amounts[amounts.length - 1],\n            feeAmount,\n            bestDex\n        );\n    }\n\n    function swapExactETHForTokens(\n        address[] memory path,\n        uint256 amountOutMin,\n        address to\n    ) internal {\n        require(msg.value > 0, \"Aggregator: ETH required for swap\");\n        require(path[0] == WCRO, \"Path must start with WCRO\");\n\n        (uint256 feeAmount, uint256 amountAfterFee) = calculateFeeExactIn(\n            msg.value\n        );\n        (uint256 amountOut, address bestDex) = getBestPriceOut(\n            path,\n            amountAfterFee\n        );\n        // Ensure the best DEX is valid, bestDex will be address(0) if no valid DEX found\n        require(bestDex != address(0), \"Aggregator: No valid DEX found\");\n        require(amountOut >= amountOutMin, \"Aggregator: Insufficient output\");\n        // Transfer fee to fee address\n        (bool success1, ) = feeAddress.call{value: feeAmount}(\"\");\n        require(success1, \"Failed to send fee to feeAddress\");\n\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(\n                keccak256(\n                    \"swapExactETHForTokens(uint256,address[],address,uint256)\"\n                )\n            ),\n            amountOutMin,\n            path,\n            to,\n            block.timestamp\n        );\n\n        (bool success2, bytes memory returnData) = bestDex.call{\n            value: amountAfterFee\n        }(data);\n        require(success2, \"Swap failed\");\n\n        uint256[] memory amounts = abi.decode(returnData, (uint256[]));\n        emit SwapExecuted(\n            msg.sender,\n            msg.value,\n            amounts[amounts.length - 1],\n            feeAmount,\n            bestDex\n        );\n    }\n\n    function swapETHForExactTokens(\n        address[] memory path,\n        uint256 amountOut,\n        address to\n    ) internal {\n        require(msg.value > 0, \"Aggregator: ETH required for swap\");\n        require(path[0] == WCRO, \"Path must start with WCRO\");\n\n        // Calculate the total amount of ETH needed, including the fee\n        (uint256 amountIn, uint256 feeAmount, address bestDex) = getBestPriceIn(\n            path,\n            amountOut\n        );\n\n        // Ensure the best DEX is valid, bestDex will be address(0) if no valid DEX found\n        require(bestDex != address(0), \"Aggregator: No valid DEX found\");\n\n        // Ensure the user sent enough ETH for the total amount (including fee)\n        require(msg.value >= amountIn, \"Insufficient ETH provided\");\n\n        // Send the fee to the fee address\n        (bool success1, ) = feeAddress.call{value: feeAmount}(\"\");\n        require(success1, \"Failed to send fee to feeAddress\");\n\n        // Calculate the amount after deducting the aggregator's fee\n        uint256 amountAfterFee = amountIn - feeAmount;\n\n        // Prepare the data for the swap call\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(\n                keccak256(\n                    \"swapETHForExactTokens(uint256,address[],address,uint256)\"\n                )\n            ),\n            amountOut,\n            path,\n            to,\n            block.timestamp\n        );\n\n        // Call the best DEX with the exact amount after fee\n        (bool success2, bytes memory returnData) = bestDex.call{\n            value: amountAfterFee\n        }(data);\n        require(success2, \"Swap failed\");\n\n        // Decode the amounts array to retrieve the final output amount\n        uint256[] memory amounts = abi.decode(returnData, (uint256[]));\n\n        // Refund any excess ETH, if any\n        if (msg.value > amountIn) {\n            (bool success3, ) = msg.sender.call{value: msg.value - amountIn}(\n                \"\"\n            );\n            require(success3, \"Failed to refund excess ETH\");\n        }\n\n        // Emit the swap event with the fee and amount details\n        emit SwapExecuted(\n            msg.sender,\n            amountIn,\n            amounts[amounts.length - 1],\n            feeAmount,\n            bestDex\n        );\n    }\n\n    // Helper function to get output amount from a router (getAmountsOut)\n    function getAmountsOut(\n        IAggRouter router,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256) {\n        try router.getAmountsOut(amountIn, path) returns (\n            uint256[] memory amounts\n        ) {\n            return amounts[amounts.length - 1];\n        } catch {\n            // Return 0 if the route does not exist or if the call fails\n            return 0;\n        }\n    }\n\n    // Helper function to get input amount for a target output from a router (getAmountsIn)\n    function getAmountsIn(\n        IAggRouter router,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256) {\n        try router.getAmountsIn(amountOut, path) returns (\n            uint256[] memory amounts\n        ) {\n            return amounts[0];\n        } catch {\n            // Return max uint256 if the route does not exist or if the call fails\n            return type(uint256).max;\n        }\n    }\n\n    function viewPathLiquidity(\n        address[] memory path\n    ) external view returns (uint256[][][] memory) {\n        require(path.length > 1, \"Invalid path length\");\n\n        // Initialize the liquidity array: [routerIndex][pairIndex][reserveIndex]\n        uint256[][][] memory liquidity = new uint256[][][](routers.length);\n\n        for (uint256 i = 0; i < routers.length; i++) {\n            // view path liquidity for single dex\n            liquidity[i] = viewPathLiquidityForSingleDex(path, routers[i]);\n        }\n\n        return liquidity;\n    }\n\n    function viewPathLiquidityForSingleDex(\n        address[] memory path,\n        address router\n    ) public view returns (uint256[][] memory) {\n        require(path.length > 1, \"Invalid path length\");\n\n        // Initialize the liquidity array: [pairIndex][reserveIndex]\n        uint256[][] memory liquidity = new uint256[][](path.length - 1);\n\n        // Get factory for the current router\n        address factory = IAggRouter(router).factory();\n\n        for (uint256 j = 0; j < path.length - 1; j++) {\n            // Initialize sub-array for this pair's reserves\n            liquidity[j] = new uint256[](2);\n\n            address pair = IAggFactory(factory).getPair(path[j], path[j + 1]);\n            uint256 reserve0 = 0;\n            uint256 reserve1 = 0;\n\n            if (pair != address(0)) {\n                (reserve0, reserve1, ) = IAggPair(pair).getReserves();\n            }\n\n            // Assign reserves\n            liquidity[j][0] = reserve0;\n            liquidity[j][1] = reserve1;\n        }\n\n        return liquidity;\n    }\n}\n"
    },
    "contracts/Puushdot/Agg/PuushdotAggV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./IAggRouter.sol\";\nimport \"./IAggFactory.sol\";\nimport \"./IAggPair.sol\";\n\ncontract PuushdotAggV2 is Ownable, ReentrancyGuard {\n    error Paused();\n    error InvalidPath();\n    error InvalidAmount();\n    error InvalidTokens();\n    error NoValidPathFound();\n    error FeeTooHigh();\n    error EthRequiredForSwap();\n    error UnsupportedSwapType();\n    error InsufficientETHProvided();\n    error InsufficientOutput();\n    error ExcessiveInput();\n    error FailedToSendFee();\n    error FailedToRefund();\n    error SwapFailed();\n    error RouteLengthMismatch();\n    error InvalidFirstPathForSwapAnyETH();\n    error ETHSentWithTokenSwap();\n\n    address[] public routers; // Array of all routers\n    address public feeAddress; // Address to receive fees\n    uint256 public feePercentage; // Fee percentage in basis points (e.g., 100 = 1%)\n    address public WCRO; // WCRO token address\n    bool public paused; // Pause flag\n\n    enum SwapType {\n        SwapExactTokensForTokens,\n        SwapTokensForExactTokens,\n        SwapExactTokensForETH,\n        SwapTokensForExactETH,\n        SwapExactETHForTokens,\n        SwapETHForExactTokens\n    }\n\n    // Event to notify users about the swap details for multi-hop routes\n    event SwapExecuted(\n        address indexed user,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 feeAmount,\n        address[] dexesUsed,\n        address[] path,\n        uint256 timestamp\n    );\n\n    constructor(\n        address _feeAddress,\n        uint256 _feePercentage,\n        address _WCRO\n    ) Ownable(msg.sender) {\n        if (_feePercentage > 10000) revert FeeTooHigh(); // Max 100% fee\n        feeAddress = _feeAddress;\n        feePercentage = _feePercentage;\n        WCRO = _WCRO;\n    }\n\n    function emergencyWithdrawERC20(address token) external onlyOwner {\n        IERC20(token).transfer(\n            msg.sender,\n            IERC20(token).balanceOf(address(this))\n        );\n    }\n\n    function emergencyWithdrawETH() external onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function setPaused(bool _paused) external onlyOwner {\n        paused = _paused;\n    }\n\n    // Update fee address\n    function setFeeAddress(address _feeAddress) external onlyOwner {\n        feeAddress = _feeAddress;\n    }\n\n    // Update fee percentage (in basis points)\n    function setFeePercentage(uint256 _feePercentage) external onlyOwner {\n        if (_feePercentage > 10000) revert FeeTooHigh();\n        feePercentage = _feePercentage;\n    }\n\n    // Update the WCRO address\n    function setWCRO(address _WCRO) external onlyOwner {\n        WCRO = _WCRO;\n    }\n\n    // Add a new router to the list\n    function addRouter(address router) external onlyOwner {\n        routers.push(router);\n    }\n\n    // Remove a router from the list\n    function removeRouter(address router) external onlyOwner {\n        for (uint256 i = 0; i < routers.length; i++) {\n            if (routers[i] == router) {\n                routers[i] = routers[routers.length - 1];\n                routers.pop();\n                break;\n            }\n        }\n    }\n\n    function isExactIn(SwapType swapType) internal pure returns (bool) {\n        return (swapType == SwapType.SwapExactTokensForTokens ||\n            swapType == SwapType.SwapExactTokensForETH ||\n            swapType == SwapType.SwapExactETHForTokens);\n    }\n\n    function isFinalHop(\n        uint256 i,\n        uint256 length\n    ) internal pure returns (bool) {\n        return (i == length - 1);\n    }\n\n    // Calculate fee and return the final amount after deducting the fee for a given exact input amount\n    function calculateFeeExactIn(\n        uint256 amount // Amount before fee\n    ) internal view returns (uint256, uint256) {\n        uint256 feeAmount = (amount * feePercentage) / 10000;\n        uint256 amountAfterFee = amount - feeAmount;\n        return (feeAmount, amountAfterFee);\n    }\n\n    // Calculate fee and return the total amount needed for a given exact output amount\n    function calculateFeeExactOut(\n        uint256 amount // Amount after fee\n    ) internal view returns (uint256, uint256) {\n        // Increase the target output to include the aggregator fee\n        uint256 adjustedAmountIn = (amount * 10000) / (10000 - feePercentage);\n        uint256 feeAmount = adjustedAmountIn - amount;\n        return (feeAmount, adjustedAmountIn);\n    }\n\n    function viewBestSwap(\n        address token1,\n        address token2,\n        uint256 amountSpecified,\n        SwapType swapType\n    )\n        public\n        view\n        returns (\n            address[] memory bestPath,\n            address[] memory bestDexes,\n            uint256 amountCalculated,\n            uint256 feeAmount\n        )\n    {\n        if (token1 == token2) revert InvalidTokens();\n        if (token1 == address(0) || token2 == address(0))\n            revert InvalidTokens();\n        if (amountSpecified == 0) revert InvalidAmount();\n\n        // Construct candidate paths\n        address[] memory directPath = new address[](2);\n        directPath[0] = token1;\n        directPath[1] = token2;\n\n        address[] memory indirectPath = new address[](3);\n        indirectPath[0] = token1;\n        indirectPath[1] = WCRO;\n        indirectPath[2] = token2;\n\n        if (isExactIn(swapType)) {\n            // For exact-in: calculate fee first\n            (uint256 fAmount, uint256 amountAfterFee) = calculateFeeExactIn(\n                amountSpecified\n            );\n            feeAmount = fAmount;\n\n            // Now find the best route to maximize output from amountAfterFee\n            (\n                address[] memory directDexes,\n                uint256 directOut\n            ) = checkMultiDexRoute(directPath, amountAfterFee, swapType);\n            (\n                address[] memory indirectDexes,\n                uint256 indirectOut\n            ) = checkMultiDexRoute(indirectPath, amountAfterFee, swapType);\n\n            // Choose the best output\n            if (isBetterPrice(directOut, indirectOut, swapType)) {\n                amountCalculated = directOut;\n                bestPath = directPath;\n                bestDexes = directDexes;\n            } else {\n                amountCalculated = indirectOut;\n                bestPath = indirectPath;\n                bestDexes = indirectDexes;\n            }\n\n            // amountCalculated is the best output the user can get from the given input (minus fee)\n            // feeAmount already known\n        } else {\n            // For exact-out: find the minimal input (without fee) needed first\n            (\n                address[] memory directDexes,\n                uint256 directIn\n            ) = checkMultiDexRoute(directPath, amountSpecified, swapType);\n            (\n                address[] memory indirectDexes,\n                uint256 indirectIn\n            ) = checkMultiDexRoute(indirectPath, amountSpecified, swapType);\n\n            // Choose the best route (lowest input)\n            uint256 bestIn;\n            if (isBetterPrice(directIn, indirectIn, swapType)) {\n                bestIn = directIn;\n                bestPath = directPath;\n                bestDexes = directDexes;\n            } else {\n                bestIn = indirectIn;\n                bestPath = indirectPath;\n                bestDexes = indirectDexes;\n            }\n\n            // Now apply fee on top of bestIn\n            (feeAmount, amountCalculated) = calculateFeeExactOut(bestIn);\n            // amountCalculated now includes the fee, reflecting the total input required\n        }\n\n        if (bestPath.length == 0) revert NoValidPathFound();\n\n        return (bestPath, bestDexes, amountCalculated, feeAmount);\n    }\n\n    function checkMultiDexRoute(\n        address[] memory path,\n        uint256 amountSpecified,\n        SwapType swapType\n    ) internal view returns (address[] memory dexes, uint256 finalValue) {\n        if (\n            swapType == SwapType.SwapExactTokensForTokens ||\n            swapType == SwapType.SwapExactTokensForETH ||\n            swapType == SwapType.SwapExactETHForTokens\n        ) {\n            // Exact In scenario\n            (finalValue, dexes) = findMultiDexRouteExactIn(\n                path,\n                amountSpecified\n            );\n            return (dexes, finalValue);\n        } else if (\n            swapType == SwapType.SwapTokensForExactTokens ||\n            swapType == SwapType.SwapTokensForExactETH ||\n            swapType == SwapType.SwapETHForExactTokens\n        ) {\n            // Exact Out scenario\n            (finalValue, dexes) = findMultiDexRouteExactOut(\n                path,\n                amountSpecified\n            );\n            return (dexes, finalValue);\n        } else {\n            revert UnsupportedSwapType();\n        }\n    }\n\n    // Helper function to compare prices\n    function isBetterPrice(\n        uint256 newPrice,\n        uint256 currentBestPrice,\n        SwapType swapType\n    ) internal pure returns (bool) {\n        if (\n            swapType == SwapType.SwapExactTokensForTokens ||\n            swapType == SwapType.SwapExactTokensForETH ||\n            swapType == SwapType.SwapExactETHForTokens\n        ) {\n            return newPrice > currentBestPrice; // Higher is better for \"best price out\"\n        } else {\n            return newPrice < currentBestPrice; // Lower is better for \"best price in\"\n        }\n    }\n\n    function findMultiDexRouteExactIn(\n        address[] memory path,\n        uint256 initialAmountIn\n    ) internal view returns (uint256 finalAmountOut, address[] memory dexes) {\n        uint256 hops = path.length - 1;\n        dexes = new address[](hops);\n        uint256 currentAmount = initialAmountIn;\n\n        for (uint256 i = 0; i < hops; i++) {\n            // For the i-th hop, we have a pair: path[i] → path[i+1]\n            (uint256 bestOut, address bestDex) = (0, address(0));\n\n            for (uint256 j = 0; j < routers.length; j++) {\n                uint256 amountOut = safeGetAmountsOut(\n                    IAggRouter(routers[j]),\n                    currentAmount,\n                    _buildPath(path[i], path[i + 1])\n                );\n\n                if (amountOut > bestOut) {\n                    bestOut = amountOut;\n                    bestDex = routers[j];\n                }\n            }\n\n            // If no DEX yields a valid output, route fails\n            if (bestDex == address(0)) {\n                return (0, new address[](0)); // indicates failure\n            }\n\n            dexes[i] = bestDex;\n            currentAmount = bestOut; // output of this hop is input of next\n        }\n\n        finalAmountOut = currentAmount;\n    }\n\n    function findMultiDexRouteExactOut(\n        address[] memory path,\n        uint256 finalAmountOut\n    ) internal view returns (uint256 totalAmountIn, address[] memory dexes) {\n        uint256 hops = path.length - 1;\n        dexes = new address[](hops);\n        uint256 requiredOutput = finalAmountOut;\n\n        // Work backwards from the last pair\n        for (uint256 i = hops; i > 0; i--) {\n            address tokenIn = path[i - 1];\n            address tokenOut = path[i];\n\n            (uint256 bestIn, address bestDex) = (type(uint256).max, address(0));\n\n            for (uint256 j = 0; j < routers.length; j++) {\n                uint256 amountIn = safeGetAmountsIn(\n                    IAggRouter(routers[j]),\n                    requiredOutput,\n                    _buildPath(tokenIn, tokenOut)\n                );\n                if (amountIn < bestIn) {\n                    bestIn = amountIn;\n                    bestDex = routers[j];\n                }\n            }\n\n            if (bestDex == address(0)) {\n                return (type(uint256).max, new address[](0)); // indicates failure\n            }\n\n            dexes[i - 1] = bestDex;\n            requiredOutput = bestIn; // this is now the output needed from the previous hop\n        }\n\n        totalAmountIn = requiredOutput;\n    }\n\n    function _buildPath(\n        address tokenIn,\n        address tokenOut\n    ) internal pure returns (address[] memory singleHop) {\n        singleHop = new address[](2);\n        singleHop[0] = tokenIn;\n        singleHop[1] = tokenOut;\n    }\n\n    // Main swap function that routes to specific swap functions based on SwapType enum\n    function swap(\n        address[] memory path,\n        uint256 amountSpecified,\n        uint256 amountLimit,\n        address to,\n        SwapType swapFunctionSelector\n    ) external payable nonReentrant {\n        if (paused) revert Paused();\n        if (path.length <= 1) revert InvalidPath();\n        if (amountSpecified == 0) revert InvalidAmount();\n\n        if (swapFunctionSelector == SwapType.SwapExactTokensForTokens) {\n            swapExactTokensForTokens(path, amountSpecified, amountLimit, to);\n        } else if (swapFunctionSelector == SwapType.SwapTokensForExactTokens) {\n            swapTokensForExactTokens(path, amountSpecified, amountLimit, to);\n        } else if (swapFunctionSelector == SwapType.SwapExactTokensForETH) {\n            swapExactTokensForETH(path, amountSpecified, amountLimit, to);\n        } else if (swapFunctionSelector == SwapType.SwapTokensForExactETH) {\n            swapTokensForExactETH(path, amountSpecified, amountLimit, to);\n        } else if (swapFunctionSelector == SwapType.SwapExactETHForTokens) {\n            swapExactETHForTokens(path, amountLimit, to);\n        } else if (swapFunctionSelector == SwapType.SwapETHForExactTokens) {\n            swapETHForExactTokens(path, amountSpecified, to);\n        } else {\n            revert UnsupportedSwapType();\n        }\n    }\n\n    function swapExactTokensForTokens(\n        address[] memory path,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address to\n    ) internal {\n        if (msg.value > 0) revert ETHSentWithTokenSwap();\n\n        // Use viewBestSwap to find the best route, fee, and output\n        (\n            address[] memory bestPath,\n            address[] memory dexes,\n            uint256 amountCalculated, // This is the best output amount\n            uint256 feeAmount\n        ) = viewBestSwap(\n                path[0],\n                path[path.length - 1],\n                amountIn,\n                SwapType.SwapExactTokensForTokens\n            );\n\n        // Confirm that the best route matches the provided path length\n        if (bestPath.length != path.length) revert RouteLengthMismatch();\n\n        // Check that we meet the minimum output requirement\n        if (amountCalculated < amountOutMin) revert InsufficientOutput();\n\n        // amountIn is the total input user provides (exact-in)\n        // feeAmount was returned by viewBestSwap\n        // The aggregator takes feeAmount and the remainder goes into the swaps\n        uint256 amountAfterFee = amountIn - feeAmount;\n\n        // Transfer fee to fee address\n        IERC20(path[0]).transferFrom(msg.sender, feeAddress, feeAmount);\n\n        // Transfer amountAfterFee to the contract for the swap\n        IERC20(path[0]).transferFrom(msg.sender, address(this), amountAfterFee);\n\n        // Execute each hop using the dexes provided by viewBestSwap\n        uint256 currentAmountIn = amountAfterFee;\n        for (uint256 i = 0; i < dexes.length; i++) {\n            address tokenIn = path[i];\n            address tokenOut = path[i + 1];\n            address dex = dexes[i];\n\n            IERC20(tokenIn).approve(dex, currentAmountIn);\n\n            address[] memory singleHop = _buildPath(tokenIn, tokenOut);\n            address recipient = (i == dexes.length - 1) ? to : address(this);\n\n            // For intermediate steps, minimum output can be 0 since we trust the route\n            bytes memory data = abi.encodeWithSelector(\n                IAggRouter.swapExactTokensForTokens.selector,\n                currentAmountIn,\n                0,\n                singleHop,\n                recipient,\n                block.timestamp\n            );\n\n            (bool success, bytes memory returnData) = dex.call(data);\n            if (!success) revert SwapFailed();\n\n            uint256[] memory amounts = abi.decode(returnData, (uint256[]));\n            currentAmountIn = amounts[amounts.length - 1];\n        }\n\n        // currentAmountIn is the actual final amount of output tokens received\n        emit SwapExecuted(\n            msg.sender,\n            amountIn,\n            currentAmountIn,\n            feeAmount,\n            dexes,\n            path,\n            block.timestamp\n        );\n    }\n\n    function swapTokensForExactTokens(\n        address[] memory path,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address to\n    ) internal {\n        if (msg.value > 0) revert ETHSentWithTokenSwap();\n\n        // Use viewBestSwap to find the best route and total required input including fee\n        (\n            address[] memory bestPath,\n            address[] memory dexes,\n            uint256 amountCalculated, // This is the total input required including fee\n            uint256 feeAmount\n        ) = viewBestSwap(\n                path[0],\n                path[path.length - 1],\n                amountOut,\n                SwapType.SwapTokensForExactTokens\n            );\n\n        // Confirm that the best route matches the provided path length\n        if (bestPath.length != path.length) revert RouteLengthMismatch();\n\n        // Ensure we do not exceed amountInMax\n        if (amountCalculated > amountInMax) revert ExcessiveInput();\n\n        // amountCalculated is the total input including fee\n        // feeAmount is included in amountCalculated\n\n        // Transfer the total amount to this contract\n        IERC20(path[0]).transferFrom(\n            msg.sender,\n            address(this),\n            amountCalculated\n        );\n\n        // Transfer fee portion to fee address\n        IERC20(path[0]).transfer(feeAddress, feeAmount);\n\n        uint256 currentAmountIn = amountCalculated - feeAmount;\n\n        // We now execute each hop in the path\n        for (uint256 i = 0; i < dexes.length; i++) {\n            address dex = dexes[i];\n            address tokenIn = path[i];\n            address tokenOut = path[i + 1];\n\n            address[] memory singleHop = _buildPath(tokenIn, tokenOut);\n            address recipient = isFinalHop(i, dexes.length)\n                ? to\n                : address(this);\n\n            // Token approval\n            IERC20(tokenIn).approve(dex, currentAmountIn);\n\n            bytes memory data;\n\n            if (isFinalHop(i, dexes.length)) {\n                // Final hop: swapTokensForExactTokens\n                data = abi.encodeWithSelector(\n                    IAggRouter.swapTokensForExactTokens.selector,\n                    amountOut, // amountOut\n                    currentAmountIn, // amountInMax\n                    singleHop,\n                    recipient,\n                    block.timestamp\n                );\n            } else {\n                // Intermediate hop: swapTokensForExactTokens\n                data = abi.encodeWithSelector(\n                    IAggRouter.swapExactTokensForTokens.selector,\n                    currentAmountIn,\n                    0, // minOut is 0 for intermediate hops\n                    singleHop,\n                    recipient,\n                    block.timestamp\n                );\n            }\n\n            (bool success, bytes memory returnData) = dex.call(data);\n            if (!success) revert SwapFailed();\n            uint256[] memory amounts = abi.decode(returnData, (uint256[]));\n            currentAmountIn = amounts[amounts.length - 1]; // This is the input for the final hop\n        }\n\n        // currentAmountIn is now the final output received, which should match amountOut\n        if (currentAmountIn != amountOut) revert InsufficientOutput();\n\n        emit SwapExecuted(\n            msg.sender,\n            amountCalculated, // total input the user spent (including fee)\n            amountOut, // final output received\n            feeAmount,\n            dexes,\n            path,\n            block.timestamp\n        );\n    }\n\n    function swapExactTokensForETH(\n        address[] memory path,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address to\n    ) internal {\n        if (msg.value > 0) revert ETHSentWithTokenSwap();\n        // Path must be length 2: [tokenIn, WCRO]\n        if (path.length != 2) revert RouteLengthMismatch();\n        // The final token must be WCRO for ETH output\n        if (path[1] != WCRO) revert InvalidTokens();\n\n        (\n            address[] memory bestPath,\n            address[] memory dexes,\n            uint256 amountCalculated, // best possible ETH output amount after fee\n            uint256 feeAmount\n        ) = viewBestSwap(\n                path[0],\n                path[1],\n                amountIn,\n                SwapType.SwapExactTokensForETH\n            );\n\n        // Verify that bestPath matches our given path exactly\n        if (\n            bestPath.length != 2 ||\n            bestPath[0] != path[0] ||\n            bestPath[1] != path[1]\n        ) {\n            revert RouteLengthMismatch();\n        }\n\n        // Check output is enough after fee\n        if (amountCalculated < amountOutMin) revert InsufficientOutput();\n\n        // Deduct fee from amountIn and transfer\n        uint256 amountAfterFee = amountIn - feeAmount;\n        IERC20(path[0]).transferFrom(msg.sender, feeAddress, feeAmount);\n        IERC20(path[0]).transferFrom(msg.sender, address(this), amountAfterFee);\n\n        // Single swap: tokenIn -> ETH\n        IERC20(path[0]).approve(dexes[0], amountAfterFee);\n\n        bytes memory data = abi.encodeWithSelector(\n            IAggRouter.swapExactTokensForETH.selector,\n            amountAfterFee,\n            amountOutMin,\n            _buildPath(path[0], path[1]),\n            to,\n            block.timestamp\n        );\n\n        (bool success, bytes memory returnData) = dexes[0].call(data);\n        if (!success) revert SwapFailed();\n\n        uint256[] memory amounts = abi.decode(returnData, (uint256[]));\n        uint256 finalETHOut = amounts[amounts.length - 1];\n\n        // finalETHOut is now the final ETH received\n        // Emit event with the original amountIn and the actual ETH received\n        emit SwapExecuted(\n            msg.sender,\n            amountIn,\n            finalETHOut,\n            feeAmount,\n            dexes,\n            bestPath,\n            block.timestamp\n        );\n    }\n\n    function swapTokensForExactETH(\n        address[] memory path,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address to\n    ) internal {\n        if (msg.value > 0) revert ETHSentWithTokenSwap();\n        // Path must be length 2: [tokenIn, WCRO]\n        if (path.length != 2) revert RouteLengthMismatch();\n        // The final token must be WCRO for ETH output\n        if (path[1] != WCRO) revert InvalidTokens();\n\n        (\n            address[] memory bestPath,\n            address[] memory dexes,\n            uint256 amountCalculated,\n            uint256 feeAmount\n        ) = viewBestSwap(\n                path[0],\n                path[1],\n                amountOut,\n                SwapType.SwapTokensForExactETH\n            );\n\n        // Verify that bestPath matches our given path exactly\n        if (\n            bestPath.length != 2 ||\n            bestPath[0] != path[0] ||\n            bestPath[1] != path[1]\n        ) {\n            revert RouteLengthMismatch();\n        }\n\n        // Check we do not exceed amountInMax\n        if (amountCalculated > amountInMax) revert ExcessiveInput();\n\n        // Transfer total amount (including fee) from user\n        IERC20(path[0]).transferFrom(\n            msg.sender,\n            address(this),\n            amountCalculated\n        );\n\n        // Transfer fee portion to feeAddress\n        IERC20(path[0]).transfer(feeAddress, feeAmount);\n\n        uint256 amountAfterFee = amountCalculated - feeAmount;\n\n        // Single swap: tokenIn -> exact ETH out\n        IERC20(path[0]).approve(dexes[0], amountAfterFee);\n\n        bytes memory data = abi.encodeWithSelector(\n            IAggRouter.swapTokensForExactETH.selector,\n            amountOut, // exact ETH output desired\n            amountAfterFee, // max tokens we can spend\n            _buildPath(path[0], path[1]),\n            to,\n            block.timestamp\n        );\n\n        (bool success, bytes memory returnData) = dexes[0].call(data);\n        if (!success) revert SwapFailed();\n\n        uint256[] memory amounts = abi.decode(returnData, (uint256[]));\n        uint256 finalETHOut = amounts[amounts.length - 1];\n\n        // finalETHOut should equal amountOut since it's exact-out\n        if (finalETHOut != amountOut) revert InsufficientOutput();\n\n        emit SwapExecuted(\n            msg.sender,\n            amountCalculated, // total input user spent (including fee)\n            amountOut, // exact ETH output received\n            feeAmount,\n            dexes,\n            bestPath,\n            block.timestamp\n        );\n    }\n\n    function swapExactETHForTokens(\n        address[] memory path,\n        uint256 amountOutMin,\n        address to\n    ) internal {\n        if (msg.value == 0) revert EthRequiredForSwap();\n        // Path must be exactly two tokens: [WCRO, tokenOut]\n        if (path.length != 2) revert RouteLengthMismatch();\n        if (path[0] != WCRO) revert InvalidFirstPathForSwapAnyETH();\n\n        (\n            address[] memory bestPath,\n            address[] memory dexes,\n            uint256 amountCalculated, // best possible token output after fee\n            uint256 feeAmount\n        ) = viewBestSwap(\n                path[0],\n                path[1],\n                msg.value,\n                SwapType.SwapExactETHForTokens\n            );\n\n        // Check that bestPath matches our given path\n        if (\n            bestPath.length != 2 ||\n            bestPath[0] != path[0] ||\n            bestPath[1] != path[1]\n        ) {\n            revert RouteLengthMismatch();\n        }\n\n        // Ensure we get at least amountOutMin tokens after fees\n        if (amountCalculated < amountOutMin) revert InsufficientOutput();\n\n        (bool feeSent, ) = feeAddress.call{value: feeAmount}(\"\");\n        if (!feeSent) revert FailedToSendFee();\n\n        bytes memory data = abi.encodeWithSelector(\n            IAggRouter.swapExactETHForTokens.selector,\n            amountOutMin, // minOut to ensure at least amountOutMin tokens\n            _buildPath(path[0], path[1]),\n            to,\n            block.timestamp\n        );\n\n        (bool success, bytes memory returnData) = dexes[0].call{\n            value: msg.value - feeAmount\n        }(data);\n        if (!success) revert SwapFailed();\n\n        uint256[] memory amounts = abi.decode(returnData, (uint256[]));\n        uint256 finalTokensOut = amounts[amounts.length - 1];\n\n        // Emit the event with final details\n        emit SwapExecuted(\n            msg.sender,\n            msg.value, // total ETH user sent\n            finalTokensOut, // final tokens received\n            feeAmount,\n            dexes,\n            bestPath,\n            block.timestamp\n        );\n    }\n\n    function swapETHForExactTokens(\n        address[] memory path,\n        uint256 amountOut,\n        address to\n    ) internal {\n        if (msg.value == 0) revert EthRequiredForSwap();\n        // For this scenario, path must be length 2: [WCRO, tokenOut]\n        // The aggregator logic ensures only a single-hop path is chosen for ETH->Tokens\n        if (path.length != 2) revert RouteLengthMismatch();\n        if (path[0] != WCRO) revert InvalidFirstPathForSwapAnyETH();\n\n        (\n            address[] memory bestPath,\n            address[] memory dexes,\n            uint256 amountCalculated,\n            uint256 feeAmount\n        ) = viewBestSwap(\n                path[0],\n                path[path.length - 1],\n                amountOut,\n                SwapType.SwapETHForExactTokens\n            );\n\n        // Double-check the returned path matches our original path\n        if (\n            bestPath.length != 2 ||\n            bestPath[0] != path[0] ||\n            bestPath[1] != path[1]\n        ) {\n            revert RouteLengthMismatch();\n        }\n\n        // Ensure user provided enough ETH\n        if (msg.value < amountCalculated) revert InsufficientETHProvided();\n\n        // Pay the fee portion\n        (bool feeSent, ) = feeAddress.call{value: feeAmount}(\"\");\n        if (!feeSent) revert FailedToSendFee();\n\n        uint256 amountAfterFee = amountCalculated - feeAmount;\n\n        // Refund any excess ETH if the user sent more than required\n        if (msg.value > amountCalculated) {\n            uint256 refund = msg.value - amountCalculated;\n            (bool successRefund, ) = msg.sender.call{value: refund}(\"\");\n            if (!successRefund) revert FailedToRefund();\n        }\n\n        // Perform the single swap: ETH->Exact Tokens\n        // There's only one DEX and one hop: dexes[0]\n\n        // Call swapETHForExactTokens: we want exactly `amountOut` tokens\n        // `amountAfterFee` is how much ETH we supply as max input\n        bytes memory data = abi.encodeWithSelector(\n            IAggRouter.swapETHForExactTokens.selector,\n            amountOut,\n            _buildPath(path[0], path[1]),\n            to,\n            block.timestamp\n        );\n\n        (bool success, bytes memory returnData) = dexes[0].call{\n            value: amountAfterFee\n        }(data);\n        if (!success) revert SwapFailed();\n\n        uint256[] memory amounts = abi.decode(returnData, (uint256[]));\n\n        // Verify we got exactly amountOut tokens\n        if (amounts[amounts.length - 1] != amountOut)\n            revert InsufficientOutput();\n\n        emit SwapExecuted(\n            msg.sender,\n            amountCalculated, // total ETH spent including fee\n            amountOut, // exact tokens out\n            feeAmount,\n            dexes,\n            bestPath,\n            block.timestamp\n        );\n    }\n\n    // Helper function to get output amount from a router (getAmountsOut)\n    function safeGetAmountsOut(\n        IAggRouter router,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256) {\n        // Check if all pairs exist first\n        if (!allPairsExist(router, path)) {\n            return 0; // If a pair doesn't exist, no route\n        }\n\n        (bool success, bytes memory data) = address(router).staticcall(\n            abi.encodeWithSelector(\n                router.getAmountsOut.selector,\n                amountIn,\n                path\n            )\n        );\n\n        if (!success) {\n            // If call fails, return 0 to indicate no valid route\n            return 0;\n        }\n\n        uint256[] memory amounts = abi.decode(data, (uint256[]));\n        return amounts[amounts.length - 1];\n    }\n\n    function safeGetAmountsIn(\n        IAggRouter router,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256) {\n        // Check if all pairs exist first\n        if (!allPairsExist(router, path)) {\n            return type(uint256).max; // No valid route\n        }\n\n        (bool success, bytes memory data) = address(router).staticcall(\n            abi.encodeWithSelector(\n                router.getAmountsIn.selector,\n                amountOut,\n                path\n            )\n        );\n\n        if (!success) {\n            // If call fails, return max uint to indicate no valid route\n            return type(uint256).max;\n        }\n\n        uint256[] memory amounts = abi.decode(data, (uint256[]));\n        return amounts[0];\n    }\n\n    function allPairsExist(\n        IAggRouter router,\n        address[] memory path\n    ) internal view returns (bool) {\n        address factory = router.factory();\n\n        for (uint256 i = 0; i < path.length - 1; i++) {\n            address pair = IAggFactory(factory).getPair(path[i], path[i + 1]);\n            if (pair == address(0)) {\n                // If any pair in the path doesn't exist, we cannot proceed\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function safeGetReserves(\n        address pair\n    ) internal view returns (uint256 reserve0, uint256 reserve1) {\n        if (pair == address(0)) {\n            // If pair doesn't exist, return zero liquidity\n            return (0, 0);\n        }\n\n        // Perform a staticcall to safely get reserves\n        (bool success, bytes memory data) = pair.staticcall(\n            abi.encodeWithSelector(IAggPair.getReserves.selector)\n        );\n\n        if (success && data.length >= 96) {\n            // Decode the returned data. Reserves are (uint112, uint112, uint32), but\n            // decoding into uint256 is safe since it's larger. The last value (blockTimestampLast)\n            // isn't needed here, so we can ignore it.\n            (reserve0, reserve1, ) = abi.decode(\n                data,\n                (uint256, uint256, uint32)\n            );\n        } else {\n            // If the call fails or data is incomplete, treat as zero liquidity\n            reserve0 = 0;\n            reserve1 = 0;\n        }\n    }\n\n    function viewPathLiquidity(\n        address[] memory path\n    ) external view returns (uint256[][][] memory) {\n        if (path.length <= 1) revert InvalidPath();\n\n        // Initialize the liquidity array: liquidity[routerIndex][pairIndex][reserveIndex]\n        uint256[][][] memory liquidity = new uint256[][][](routers.length);\n\n        for (uint256 i = 0; i < routers.length; i++) {\n            liquidity[i] = viewPathLiquidityForSingleDex(path, routers[i]);\n        }\n\n        return liquidity;\n    }\n\n    function viewPathLiquidityForSingleDex(\n        address[] memory path,\n        address router\n    ) public view returns (uint256[][] memory) {\n        if (path.length <= 1) revert InvalidPath();\n\n        // Initialize the liquidity array: liquidity[pairIndex][reserveIndex]\n        uint256[][] memory liquidity = new uint256[][](path.length - 1);\n\n        // Get the factory for the current router\n        address factory = IAggRouter(router).factory();\n\n        for (uint256 j = 0; j < path.length - 1; j++) {\n            liquidity[j] = new uint256[](2);\n\n            address pair = IAggFactory(factory).getPair(path[j], path[j + 1]);\n            (uint256 reserve0, uint256 reserve1) = safeGetReserves(pair);\n\n            liquidity[j][0] = reserve0;\n            liquidity[j][1] = reserve1;\n        }\n\n        return liquidity;\n    }\n\n    // This function executes whenever ETH is sent without data\n    receive() external payable {\n        revert(\"Direct ETH transfers not allowed\");\n    }\n\n    // This function executes whenever a call with data doesn't match any function signature\n    fallback() external payable {\n        revert(\"Fallback not allowed\");\n    }\n}\n"
    },
    "contracts/Puushdot/DeFi/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n}\n"
    },
    "contracts/Puushdot/DeFi/interfaces/IPuushV2Callee.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IPuushV2Callee {\n    function uniswapV2Call(\n        address sender,\n        uint amount0,\n        uint amount1,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/Puushdot/DeFi/interfaces/IPuushV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IPuushV2ERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint);\n\n    function permit(\n        address owner,\n        address spender,\n        uint value,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/Puushdot/DeFi/interfaces/IPuushV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IPuushV2Factory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint\n    );\n    event SwapFeeUpdated(uint newSwapFee);\n\n    function feeTo() external view returns (address);\n\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n\n    function allPairs(uint) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint);\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setSwapFee(address pair, uint newSwapFee) external;\n}\n"
    },
    "contracts/Puushdot/DeFi/interfaces/IPuushV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./IPuushV2ERC20.sol\";\n\ninterface IPuushV2Pair is IPuushV2ERC20 {\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(\n        address indexed sender,\n        uint amount0,\n        uint amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to,\n        uint feeAmount0,\n        uint feeAmount1\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function price0CumulativeLast() external view returns (uint);\n\n    function price1CumulativeLast() external view returns (uint);\n\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n\n    function burn(address to) external returns (uint amount0, uint amount1);\n\n    function swap(\n        uint amount0Out,\n        uint amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n\n    function swapFee() external view returns (uint);\n\n    function updateSwapFee(uint newSwapFee) external;\n}\n"
    },
    "contracts/Puushdot/DeFi/interfaces/IPuushV2Router01.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IPuushV2Router01 {\n    function factory() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    )\n        external\n        payable\n        returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint amountOut,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function quote(\n        uint amountA,\n        uint reserveA,\n        uint reserveB\n    ) external pure returns (uint amountB);\n\n    function getAmountOut(\n        uint amountIn,\n        uint reserveIn,\n        uint reserveOut\n    ) external pure returns (uint amountOut);\n\n    function getAmountIn(\n        uint amountOut,\n        uint reserveIn,\n        uint reserveOut\n    ) external pure returns (uint amountIn);\n\n    function getAmountsOut(\n        uint amountIn,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function getAmountsIn(\n        uint amountOut,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/Puushdot/DeFi/interfaces/IPuushV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./IPuushV2Router01.sol\";\n\ninterface IPuushV2Router02 is IPuushV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "contracts/Puushdot/DeFi/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/Puushdot/DeFi/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// a library for performing various math operations\n\nlibrary Math {\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/Puushdot/DeFi/libraries/PuushV2Library.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../interfaces/IPuushV2Pair.sol\";\nimport \"./SafeMath.sol\";\n\nlibrary PuushV2Library {\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"PuushV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"PuushV2Library: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            factory,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            hex\"f18b16c1f6819597552c0307c910b5531a722e4b1ffaf4beece84820abea0a03\" // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint reserveA, uint reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1, ) = IPuushV2Pair(\n            pairFor(factory, tokenA, tokenB)\n        ).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint amountA,\n        uint reserveA,\n        uint reserveB\n    ) internal pure returns (uint amountB) {\n        require(amountA > 0, \"PuushV2Library: INSUFFICIENT_AMOUNT\");\n        require(\n            reserveA > 0 && reserveB > 0,\n            \"PuushV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint amountIn,\n        uint reserveIn,\n        uint reserveOut\n    ) internal pure returns (uint amountOut) {\n        require(amountIn > 0, \"PuushV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"PuushV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint amountOut,\n        uint reserveIn,\n        uint reserveOut\n    ) internal pure returns (uint amountIn) {\n        require(amountOut > 0, \"PuushV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"PuushV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint amountIn,\n        address[] memory path\n    ) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, \"PuushV2Library: INVALID_PATH\");\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(\n                factory,\n                path[i],\n                path[i + 1]\n            );\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint amountOut,\n        address[] memory path\n    ) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, \"PuushV2Library: INVALID_PATH\");\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(\n                factory,\n                path[i - 1],\n                path[i]\n            );\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "contracts/Puushdot/DeFi/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n}\n"
    },
    "contracts/Puushdot/DeFi/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper::safeApprove: approve failed\"\n        );\n    }\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper::safeTransfer: transfer failed\"\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper::transferFrom: transferFrom failed\"\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(\n            success,\n            \"TransferHelper::safeTransferETH: ETH transfer failed\"\n        );\n    }\n}\n"
    },
    "contracts/Puushdot/DeFi/libraries/UQ112x112.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2 ** 112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    },
    "contracts/Puushdot/DeFi/PuushV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./interfaces/IPuushV2ERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\n\ncontract PuushV2ERC20 is IPuushV2ERC20 {\n    using SafeMath for uint;\n\n    string public constant name = \"Puush V2\";\n    string public constant symbol = \"PUUSH-V2\";\n    uint8 public constant decimals = 18;\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    constructor() {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\n                value\n            );\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint value,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"PuushV2: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"PuushV2: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/Puushdot/DeFi/PuushV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./interfaces/IPuushV2Factory.sol\";\nimport \"./PuushV2Pair.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PuushV2Factory is IPuushV2Factory, Ownable {\n    address public feeTo;\n    mapping(address => bool) public isAdmin;\n\n    mapping(address => mapping(address => address)) public getPair;\n    address[] public allPairs;\n\n    modifier onlyAdmin() {\n        require(isAdmin[msg.sender], \"Only admin can call this function\");\n        _;\n    }\n\n    constructor(address _feeTo, address _owner) Ownable(_owner) {\n        feeTo = _feeTo;\n    }\n\n    function allPairsLength() external view returns (uint) {\n        return allPairs.length;\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair) {\n        require(tokenA != tokenB, \"PuushV2: IDENTICAL_ADDRESSES\");\n        (address token0, address token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"PuushV2: ZERO_ADDRESS\");\n        require(getPair[token0][token1] == address(0), \"PuushV2: PAIR_EXISTS\"); // single check is sufficient\n        bytes memory bytecode = type(PuushV2Pair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        IPuushV2Pair(pair).initialize(token0, token1);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n\n    function setFeeTo(address _feeTo) external onlyOwner {\n        feeTo = _feeTo;\n    }\n\n    // @dev Set the swap fee for a pair\n    // @param pair The pair to set the swap fee for\n    // @param newSwapFee The new swap fee, 1000 = 10%, 0 = 0%, 30 = 0.3%, 100 = 1%\n    function setSwapFee(address pair, uint newSwapFee) external onlyAdmin {\n        require(newSwapFee <= 1000, \"PuushV2: FEE_TOO_HIGH\"); // Max fee: 10%\n        PuushV2Pair(pair).updateSwapFee(newSwapFee);\n    }\n\n    function setAdmin(address _admin, bool _isAdmin) external onlyOwner {\n        isAdmin[_admin] = _isAdmin;\n    }\n}\n"
    },
    "contracts/Puushdot/DeFi/PuushV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./interfaces/IPuushV2Pair.sol\";\nimport \"./PuushV2ERC20.sol\";\nimport \"./libraries/Math.sol\";\nimport \"./libraries/UQ112x112.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IPuushV2Factory.sol\";\nimport \"./interfaces/IPuushV2Callee.sol\";\n\ncontract PuushV2Pair is IPuushV2Pair, PuushV2ERC20 {\n    using SafeMath for uint;\n    using UQ112x112 for uint224;\n\n    uint public constant MINIMUM_LIQUIDITY = 10 ** 3;\n    bytes4 private constant SELECTOR =\n        bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, \"PuushV2: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(SELECTOR, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"PuushV2: TRANSFER_FAILED\"\n        );\n    }\n\n    uint public swapFee; // Fee in basis points (e.g., 30 = 0.3%)\n\n    constructor() {\n        factory = msg.sender;\n        swapFee = 30; // Default fee: 0.3%\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, \"PuushV2: FORBIDDEN\"); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    // update swap fee\n    function updateSwapFee(uint newSwapFee) external {\n        require(msg.sender == factory, \"PuushV2: FORBIDDEN\");\n        swapFee = newSwapFee;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(\n        uint balance0,\n        uint balance1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private {\n        require(\n            balance0 <= type(uint112).max && balance1 <= type(uint112).max,\n            \"PuushV2: OVERFLOW\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast +=\n                uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *\n                timeElapsed;\n            price1CumulativeLast +=\n                uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *\n                timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _mintFee(\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private returns (bool feeOn) {\n        address feeTo = IPuushV2Factory(factory).feeTo();\n        feeOn = feeTo != address(0);\n        uint _kLast = kLast; // gas savings\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\n                uint rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));\n                    uint denominator = rootK.mul(5).add(rootKLast);\n                    uint liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint liquidity) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        uint balance0 = IERC20(token0).balanceOf(address(this));\n        uint balance1 = IERC20(token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(\n                amount0.mul(_totalSupply) / _reserve0,\n                amount1.mul(_totalSupply) / _reserve1\n            );\n        }\n        require(liquidity > 0, \"PuushV2: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(\n        address to\n    ) external lock returns (uint amount0, uint amount1) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf[address(this)];\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(\n            amount0 > 0 && amount1 > 0,\n            \"PuushV2: INSUFFICIENT_LIQUIDITY_BURNED\"\n        );\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(\n        uint amount0Out,\n        uint amount1Out,\n        address to,\n        bytes calldata data\n    ) external lock {\n        require(\n            amount0Out > 0 || amount1Out > 0,\n            \"PuushV2: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        require(\n            amount0Out < _reserve0 && amount1Out < _reserve1,\n            \"PuushV2: INSUFFICIENT_LIQUIDITY\"\n        );\n\n        uint balance0;\n        uint balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 && to != _token1, \"PuushV2: INVALID_TO\");\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n            if (data.length > 0)\n                IPuushV2Callee(to).uniswapV2Call(\n                    msg.sender,\n                    amount0Out,\n                    amount1Out,\n                    data\n                );\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out\n            ? balance0 - (_reserve0 - amount0Out)\n            : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out\n            ? balance1 - (_reserve1 - amount1Out)\n            : 0;\n        require(\n            amount0In > 0 || amount1In > 0,\n            \"PuushV2: INSUFFICIENT_INPUT_AMOUNT\"\n        );\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint balance0Adjusted = balance0.mul(10000).sub(\n                amount0In.mul(swapFee)\n            );\n            uint balance1Adjusted = balance1.mul(10000).sub(\n                amount1In.mul(swapFee)\n            );\n            require(\n                balance0Adjusted.mul(balance1Adjusted) >=\n                    uint(_reserve0).mul(_reserve1).mul(10000 ** 2),\n                \"PuushV2: K\"\n            );\n        }\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(\n            msg.sender,\n            amount0In,\n            amount1In,\n            amount0Out,\n            amount1Out,\n            to,\n            amount0In.mul(swapFee) / 10000,\n            amount1In.mul(swapFee) / 10000\n        );\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(\n            _token0,\n            to,\n            IERC20(_token0).balanceOf(address(this)).sub(reserve0)\n        );\n        _safeTransfer(\n            _token1,\n            to,\n            IERC20(_token1).balanceOf(address(this)).sub(reserve1)\n        );\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this)),\n            reserve0,\n            reserve1\n        );\n    }\n}\n"
    },
    "contracts/Puushdot/DeFi/PuushV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./interfaces/IPuushV2Factory.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/IPuushV2Router02.sol\";\nimport \"./libraries/PuushV2Library.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IWETH.sol\";\n\ncontract PuushV2Router02 is IPuushV2Router02 {\n    using SafeMath for uint;\n\n    address public immutable override factory;\n    address public immutable override WETH;\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, \"PuushV2Router: EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _WETH) {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal virtual returns (uint amountA, uint amountB) {\n        // create the pair if it doesn't exist yet\n        if (IPuushV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n            IPuushV2Factory(factory).createPair(tokenA, tokenB);\n        }\n        (uint reserveA, uint reserveB) = PuushV2Library.getReserves(\n            factory,\n            tokenA,\n            tokenB\n        );\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = PuushV2Library.quote(\n                amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal <= amountBDesired) {\n                require(\n                    amountBOptimal >= amountBMin,\n                    \"PuushV2Router: INSUFFICIENT_B_AMOUNT\"\n                );\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = PuushV2Library.quote(\n                    amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                assert(amountAOptimal <= amountADesired);\n                require(\n                    amountAOptimal >= amountAMin,\n                    \"PuushV2Router: INSUFFICIENT_A_AMOUNT\"\n                );\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint amountA, uint amountB, uint liquidity)\n    {\n        (amountA, amountB) = _addLiquidity(\n            tokenA,\n            tokenB,\n            amountADesired,\n            amountBDesired,\n            amountAMin,\n            amountBMin\n        );\n        address pair = PuushV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IPuushV2Pair(pair).mint(to);\n    }\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    )\n        external\n        payable\n        virtual\n        override\n        ensure(deadline)\n        returns (uint amountToken, uint amountETH, uint liquidity)\n    {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = PuushV2Library.pairFor(factory, token, WETH);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit{value: amountETH}();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n        liquidity = IPuushV2Pair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH)\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    )\n        public\n        virtual\n        override\n        ensure(deadline)\n        returns (uint amountA, uint amountB)\n    {\n        address pair = PuushV2Library.pairFor(factory, tokenA, tokenB);\n        IPuushV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint amount0, uint amount1) = IPuushV2Pair(pair).burn(to);\n        (address token0, ) = PuushV2Library.sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0\n            ? (amount0, amount1)\n            : (amount1, amount0);\n        require(amountA >= amountAMin, \"PuushV2Router: INSUFFICIENT_A_AMOUNT\");\n        require(amountB >= amountBMin, \"PuushV2Router: INSUFFICIENT_B_AMOUNT\");\n    }\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    )\n        public\n        virtual\n        override\n        ensure(deadline)\n        returns (uint amountToken, uint amountETH)\n    {\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override returns (uint amountA, uint amountB) {\n        address pair = PuushV2Library.pairFor(factory, tokenA, tokenB);\n        uint value = approveMax ? type(uint).max : liquidity;\n        IPuushV2Pair(pair).permit(\n            msg.sender,\n            address(this),\n            value,\n            deadline,\n            v,\n            r,\n            s\n        );\n        (amountA, amountB) = removeLiquidity(\n            tokenA,\n            tokenB,\n            liquidity,\n            amountAMin,\n            amountBMin,\n            to,\n            deadline\n        );\n    }\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override returns (uint amountToken, uint amountETH) {\n        address pair = PuushV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? type(uint).max : liquidity;\n        IPuushV2Pair(pair).permit(\n            msg.sender,\n            address(this),\n            value,\n            deadline,\n            v,\n            r,\n            s\n        );\n        (amountToken, amountETH) = removeLiquidityETH(\n            token,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            to,\n            deadline\n        );\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\n        (, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(\n            token,\n            to,\n            IERC20(token).balanceOf(address(this))\n        );\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override returns (uint amountETH) {\n        address pair = PuushV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? type(uint).max : liquidity;\n        IPuushV2Pair(pair).permit(\n            msg.sender,\n            address(this),\n            value,\n            deadline,\n            v,\n            r,\n            s\n        );\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n            token,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            to,\n            deadline\n        );\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(\n        uint[] memory amounts,\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0, ) = PuushV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0\n                ? (uint(0), amountOut)\n                : (amountOut, uint(0));\n            address to = i < path.length - 2\n                ? PuushV2Library.pairFor(factory, output, path[i + 2])\n                : _to;\n            IPuushV2Pair(PuushV2Library.pairFor(factory, input, output)).swap(\n                amount0Out,\n                amount1Out,\n                to,\n                new bytes(0)\n            );\n        }\n    }\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        amounts = PuushV2Library.getAmountsOut(factory, amountIn, path);\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"PuushV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            PuushV2Library.pairFor(factory, path[0], path[1]),\n            amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        amounts = PuushV2Library.getAmountsIn(factory, amountOut, path);\n        require(\n            amounts[0] <= amountInMax,\n            \"PuushV2Router: EXCESSIVE_INPUT_AMOUNT\"\n        );\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            PuushV2Library.pairFor(factory, path[0], path[1]),\n            amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n\n    function swapExactETHForTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        payable\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, \"PuushV2Router: INVALID_PATH\");\n        amounts = PuushV2Library.getAmountsOut(factory, msg.value, path);\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"PuushV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(\n            IWETH(WETH).transfer(\n                PuushV2Library.pairFor(factory, path[0], path[1]),\n                amounts[0]\n            )\n        );\n        _swap(amounts, path, to);\n    }\n\n    function swapTokensForExactETH(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, \"PuushV2Router: INVALID_PATH\");\n        amounts = PuushV2Library.getAmountsIn(factory, amountOut, path);\n        require(\n            amounts[0] <= amountInMax,\n            \"PuushV2Router: EXCESSIVE_INPUT_AMOUNT\"\n        );\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            PuushV2Library.pairFor(factory, path[0], path[1]),\n            amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n\n    function swapExactTokensForETH(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, \"PuushV2Router: INVALID_PATH\");\n        amounts = PuushV2Library.getAmountsOut(factory, amountIn, path);\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"PuushV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            PuushV2Library.pairFor(factory, path[0], path[1]),\n            amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n\n    function swapETHForExactTokens(\n        uint amountOut,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        payable\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, \"PuushV2Router: INVALID_PATH\");\n        amounts = PuushV2Library.getAmountsIn(factory, amountOut, path);\n        require(\n            amounts[0] <= msg.value,\n            \"PuushV2Router: EXCESSIVE_INPUT_AMOUNT\"\n        );\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(\n            IWETH(WETH).transfer(\n                PuushV2Library.pairFor(factory, path[0], path[1]),\n                amounts[0]\n            )\n        );\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0])\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0, ) = PuushV2Library.sortTokens(input, output);\n            IPuushV2Pair pair = IPuushV2Pair(\n                PuushV2Library.pairFor(factory, input, output)\n            );\n            uint amountInput;\n            uint amountOutput;\n            {\n                // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1, ) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0\n                    ? (reserve0, reserve1)\n                    : (reserve1, reserve0);\n                amountInput = IERC20(input).balanceOf(address(pair)).sub(\n                    reserveInput\n                );\n                amountOutput = PuushV2Library.getAmountOut(\n                    amountInput,\n                    reserveInput,\n                    reserveOutput\n                );\n            }\n            (uint amount0Out, uint amount1Out) = input == token0\n                ? (uint(0), amountOutput)\n                : (amountOutput, uint(0));\n            address to = i < path.length - 2\n                ? PuushV2Library.pairFor(factory, output, path[i + 2])\n                : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            PuushV2Library.pairFor(factory, path[0], path[1]),\n            amountIn\n        );\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >=\n                amountOutMin,\n            \"PuushV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n    }\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable virtual override ensure(deadline) {\n        require(path[0] == WETH, \"PuushV2Router: INVALID_PATH\");\n        uint amountIn = msg.value;\n        IWETH(WETH).deposit{value: amountIn}();\n        assert(\n            IWETH(WETH).transfer(\n                PuushV2Library.pairFor(factory, path[0], path[1]),\n                amountIn\n            )\n        );\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >=\n                amountOutMin,\n            \"PuushV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n    }\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) {\n        require(path[path.length - 1] == WETH, \"PuushV2Router: INVALID_PATH\");\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            PuushV2Library.pairFor(factory, path[0], path[1]),\n            amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(path, address(this));\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\n        require(\n            amountOut >= amountOutMin,\n            \"PuushV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        IWETH(WETH).withdraw(amountOut);\n        TransferHelper.safeTransferETH(to, amountOut);\n    }\n\n    // **** LIBRARY FUNCTIONS ****\n    function quote(\n        uint amountA,\n        uint reserveA,\n        uint reserveB\n    ) public pure virtual override returns (uint amountB) {\n        return PuushV2Library.quote(amountA, reserveA, reserveB);\n    }\n\n    function getAmountOut(\n        uint amountIn,\n        uint reserveIn,\n        uint reserveOut\n    ) public pure virtual override returns (uint amountOut) {\n        return PuushV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n    }\n\n    function getAmountIn(\n        uint amountOut,\n        uint reserveIn,\n        uint reserveOut\n    ) public pure virtual override returns (uint amountIn) {\n        return PuushV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n    }\n\n    function getAmountsOut(\n        uint amountIn,\n        address[] memory path\n    ) public view virtual override returns (uint[] memory amounts) {\n        return PuushV2Library.getAmountsOut(factory, amountIn, path);\n    }\n\n    function getAmountsIn(\n        uint amountOut,\n        address[] memory path\n    ) public view virtual override returns (uint[] memory amounts) {\n        return PuushV2Library.getAmountsIn(factory, amountOut, path);\n    }\n}\n"
    },
    "contracts/Puushdot/extras/PuushdotJackpot.sol": {
      "content": "// PuushdotJackpot.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract PuushdotJackpot {\n    address public lastDepositor;\n    uint256 public lastDepositTime;\n    uint256 public jackpot;\n    uint256 public constant TIME_LIMIT = 10 minutes;\n    uint256 public constant DEPOSIT_AMOUNT = 100 ether;\n    uint256 public constant DEPOSIT_FEE = 10 ether;\n    address public feeWallet;\n\n    event Deposit(address user, uint256 amount, uint256 timestamp);\n    event JackpotWon(address winner, uint256 amount, uint256 timestamp);\n    event FeeTransferred(address feeWallet, uint256 amount, uint256 timestamp);\n\n    constructor(address _feeWallet) {\n        require(_feeWallet != address(0), \"Fee wallet address cannot be zero\");\n        feeWallet = _feeWallet;\n        lastDepositor = address(0);\n        lastDepositTime = block.timestamp;\n        jackpot = 0;\n    }\n\n    function deposit() public payable {\n        require(msg.value == DEPOSIT_AMOUNT, \"Must deposit exactly 100 ETH\");\n\n        // Deduct the fee and add the remaining to the jackpot\n        uint256 feeAmount = DEPOSIT_FEE;\n        uint256 depositAmount = msg.value - feeAmount;\n\n        // Transfer the fee to the fee wallet\n        payable(feeWallet).transfer(feeAmount);\n        emit FeeTransferred(feeWallet, feeAmount, block.timestamp);\n\n        // Check if the last deposit was more than 10 minutes ago\n        if (jackpot > 0 && block.timestamp > lastDepositTime + TIME_LIMIT) {\n            // Previous depositor wins the jackpot\n            payoutJackpot();\n        }\n\n        // Update the jackpot and the last depositor details\n        jackpot += depositAmount;\n        lastDepositor = msg.sender;\n        lastDepositTime = block.timestamp;\n\n        emit Deposit(msg.sender, depositAmount, block.timestamp);\n    }\n\n    function payoutJackpot() internal {\n        require(jackpot > 0, \"No jackpot to payout\");\n\n        uint256 payoutAmount = jackpot;\n        address winner = lastDepositor;\n\n        // Reset the jackpot\n        jackpot = 0;\n        lastDepositor = address(0);\n        lastDepositTime = block.timestamp;\n\n        // Transfer the jackpot to the winner\n        payable(winner).transfer(payoutAmount);\n\n        emit JackpotWon(winner, payoutAmount, block.timestamp);\n    }\n\n    function timeUntilNextPayout() public view returns (uint256) {\n        if (block.timestamp > lastDepositTime + TIME_LIMIT) {\n            return 0;\n        } else {\n            return (lastDepositTime + TIME_LIMIT) - block.timestamp;\n        }\n    }\n\n    receive() external payable {\n        deposit();\n    }\n}\n"
    },
    "contracts/Puushdot/extras/PuushdotLocker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title PuushdotLocker\n/// @notice Lock ERC20 tokens for a specified duration or intervals, with optional delegation of unlock privileges.\ncontract PuushdotLocker is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// Errors\n    error InvalidParameters();\n    error LockPeriodOngoing();\n    error AlreadyFullyUnlocked();\n    error TransferFailed();\n    error Unauthorized();\n\n    /// Events\n    event LockCreated(\n        uint256 indexed lockId,\n        address indexed tokenAddress,\n        address indexed creator,\n        address unlocker,\n        uint256 totalAmount,\n        uint256 unlockIntervals,\n        uint256 unlockIntervalDuration,\n        uint256 timestamp\n    );\n\n    event Unlocked(\n        uint256 indexed lockId,\n        address indexed tokenAddress,\n        address indexed unlocker,\n        uint256 amountUnlocked,\n        uint256 totalUnlockedSoFar,\n        uint256 timestamp\n    );\n\n    event UnlockerUpdated(\n        uint256 indexed lockId,\n        address indexed oldUnlocker,\n        address indexed newUnlocker,\n        uint256 timestamp\n    );\n\n    /// Lock data structure\n    struct Locks {\n        address creator; // Address that locked the tokens\n        address unlocker; // Address that can unlock the tokens\n        address tokenAddress; // ERC20 token address\n        uint256 totalAmount; // Total amount of tokens locked\n        uint256 unlockedAmount; // Amount of tokens unlocked so far\n        uint256 unlockIntervals; // Number of intervals for partial unlock\n        uint256 unlockIntervalDuration; // Duration in seconds for each interval\n        uint256 lockDate; // Timestamp when the lock was created\n        uint256 lockId; // Unique identifier for the lock\n    }\n\n    /// Global Lock ID counter\n    uint256 public lockIdCounter;\n\n    /// Main storage for lock data\n    mapping(uint256 => Locks) public lockers;\n\n    /// @notice Constructor that sets the owner. Reverts if `_owner` is address(0).\n    constructor(address _owner) Ownable(_owner) {}\n\n    /**\n     * @dev Create a new lock.\n     *      If _unlockIntervals == 1, it effectively becomes \"all at once\" after _unlockIntervalDuration seconds.\n     *      If _unlockIntervals > 1, partial unlock occurs at each interval.\n     * @param _tokenAddress Address of the ERC20 token to lock\n     * @param _unlocker Address that can unlock the tokens\n     * @param _totalAmount Total amount of tokens to lock\n     * @param _unlockIntervals Number of intervals to unlock\n     * @param _unlockIntervalDuration Duration (in seconds) of each interval\n     */\n    function createLock(\n        address _tokenAddress,\n        address _unlocker,\n        uint256 _totalAmount,\n        uint256 _unlockIntervals,\n        uint256 _unlockIntervalDuration\n    ) external nonReentrant {\n        // Basic validations\n        if (\n            _tokenAddress == address(0) ||\n            _unlocker == address(0) ||\n            _totalAmount == 0 ||\n            _unlockIntervals == 0 ||\n            _unlockIntervalDuration == 0\n        ) {\n            revert InvalidParameters();\n        }\n\n        // Transfer tokens from msg.sender to this contract\n        IERC20 token = IERC20(_tokenAddress);\n        uint256 balanceBefore = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _totalAmount);\n        uint256 balanceAfter = token.balanceOf(address(this));\n\n        // Ensure the contract actually received the tokens\n        if (balanceAfter - balanceBefore != _totalAmount) {\n            revert TransferFailed();\n        }\n\n        // Increment lock ID\n        lockIdCounter++;\n        uint256 newLockId = lockIdCounter;\n\n        // Create and store the lock\n        lockers[newLockId] = Locks({\n            creator: msg.sender,\n            unlocker: _unlocker,\n            tokenAddress: _tokenAddress,\n            totalAmount: _totalAmount,\n            unlockedAmount: 0,\n            unlockIntervals: _unlockIntervals,\n            unlockIntervalDuration: _unlockIntervalDuration,\n            lockDate: block.timestamp,\n            lockId: newLockId\n        });\n\n        // Emit event\n        emit LockCreated(\n            newLockId,\n            _tokenAddress,\n            msg.sender,\n            _unlocker,\n            _totalAmount,\n            _unlockIntervals,\n            _unlockIntervalDuration,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Unlocks the portion of tokens currently available for the given lock.\n     * @param _lockId The ID of the lock\n     */\n    function unlockAvailable(uint256 _lockId) external nonReentrant {\n        Locks storage locked = lockers[_lockId];\n\n        // Validate the caller is authorized to unlock\n        if (msg.sender != locked.unlocker) {\n            revert Unauthorized();\n        }\n\n        // If lock is already fully unlocked, revert\n        if (locked.unlockedAmount >= locked.totalAmount) {\n            revert AlreadyFullyUnlocked();\n        }\n\n        // Calculate how many intervals have passed\n        uint256 elapsed = block.timestamp - locked.lockDate;\n        uint256 intervalsPassed = elapsed / locked.unlockIntervalDuration;\n        if (intervalsPassed > locked.unlockIntervals) {\n            intervalsPassed = locked.unlockIntervals; // cap to total intervals\n        }\n\n        // Total unlocked so far, in proportion to intervals passed\n        uint256 totalUnlockedSoFar = (locked.totalAmount * intervalsPassed) /\n            locked.unlockIntervals;\n\n        // Amount newly available this call\n        uint256 amountToUnlock = totalUnlockedSoFar - locked.unlockedAmount;\n        if (amountToUnlock == 0) {\n            revert LockPeriodOngoing();\n            // or revert(\"Nothing to unlock yet\");\n        }\n\n        // Update storage\n        locked.unlockedAmount += amountToUnlock;\n\n        // Transfer tokens to unlocker\n        IERC20(locked.tokenAddress).safeTransfer(msg.sender, amountToUnlock);\n\n        // Emit event\n        emit Unlocked(\n            _lockId,\n            locked.tokenAddress,\n            msg.sender,\n            amountToUnlock,\n            locked.unlockedAmount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Allows the current unlocker to change the unlocker address.\n     * @param _lockId The ID of the lock\n     * @param _newUnlocker The new unlocker address\n     */\n    function updateUnlocker(uint256 _lockId, address _newUnlocker) external {\n        Locks storage locked = lockers[_lockId];\n\n        if (_newUnlocker == address(0)) {\n            revert InvalidParameters();\n        }\n\n        // Only the current unlocker can do this\n        if (msg.sender != locked.unlocker) {\n            revert Unauthorized();\n        }\n\n        address oldUnlocker = locked.unlocker;\n        locked.unlocker = _newUnlocker;\n\n        emit UnlockerUpdated(\n            _lockId,\n            oldUnlocker,\n            _newUnlocker,\n            block.timestamp\n        );\n    }\n\n    //--------------------------------------------------------------------------\n    // VIEW FUNCTIONS\n    //--------------------------------------------------------------------------\n\n    /**\n     * @dev Returns how many tokens are currently available to unlock for a given lock.\n     */\n    function availableToUnlock(\n        uint256 _lockId\n    ) external view returns (uint256) {\n        Locks memory locked = lockers[_lockId];\n\n        if (locked.unlockedAmount >= locked.totalAmount) {\n            return 0;\n        }\n\n        uint256 elapsed = block.timestamp - locked.lockDate;\n        uint256 intervalsPassed = elapsed / locked.unlockIntervalDuration;\n        if (intervalsPassed > locked.unlockIntervals) {\n            intervalsPassed = locked.unlockIntervals;\n        }\n\n        uint256 totalUnlockedSoFar = (locked.totalAmount * intervalsPassed) /\n            locked.unlockIntervals;\n\n        return totalUnlockedSoFar - locked.unlockedAmount;\n    }\n\n    //--------------------------------------------------------------------------\n    // EMERGENCY FUNCTIONS\n    //--------------------------------------------------------------------------\n\n    /**\n     * @dev Allows the owner to withdraw any ERC20 tokens from the contract.\n     * @param _tokenAddress Address of the ERC20 token to withdraw\n     * @param _amount Amount of tokens to withdraw\n     */\n    function emergencyWithdraw(\n        address _tokenAddress,\n        uint256 _amount\n    ) external onlyOwner {\n        IERC20(_tokenAddress).safeTransfer(owner(), _amount);\n    }\n}\n"
    },
    "contracts/Puushdot/extras/PuushdotRetro404.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PuushdotRetro404 is ReentrancyGuard, Ownable {\n    constructor() Ownable(msg.sender) {}\n\n    event TokensDeposited(uint256 poolId, address user, uint256 amount);\n    event TokensWithdrawn(uint256 poolId, address user, uint256 amount);\n    event SwapNFTsForTokens(\n        address user,\n        uint256 poolId,\n        uint256[] tokenIds,\n        uint256 tokenAmount\n    );\n    event SwapTokensForNFTs(\n        address user,\n        uint256 poolId,\n        uint256[] tokenIds,\n        uint256 tokenAmount\n    );\n    event SwapNFTForNFT(\n        address user,\n        uint256 poolId,\n        uint256 tokenIdIn,\n        uint256 tokenIdOut\n    );\n\n    address public puushFeeReceiver;\n    uint256 public puushFeeAmount = 100; // 100 = 1%, 10000 = 100%\n    uint256 public poolCount = 0;\n    mapping(uint256 => RetroPool) public pools; // poolId => RetroPool\n    mapping(uint256 => mapping(uint256 => uint256)) public poolNftIds; // poolId => index => nftId\n\n    struct RetroPool {\n        uint256 poolId;\n        address nftContract;\n        address tokenContract;\n        address projectFeeReceiver;\n        uint256 projectFeeAmount; // 100 = 1%, 10000 = 100%\n        uint256 maxNftSupply;\n        uint256 minNftSupply;\n        uint256 currentNftSupply;\n        uint256 maxTokenSupply;\n        uint256 currentTokenSupply;\n        bool active;\n        bool publicDepositsLocked;\n    }\n\n    /******************************************************\n     *                                                    *\n     *                 Owner Setters                      *\n     *                                                    *\n     ******************************************************/\n\n    function setPuushFeeReceiver(address _puushFeeReceiver) external onlyOwner {\n        puushFeeReceiver = _puushFeeReceiver;\n    }\n\n    function setPuushFeeAmount(uint256 _puushFeeAmount) external onlyOwner {\n        puushFeeAmount = _puushFeeAmount;\n    }\n\n    function setProjectFeeReceiver(\n        uint256 poolId,\n        address _projectFeeReceiver\n    ) external onlyOwner {\n        RetroPool storage pool = pools[poolId];\n        pool.projectFeeReceiver = _projectFeeReceiver;\n    }\n\n    function setProjectFeeAmount(\n        uint256 poolId,\n        uint256 _projectFeeAmount\n    ) external onlyOwner {\n        RetroPool storage pool = pools[poolId];\n        pool.projectFeeAmount = _projectFeeAmount;\n    }\n\n    function setPoolActive(uint256 poolId, bool active) external onlyOwner {\n        RetroPool storage pool = pools[poolId];\n        pool.active = active;\n    }\n\n    function setPoolMaxTokenSupply(\n        uint256 poolId,\n        uint256 maxTokenSupply\n    ) external onlyOwner {\n        RetroPool storage pool = pools[poolId];\n        pool.maxTokenSupply = maxTokenSupply;\n    }\n\n    function setPoolMaxNftSupply(\n        uint256 poolId,\n        uint256 maxNftSupply\n    ) external onlyOwner {\n        RetroPool storage pool = pools[poolId];\n        pool.maxNftSupply = maxNftSupply;\n    }\n\n    function setPoolMinNftSupply(\n        uint256 poolId,\n        uint256 minNftSupply\n    ) external onlyOwner {\n        RetroPool storage pool = pools[poolId];\n        pool.minNftSupply = minNftSupply;\n    }\n\n    function setPoolCurrentNftSupply(\n        uint256 poolId,\n        uint256 currentNftSupply\n    ) external onlyOwner {\n        RetroPool storage pool = pools[poolId];\n        pool.currentNftSupply = currentNftSupply;\n    }\n\n    function setPoolCurrentTokenSupply(\n        uint256 poolId,\n        uint256 currentTokenSupply\n    ) external onlyOwner {\n        RetroPool storage pool = pools[poolId];\n        pool.currentTokenSupply = currentTokenSupply;\n    }\n\n    function setPoolDepositsLocked(\n        uint256 poolId,\n        bool publicDepositsLocked\n    ) external onlyOwner {\n        RetroPool storage pool = pools[poolId];\n        pool.publicDepositsLocked = publicDepositsLocked;\n    }\n\n    function setPool(\n        address nftContract,\n        address tokenContract,\n        address projectFeeReceiver,\n        uint256 maxNftSupply,\n        uint256 maxTokenSupply,\n        uint256 minNftSupply\n    ) external onlyOwner {\n        require(nftContract != address(0), \"Invalid address\");\n        require(tokenContract != address(0), \"Invalid address\");\n        require(projectFeeReceiver != address(0), \"Invalid address\");\n        require(maxNftSupply > 0 && maxTokenSupply > 0, \"Invalid supply\");\n        require(minNftSupply <= maxNftSupply, \"Invalid supply\");\n\n        // Increase pool count\n        poolCount++;\n\n        pools[poolCount] = RetroPool({\n            poolId: poolCount,\n            nftContract: nftContract,\n            tokenContract: tokenContract,\n            projectFeeReceiver: projectFeeReceiver,\n            projectFeeAmount: 100,\n            maxNftSupply: maxNftSupply,\n            minNftSupply: minNftSupply,\n            currentNftSupply: 0,\n            maxTokenSupply: maxTokenSupply,\n            currentTokenSupply: 0,\n            active: false,\n            publicDepositsLocked: false\n        });\n    }\n\n    /******************************************************\n     *                                                    *\n     *                 Owner Functions                    *\n     *                                                    *\n     ******************************************************/\n\n    function depositNFTs(\n        uint256 poolId,\n        uint256[] memory tokenIds\n    ) external onlyOwner {\n        RetroPool storage pool = pools[poolId];\n        require(pool.poolId != 0, \"Pool does not exist\");\n        require(tokenIds.length > 0, \"No NFTs to deposit\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            IERC721(pool.nftContract).transferFrom(\n                msg.sender,\n                address(this),\n                tokenIds[i]\n            );\n\n            _addNFTToPool(poolId, tokenIds[i]);\n        }\n\n        emit TokensDeposited(poolId, msg.sender, tokenIds.length);\n    }\n\n    function withdrawTokensWithPriceImpact(\n        uint256 poolId,\n        uint256 amount\n    ) external onlyOwner {\n        RetroPool storage pool = pools[poolId];\n        require(\n            pool.currentTokenSupply >= amount,\n            \"Insufficient tokens in pool\"\n        );\n        require(pool.currentNftSupply > 0, \"No NFTs in pool\");\n\n        // Find out by how much maxTokenSupply should decrease\n        uint256 newPrice = (pool.currentTokenSupply - amount) /\n            (pool.maxNftSupply - pool.currentNftSupply);\n        uint256 newMaxTokenSupply = newPrice * pool.maxNftSupply;\n\n        // Update current token supply and max token supply\n        pool.currentTokenSupply -= amount;\n        pool.maxTokenSupply = newMaxTokenSupply;\n\n        // Transfer tokens to user\n        IERC20(pool.tokenContract).transfer(msg.sender, amount);\n\n        emit TokensWithdrawn(poolId, msg.sender, amount);\n    }\n\n    function withdrawTokensWithoutPriceImpact(\n        uint256 poolId,\n        uint256 amount\n    ) external onlyOwner {\n        RetroPool storage pool = pools[poolId];\n        require(\n            pool.currentTokenSupply >= amount,\n            \"Insufficient tokens in pool\"\n        );\n\n        // Update current token supply and max token supply\n        pool.currentTokenSupply -= amount;\n\n        // Transfer tokens to user\n        IERC20(pool.tokenContract).transfer(msg.sender, amount);\n\n        emit TokensWithdrawn(poolId, msg.sender, amount);\n    }\n\n    function emergencyWithdrawTokens(\n        address tokenContract,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(tokenContract).transfer(msg.sender, amount);\n    }\n\n    function emergencyWithdrawNFTs(\n        address nftContract,\n        uint256[] memory tokenIds\n    ) external onlyOwner {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            IERC721(nftContract).transferFrom(\n                address(this),\n                msg.sender,\n                tokenIds[i]\n            );\n        }\n    }\n\n    /******************************************************\n     *                                                    *\n     *                 Public Deposit Functions           *\n     *                                                    *\n     ******************************************************/\n\n    // Allow users to deposit tokens to the contract/pool, increasing NFT price\n    function depositTokensWithPriceImpact(\n        uint256 poolId,\n        uint256 amount\n    ) external {\n        RetroPool storage pool = pools[poolId];\n        require(pool.active, \"Pool is not active\");\n        require(!pool.publicDepositsLocked, \"Public deposits are locked\");\n\n        // Transfer tokens to contract\n        IERC20(pool.tokenContract).transferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Find out by how much maxTokenSupply should increase\n        uint256 newPrice = (pool.currentTokenSupply + amount) /\n            (pool.maxNftSupply - pool.currentNftSupply);\n        uint256 newMaxTokenSupply = newPrice * pool.maxNftSupply;\n\n        // Update current token supply\n        pool.currentTokenSupply += amount;\n        pool.maxTokenSupply = newMaxTokenSupply;\n\n        emit TokensDeposited(poolId, msg.sender, amount);\n    }\n\n    function depositTokensWithoutPriceImpact(\n        uint256 poolId,\n        uint256 amount\n    ) external {\n        RetroPool storage pool = pools[poolId];\n        require(pool.poolId != 0, \"Pool does not exist\");\n\n        // Transfer tokens to contract\n        IERC20(pool.tokenContract).transferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Update current token supply\n        pool.currentTokenSupply += amount;\n\n        emit TokensDeposited(poolId, msg.sender, amount);\n    }\n\n    /******************************************************\n     *                                                    *\n     *                 Public Swap Functions              *\n     *                                                    *\n     ******************************************************/\n\n    // Allow swap from NFT to tokens\n    function swapNFTsForTokens(\n        uint256 poolId,\n        uint256[] memory tokenIds\n    ) external nonReentrant {\n        RetroPool storage pool = pools[poolId];\n        require(pool.active, \"Pool is not active\");\n        require(\n            (tokenIds.length + pool.currentNftSupply) <= (pool.maxNftSupply),\n            \"Exceeds NFT supply\"\n        );\n        require(\n            pool.currentTokenSupply >= tokenIds.length * viewNftPrice(poolId),\n            \"Insufficient tokens in pool\"\n        );\n        require(tokenIds.length > 0, \"No NFTs to swap\");\n\n        // Make sure all tokenIds belong to msg.sender, and transfer to contract\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            IERC721(pool.nftContract).transferFrom(\n                msg.sender,\n                address(this),\n                tokenIds[i]\n            );\n            _addNFTToPool(poolId, tokenIds[i]);\n        }\n\n        // Calculate token amounts\n        uint256 tokenAmount = tokenIds.length * viewNftPrice(poolId);\n        uint256 feeProject = (tokenAmount * pool.projectFeeAmount) / 10000;\n        uint256 feePuush = (tokenAmount * puushFeeAmount) / 10000;\n        uint256 tokensToUser = tokenAmount - feeProject - feePuush;\n\n        // Update supply\n        pool.currentTokenSupply -= tokenAmount;\n\n        // Transfers\n        IERC20(pool.tokenContract).transfer(msg.sender, tokensToUser);\n        IERC20(pool.tokenContract).transfer(\n            pool.projectFeeReceiver,\n            feeProject\n        );\n        IERC20(pool.tokenContract).transfer(puushFeeReceiver, feePuush);\n\n        emit SwapNFTsForTokens(msg.sender, poolId, tokenIds, tokenAmount);\n    }\n\n    function swapTokensForRandomNFTs(\n        uint256 poolId,\n        uint256 nftAmount\n    ) external nonReentrant {\n        RetroPool storage pool = pools[poolId];\n        require(pool.active, \"Pool is not active\");\n        require(pool.currentNftSupply >= nftAmount, \"Exceeds max NFT supply\");\n        require(\n            (pool.currentNftSupply - nftAmount) >= pool.minNftSupply,\n            \"Exceeds min NFT supply\"\n        );\n        require(nftAmount > 0, \"Invalid NFT amount\");\n\n        uint256 nftCost = nftAmount * viewNftPrice(poolId);\n        uint256 feeProject = (nftCost * pool.projectFeeAmount) / 10000;\n        uint256 feePuush = (nftCost * puushFeeAmount) / 10000;\n        uint256 totalCost = nftCost + feeProject + feePuush;\n\n        require(\n            IERC20(pool.tokenContract).balanceOf(msg.sender) >= totalCost,\n            \"Insufficient tokens\"\n        );\n\n        // Update supply\n        pool.currentTokenSupply += nftCost;\n\n        // Transfer tokens to contract\n        IERC20(pool.tokenContract).transferFrom(\n            msg.sender,\n            address(this),\n            nftCost\n        );\n        IERC20(pool.tokenContract).transferFrom(\n            msg.sender,\n            pool.projectFeeReceiver,\n            feeProject\n        );\n        IERC20(pool.tokenContract).transferFrom(\n            msg.sender,\n            puushFeeReceiver,\n            feePuush\n        );\n\n        // Select random NFTs and transfer to user\n        uint256[] memory selectedNFTs = new uint256[](nftAmount);\n        for (uint256 i = 0; i < nftAmount; i++) {\n            uint256 randomIndex = _randomIndex(pool.currentNftSupply); // Get a random index\n            uint256 nftId = poolNftIds[poolId][randomIndex]; // Get the NFT from the pool\n\n            // Transfer the selected NFT to the user\n            IERC721(pool.nftContract).transferFrom(\n                address(this),\n                msg.sender,\n                nftId\n            );\n\n            // Update selected NFTs array\n            selectedNFTs[i] = nftId;\n\n            // Remove the NFT from the pool\n            _removeNFTFromPool(poolId, randomIndex);\n        }\n\n        emit SwapTokensForNFTs(msg.sender, poolId, selectedNFTs, totalCost);\n    }\n\n    // Trade NFT for NFT, make user pay swap fee once, same fee as price of NFT\n    function swapNFTForRandomNFT(\n        uint256 poolId,\n        uint256 nftId\n    ) external nonReentrant {\n        RetroPool storage pool = pools[poolId];\n        require(pool.active, \"Pool is not active\");\n        require(pool.currentNftSupply >= 1, \"Not enough NFTs in pool\");\n\n        uint256 nftCost = viewNftPrice(poolId);\n        uint256 feeProject = (nftCost * pool.projectFeeAmount) / 10000;\n        uint256 feePuush = (nftCost * puushFeeAmount) / 10000;\n        uint256 totalCost = feeProject + feePuush;\n\n        require(\n            IERC20(pool.tokenContract).balanceOf(msg.sender) >= totalCost,\n            \"Insufficient tokens\"\n        );\n\n        // Transfer tokens\n        IERC20(pool.tokenContract).transferFrom(\n            msg.sender,\n            pool.projectFeeReceiver,\n            feeProject\n        );\n        IERC20(pool.tokenContract).transferFrom(\n            msg.sender,\n            puushFeeReceiver,\n            feePuush\n        );\n\n        // Select random NFT and transfer to user\n        uint256 randomIndex = _randomIndex(pool.currentNftSupply); // Get a random index\n        uint256 nftIdOut = poolNftIds[poolId][randomIndex]; // Get the NFT from the pool\n\n        // Transfer the user's NFT to the pool\n        IERC721(pool.nftContract).transferFrom(\n            msg.sender,\n            address(this),\n            nftId\n        );\n\n        // Transfer the selected NFT to the user\n        IERC721(pool.nftContract).transferFrom(\n            address(this),\n            msg.sender,\n            nftIdOut\n        );\n\n        // Remove the NFT from the pool\n        _removeNFTFromPool(poolId, randomIndex);\n\n        // Add the user's NFT to the pool\n        _addNFTToPool(poolId, nftId);\n\n        emit SwapNFTForNFT(msg.sender, poolId, nftId, nftIdOut);\n    }\n\n    /******************************************************\n     *                                                    *\n     *                 Internal Functions                 *\n     *                                                    *\n     ******************************************************/\n\n    function _randomIndex(uint256 supply) internal view returns (uint256) {\n        require(supply > 0, \"Supply must be greater than 0\");\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        block.timestamp,\n                        block.difficulty,\n                        supply + 12345,\n                        msg.sender\n                    )\n                )\n            ) % supply;\n    }\n\n    function _addNFTToPool(uint256 poolId, uint256 nftId) internal {\n        RetroPool storage pool = pools[poolId];\n        poolNftIds[poolId][pool.currentNftSupply] = nftId;\n        pool.currentNftSupply++;\n    }\n\n    function _removeNFTFromPool(uint256 poolId, uint256 index) internal {\n        RetroPool storage pool = pools[poolId];\n        require(pool.currentNftSupply > 0, \"No NFTs left in the pool\");\n        require(index < pool.currentNftSupply, \"Invalid index\");\n        uint256 lastIndex = pool.currentNftSupply - 1; // Get the last index\n\n        if (index != lastIndex) {\n            // Replace the removed NFT with the last NFT in the pool\n            poolNftIds[poolId][index] = poolNftIds[poolId][lastIndex];\n        }\n\n        // Remove the last entry in the pool (we don't need to do anything for the last entry)\n        delete poolNftIds[poolId][lastIndex];\n        // Decrease the NFT supply\n        pool.currentNftSupply--;\n    }\n\n    /******************************************************\n     *                                                    *\n     *                 Public View Functions              *\n     *                                                    *\n     ******************************************************/\n\n    function viewNftPrice(uint256 poolId) public view returns (uint256) {\n        // Price is maxTokens vs maxNFTs\n        RetroPool storage pool = pools[poolId];\n        return pool.maxTokenSupply / pool.maxNftSupply;\n    }\n\n    function viewPoolInfo(\n        uint256 poolId\n    )\n        public\n        view\n        returns (\n            address nftContract,\n            address tokenContract,\n            address projectFeeReceiver,\n            uint256 projectFeeAmount,\n            uint256 _puushFeeAmount,\n            uint256 maxNftSupply,\n            uint256 minNftSupply,\n            uint256 currentNftSupply,\n            uint256 maxTokenSupply,\n            uint256 currentTokenSupply,\n            bool active,\n            bool publicDepositsLocked\n        )\n    {\n        RetroPool storage pool = pools[poolId];\n        return (\n            pool.nftContract,\n            pool.tokenContract,\n            pool.projectFeeReceiver,\n            pool.projectFeeAmount,\n            puushFeeAmount,\n            pool.maxNftSupply,\n            pool.minNftSupply,\n            pool.currentNftSupply,\n            pool.maxTokenSupply,\n            pool.currentTokenSupply,\n            pool.active,\n            pool.publicDepositsLocked\n        );\n    }\n\n    function viewUserNFTs(\n        uint256 poolId,\n        address user\n    ) public view returns (uint256[] memory) {\n        RetroPool storage pool = pools[poolId];\n        uint256 userBalance = IERC721Enumerable(pool.nftContract).balanceOf(\n            user\n        );\n        uint256[] memory tokenIds = new uint256[](userBalance);\n        for (uint256 i = 0; i < userBalance; i++) {\n            tokenIds[i] = IERC721Enumerable(pool.nftContract)\n                .tokenOfOwnerByIndex(user, i);\n        }\n        return tokenIds;\n    }\n\n    function viewPoolNfts(\n        uint256 poolId\n    ) public view returns (uint256[] memory) {\n        RetroPool storage pool = pools[poolId];\n        // Make array of size pool.currentNftSupply\n        uint256[] memory nftIds = new uint256[](pool.currentNftSupply);\n        for (uint256 i = 0; i < pool.currentNftSupply; i++) {\n            nftIds[i] = poolNftIds[poolId][i];\n        }\n        return nftIds;\n    }\n\n    function viewUserNFTsPaginated(\n        uint256 poolId,\n        address user,\n        uint256 page,\n        uint256 pageSize\n    ) public view returns (uint256[] memory) {\n        RetroPool storage pool = pools[poolId];\n        uint256 userBalance = IERC721Enumerable(pool.nftContract).balanceOf(\n            user\n        );\n\n        // Calculate start and end index based on page and page size\n        uint256 startIndex = page * pageSize;\n        uint256 endIndex = startIndex + pageSize;\n\n        // Ensure end index does not exceed user's balance\n        if (endIndex > userBalance) {\n            endIndex = userBalance;\n        }\n\n        // Handle case when startIndex exceeds total balance\n        if (startIndex >= userBalance) {\n            return new uint256[](0); // Return an empty array\n        }\n\n        // Calculate the actual size of the resulting array\n        uint256 resultSize = endIndex - startIndex;\n        uint256[] memory tokenIds = new uint256[](resultSize);\n\n        // Populate tokenIds array\n        for (uint256 i = 0; i < resultSize; i++) {\n            tokenIds[i] = IERC721Enumerable(pool.nftContract)\n                .tokenOfOwnerByIndex(user, startIndex + i);\n        }\n\n        return tokenIds;\n    }\n\n    function viewPoolNftsPaginated(\n        uint256 poolId,\n        uint256 page,\n        uint256 pageSize\n    ) public view returns (uint256[] memory) {\n        RetroPool storage pool = pools[poolId];\n\n        // Calculate start and end index based on page and page size\n        uint256 startIndex = page * pageSize;\n        uint256 endIndex = startIndex + pageSize;\n\n        // Ensure end index does not exceed currentNftSupply\n        if (endIndex > pool.currentNftSupply) {\n            endIndex = pool.currentNftSupply;\n        }\n\n        // Handle case when startIndex exceeds currentNftSupply\n        if (startIndex >= pool.currentNftSupply) {\n            return new uint256[](0); // Return an empty array\n        }\n\n        // Calculate the actual size of the resulting array\n        uint256 resultSize = endIndex - startIndex;\n        uint256[] memory nftIds = new uint256[](resultSize);\n\n        // Populate nftIds array\n        for (uint256 i = 0; i < resultSize; i++) {\n            nftIds[i] = poolNftIds[poolId][startIndex + i];\n        }\n\n        return nftIds;\n    }\n}\n"
    },
    "contracts/Puushdot/extras/PuushdotRewards.sol": {
      "content": "// PuushdotRewards.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract PuushdotRewards is Ownable {\n    event RewardsIncreased(address user, uint256 reward);\n    event RewardsSet(address user, uint256 reward);\n    event RewardClaimed(address user, uint256 reward);\n\n    constructor() Ownable(msg.sender) {}\n\n    mapping(address => uint256) public rewardsOf;\n    mapping(address => bool) public isAdmin;\n    address public rewardTokenAddress;\n\n    // Modifiers\n\n    modifier onlyAdmin() {\n        require(isAdmin[msg.sender], \"Only admin can call this function\");\n        _;\n    }\n\n    // Owner functions\n\n    function addAdmin(address admin) external onlyOwner {\n        require(!isAdmin[admin], \"Already an admin\");\n        isAdmin[admin] = true;\n    }\n\n    function removeAdmin(address admin) external onlyOwner {\n        require(isAdmin[admin], \"Not an admin\");\n        isAdmin[admin] = false;\n    }\n\n    function setRewardTokenAddress(\n        address _rewardTokenAddress\n    ) external onlyOwner {\n        rewardTokenAddress = _rewardTokenAddress;\n    }\n\n    function emergencyWithdrawERC20() external onlyOwner {\n        require(\n            rewardTokenAddress != address(0),\n            \"PuushdotRewards: Reward token address not set\"\n        );\n        uint256 _amount = IERC20(rewardTokenAddress).balanceOf(address(this));\n        require(_amount > 0, \"PuushdotRewards: No balance to withdraw\");\n        IERC20(rewardTokenAddress).transfer(msg.sender, _amount);\n    }\n\n    // Admin functions\n\n    function increaseRewards(\n        address[] memory _addresses,\n        uint256[] memory _rewards\n    ) public onlyAdmin {\n        require(\n            _addresses.length == _rewards.length,\n            \"PuushdotRewards: Invalid input length\"\n        );\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            rewardsOf[_addresses[i]] += _rewards[i];\n            emit RewardsIncreased(_addresses[i], _rewards[i]);\n        }\n    }\n\n    function setRewards(\n        address[] memory _addresses,\n        uint256[] memory _rewards\n    ) public onlyAdmin {\n        require(\n            _addresses.length == _rewards.length,\n            \"PuushdotRewards: Invalid input length\"\n        );\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            rewardsOf[_addresses[i]] = _rewards[i];\n            emit RewardsSet(_addresses[i], _rewards[i]);\n        }\n    }\n\n    // Public functions\n\n    function claimRewards() public {\n        uint256 reward = rewardsOf[msg.sender];\n        require(reward > 0, \"PuushdotRewards: No rewards to claim\");\n        rewardsOf[msg.sender] = 0;\n        IERC20(rewardTokenAddress).transfer(msg.sender, reward);\n        emit RewardClaimed(msg.sender, reward);\n    }\n}\n"
    },
    "contracts/Puushdot/extras/PuushdotSpotlight.sol": {
      "content": "// FILE: PuushdotSpotlight.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PuushdotSpotlight is Ownable {\n    constructor() Ownable(msg.sender) {}\n\n    event SpotlightPurchased(address coinAddress, address buyer);\n\n    uint256 public spotlightCost = 500 ether;\n    uint256 public lastSpotlightTimestamp = 0;\n    uint256 public spotlightDuration = 36000; // In Seconds\n\n    address public spotlightedCoin;\n    address public feeWallet;\n\n    function setSpotlightCost(uint256 _spotlightCost) external onlyOwner {\n        require(\n            _spotlightCost > 50 ether,\n            \"Spotlight cost must be greater than 50 ether\"\n        );\n        spotlightCost = _spotlightCost;\n    }\n\n    function setSpotlightDuration(\n        uint256 _spotlightDuration\n    ) external onlyOwner {\n        require(\n            _spotlightDuration > 36000,\n            \"Spotlight duration must be greater than 36000 seconds\"\n        );\n        spotlightDuration = _spotlightDuration;\n    }\n\n    function setFeeWallet(address _feeWallet) external onlyOwner {\n        feeWallet = _feeWallet;\n    }\n\n    function buySpotlight(address _coinAddress) external payable {\n        require(feeWallet != address(0), \"Fee wallet is not set\");\n        require(msg.value == spotlightCost, \"Insufficient funds\");\n        require(\n            block.timestamp - lastSpotlightTimestamp > spotlightDuration,\n            \"Spotlight is still active\"\n        );\n        lastSpotlightTimestamp = block.timestamp;\n        spotlightedCoin = _coinAddress;\n        payable(feeWallet).transfer(msg.value);\n\n        emit SpotlightPurchased(_coinAddress, msg.sender);\n    }\n}\n"
    },
    "contracts/Puushdot/extras/PuushdotSpotlightV2.sol": {
      "content": "// FILE: PuushdotSpotlight.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PuushdotSpotlightV2 is Ownable {\n    constructor() Ownable(msg.sender) {}\n\n    event SpotlightPurchased(address coinAddress, address buyer);\n\n    uint256 public spotlightCost = 100 ether;\n    uint256 public lastSpotlightTimestamp = 0;\n    uint256 public spotlightDuration = 900; // In Seconds\n\n    address public spotlightedCoin;\n    address public feeWallet;\n\n    function setSpotlightCost(uint256 _spotlightCost) external onlyOwner {\n        require(\n            _spotlightCost > 50 ether,\n            \"Spotlight cost must be greater than 50 ether\"\n        );\n        spotlightCost = _spotlightCost;\n    }\n\n    function setSpotlightDuration(\n        uint256 _spotlightDuration\n    ) external onlyOwner {\n        require(\n            _spotlightDuration > 300,\n            \"Spotlight duration must be greater than 300 seconds\"\n        );\n        spotlightDuration = _spotlightDuration;\n    }\n\n    function setFeeWallet(address _feeWallet) external onlyOwner {\n        feeWallet = _feeWallet;\n    }\n\n    function buySpotlight(address _coinAddress) external payable {\n        require(feeWallet != address(0), \"Fee wallet is not set\");\n        require(msg.value == spotlightCost, \"Insufficient funds\");\n        require(\n            block.timestamp - lastSpotlightTimestamp > spotlightDuration,\n            \"Spotlight is still active\"\n        );\n        lastSpotlightTimestamp = block.timestamp;\n        spotlightedCoin = _coinAddress;\n        payable(feeWallet).transfer(msg.value);\n\n        emit SpotlightPurchased(_coinAddress, msg.sender);\n    }\n}\n"
    },
    "contracts/Puushdot/extras/PuushdotWin.sol": {
      "content": "// PuushdotWin.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ncontract PuushdotWin is Ownable, ReentrancyGuard {\n    uint256 public constant INITIAL_TIME_LEFT = 1 hours;\n    uint256 public constant TIME_LEFT_INCREMENT = 10 minutes;\n    uint256 public constant MAX_TIME_LEFT = 6 hours;\n    uint256 public constant DEPOSIT_AMOUNT = 100 ether;\n    uint256 public constant DEV_FEE = 5 ether;\n    uint256 public constant JACKPOT_FEE = 10 ether;\n    uint256 public constant ENTRY_BONUS_FEE = 85 ether;\n\n    address public devWallet;\n    address public lastDepositor;\n\n    uint256 public lastDepositTime;\n    uint256 public timeLeft;\n    uint256 public jackpot;\n    uint256 public lastJackpot;\n    address public lastJackpotWinner;\n    uint256 public gameId;\n\n    bool public paused;\n\n    mapping(uint256 => mapping(uint256 => address)) public depositors;\n    mapping(address => uint256) public accWinnings;\n    mapping(uint256 => uint256) public gameDeposits;\n\n    event DepositMade(\n        address user,\n        uint256 amount,\n        uint256 timestamp,\n        uint256 gameId,\n        uint256 depositId,\n        uint256 jackpot\n    );\n    event WinningsClaimed(\n        address user,\n        uint256 amount,\n        uint256 timestamp,\n        uint256 gameId,\n        uint256 depositId\n    );\n    event JackpotWon(\n        address winner,\n        uint256 amount,\n        uint256 timestamp,\n        uint256 gameId,\n        uint256 depositId\n    );\n    event FeeTransferred(address feeWallet, uint256 amount, uint256 timestamp);\n\n    struct GameState {\n        uint256 gameId;\n        uint256 jackpot;\n        uint256 lastJackpot;\n        uint256 lastDepositTime;\n        uint256 currentDepositId;\n        uint256 timeLeft;\n        address lastDepositor;\n        address lastJackpotWinner;\n        bool paused;\n    }\n\n    struct UserGameState {\n        uint256 gameId;\n        uint256 jackpot;\n        uint256 lastJackpot;\n        uint256 lastDepositTime;\n        uint256 lastDepositId;\n        uint256 timeLeft;\n        uint256 accWinnings;\n        address lastDepositor;\n        address lastJackpotWinner;\n        bool paused;\n    }\n\n    constructor(address _devWallet) Ownable(msg.sender) {\n        require(_devWallet != address(0), \"Dev wallet address cannot be zero\");\n        require(\n            ENTRY_BONUS_FEE + JACKPOT_FEE + DEV_FEE == DEPOSIT_AMOUNT,\n            \"Fees must add up to deposit amount\"\n        );\n        devWallet = _devWallet;\n        paused = false;\n        initNewGame();\n    }\n\n    // Owner Functions\n\n    function emergencyWithdraw() public onlyOwner {\n        uint256 contractBalance = address(this).balance;\n        require(contractBalance > 0, \"No funds to withdraw\");\n\n        // Using call instead of transfer\n        (bool success, ) = payable(msg.sender).call{value: contractBalance}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function pauseGame() public onlyOwner {\n        paused = true;\n    }\n\n    function resumeGame() public onlyOwner {\n        paused = false;\n        lastDepositTime = block.timestamp;\n    }\n\n    function setDevWallet(address _devWallet) public onlyOwner {\n        require(_devWallet != address(0), \"Dev wallet address cannot be zero\");\n        devWallet = _devWallet;\n    }\n\n    // Public Functions\n\n    function deposit() public payable nonReentrant {\n        require(!paused, \"Game is paused\");\n        require(msg.value == DEPOSIT_AMOUNT, \"Must deposit exactly 100 ETH\");\n\n        // Transfer the fees\n        (bool success, ) = payable(devWallet).call{value: DEV_FEE}(\"\");\n        require(success, \"Transfer failed\");\n        emit FeeTransferred(devWallet, DEV_FEE, block.timestamp);\n\n        // Check if the last deposit was more than the time left\n        if (jackpot > 0 && block.timestamp > lastDepositTime + timeLeft) {\n            // Previous depositor wins the jackpot\n            payoutJackpot();\n        }\n\n        // Distribute the fees and deposit amount\n        jackpot += JACKPOT_FEE;\n\n        // Get the current game deposits, or 1 if it's the first deposit\n        uint256 currentDeposit = gameDeposits[gameId];\n\n        // Update depositors mapping\n        depositors[gameId][currentDeposit] = msg.sender;\n\n        // Distribute the entry bonus\n        uint256 entryBonusWinnerId = (currentDeposit + 1) / 2;\n        address entryBonusWinner = depositors[gameId][entryBonusWinnerId];\n        accWinnings[entryBonusWinner] += ENTRY_BONUS_FEE;\n\n        // Update the jackpot and the last depositor details\n        gameDeposits[gameId]++;\n        lastDepositor = msg.sender;\n        lastDepositTime = block.timestamp;\n        incrementTimeLeft();\n\n        emit DepositMade(\n            msg.sender,\n            DEPOSIT_AMOUNT,\n            block.timestamp,\n            gameId,\n            currentDeposit,\n            jackpot\n        );\n    }\n\n    function claimWinnings() public nonReentrant {\n        uint256 amount = accWinnings[msg.sender];\n        require(amount > 0, \"No amount to claim\");\n\n        // Reset the claimable amount\n        accWinnings[msg.sender] = 0;\n\n        // Send amount using call\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n\n        emit WinningsClaimed(\n            msg.sender,\n            amount,\n            block.timestamp,\n            gameId,\n            gameDeposits[gameId]\n        );\n    }\n\n    // Internal Functions\n\n    function incrementTimeLeft() internal {\n        uint256 currentTimeLeft = viewTimeLeft();\n\n        if (currentTimeLeft + TIME_LEFT_INCREMENT < MAX_TIME_LEFT) {\n            timeLeft = currentTimeLeft + TIME_LEFT_INCREMENT;\n        } else {\n            timeLeft = MAX_TIME_LEFT;\n        }\n    }\n\n    function payoutJackpot() internal {\n        require(jackpot > 0, \"No jackpot to payout\");\n\n        uint256 amount = jackpot;\n        uint256 currentGameId = gameId;\n        address winner = lastDepositor;\n\n        lastJackpotWinner = winner;\n        lastJackpot = amount;\n\n        // Reset the jackpot and progress to next game\n        initNewGame();\n\n        // Increase user winnings\n        accWinnings[winner] += amount;\n\n        emit JackpotWon(\n            winner,\n            amount,\n            block.timestamp,\n            currentGameId,\n            gameDeposits[currentGameId]\n        );\n    }\n\n    function initNewGame() internal {\n        gameId++; // Must come before gameDeposits[gameId] = 1\n        gameDeposits[gameId] = 1;\n        jackpot = 0;\n        lastDepositor = address(0);\n        lastDepositTime = block.timestamp;\n        timeLeft = INITIAL_TIME_LEFT;\n    }\n\n    // Public View Functions\n\n    function viewTimeLeft() public view returns (uint256) {\n        if (block.timestamp > lastDepositTime + timeLeft) {\n            return 0;\n        } else {\n            return (lastDepositTime + timeLeft) - block.timestamp;\n        }\n    }\n\n    function viewGameState() public view returns (GameState memory) {\n        return\n            GameState({\n                gameId: gameId,\n                jackpot: jackpot,\n                lastJackpot: lastJackpot,\n                lastDepositTime: lastDepositTime,\n                currentDepositId: gameDeposits[gameId],\n                timeLeft: viewTimeLeft(),\n                lastDepositor: lastDepositor,\n                lastJackpotWinner: lastJackpotWinner,\n                paused: paused\n            });\n    }\n\n    function viewUserGameState() public view returns (UserGameState memory) {\n        return\n            UserGameState({\n                gameId: gameId,\n                jackpot: jackpot,\n                lastJackpot: lastJackpot,\n                lastDepositTime: lastDepositTime,\n                lastDepositId: gameDeposits[gameId],\n                timeLeft: viewTimeLeft(),\n                accWinnings: accWinnings[msg.sender],\n                lastDepositor: lastDepositor,\n                lastJackpotWinner: lastJackpotWinner,\n                paused: paused\n            });\n    }\n\n    // Receive function\n\n    receive() external payable {\n        deposit();\n    }\n}\n"
    },
    "contracts/Puushdot/extras/PuushdotWin2.sol": {
      "content": "// PuushdotWin2.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ncontract PuushdotWin2 is Ownable, ReentrancyGuard {\n    uint256 public constant INITIAL_TIME_LEFT = 1 hours;\n    uint256 public constant TIME_LEFT_INCREMENT = 10 minutes;\n    uint256 public constant MAX_TIME_LEFT = 6 hours;\n    uint256 public constant DEPOSIT_AMOUNT = 100 ether;\n    uint256 public constant DEV_FEE = 5 ether;\n    uint256 public constant JACKPOT_FEE = 10 ether;\n    uint256 public constant ENTRY_BONUS_FEE = 85 ether;\n\n    address public devWallet;\n    address public lastDepositor;\n\n    uint256 public lastDepositTime;\n    uint256 public timeLeft;\n    uint256 public jackpot;\n    uint256 public lastJackpot;\n    address public lastJackpotWinner;\n    uint256 public gameId;\n\n    bool public paused;\n\n    mapping(uint256 => mapping(uint256 => address)) public depositors;\n    mapping(address => uint256) public accWinnings;\n    mapping(uint256 => uint256) public gameDeposits;\n\n    event DepositMade(\n        address user,\n        uint256 amount,\n        uint256 timestamp,\n        uint256 gameId,\n        uint256 depositId,\n        uint256 jackpot\n    );\n    event WinningsClaimed(\n        address user,\n        uint256 amount,\n        uint256 timestamp,\n        uint256 gameId,\n        uint256 depositId\n    );\n    event JackpotWon(\n        address winner,\n        uint256 amount,\n        uint256 timestamp,\n        uint256 gameId,\n        uint256 depositId\n    );\n    event FeeTransferred(address feeWallet, uint256 amount, uint256 timestamp);\n\n    struct GameState {\n        uint256 gameId;\n        uint256 jackpot;\n        uint256 lastJackpot;\n        uint256 lastDepositTime;\n        uint256 currentDepositId;\n        uint256 timeLeft;\n        address lastDepositor;\n        address lastJackpotWinner;\n        bool paused;\n    }\n\n    struct UserGameState {\n        uint256 gameId;\n        uint256 jackpot;\n        uint256 lastJackpot;\n        uint256 lastDepositTime;\n        uint256 lastDepositId;\n        uint256 timeLeft;\n        uint256 accWinnings;\n        address lastDepositor;\n        address lastJackpotWinner;\n        bool paused;\n    }\n\n    constructor(address _devWallet) Ownable(msg.sender) {\n        require(_devWallet != address(0), \"Dev wallet address cannot be zero\");\n        require(\n            ENTRY_BONUS_FEE + JACKPOT_FEE + DEV_FEE == DEPOSIT_AMOUNT,\n            \"Fees must add up to deposit amount\"\n        );\n        devWallet = _devWallet;\n        paused = false;\n        initNewGame();\n    }\n\n    // Owner Functions\n\n    function emergencyWithdraw() public onlyOwner {\n        uint256 contractBalance = address(this).balance;\n        require(contractBalance > 0, \"No funds to withdraw\");\n\n        // Using call instead of transfer\n        (bool success, ) = payable(msg.sender).call{value: contractBalance}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function pauseGame() public onlyOwner {\n        paused = true;\n    }\n\n    function resumeGame() public onlyOwner {\n        paused = false;\n        lastDepositTime = block.timestamp;\n    }\n\n    function setDevWallet(address _devWallet) public onlyOwner {\n        require(_devWallet != address(0), \"Dev wallet address cannot be zero\");\n        devWallet = _devWallet;\n    }\n\n    // Public Functions\n\n    function deposit() public payable nonReentrant {\n        require(!paused, \"Game is paused\");\n        require(msg.value == DEPOSIT_AMOUNT, \"Must deposit exactly 100 ETH\");\n\n        // Transfer the fees\n        (bool success, ) = payable(devWallet).call{value: DEV_FEE}(\"\");\n        require(success, \"Transfer failed\");\n        emit FeeTransferred(devWallet, DEV_FEE, block.timestamp);\n\n        // Check if the last deposit was more than the time left\n        if (jackpot > 0 && block.timestamp > lastDepositTime + timeLeft) {\n            // Previous depositor wins the jackpot\n            payoutJackpot();\n        }\n\n        // Distribute the fees and deposit amount\n        jackpot += JACKPOT_FEE;\n\n        // Get the current game deposits, or 1 if it's the first deposit\n        uint256 currentDeposit = gameDeposits[gameId];\n\n        // Update depositors mapping\n        depositors[gameId][currentDeposit] = msg.sender;\n\n        // Distribute the entry bonus\n        uint256 entryBonusWinnerId = (currentDeposit + 1) / 2;\n        address entryBonusWinner = depositors[gameId][entryBonusWinnerId];\n        accWinnings[entryBonusWinner] += ENTRY_BONUS_FEE;\n\n        // Update the jackpot and the last depositor details\n        gameDeposits[gameId]++;\n        lastDepositor = msg.sender;\n        incrementTimeLeft();\n\n        emit DepositMade(\n            msg.sender,\n            DEPOSIT_AMOUNT,\n            block.timestamp,\n            gameId,\n            currentDeposit,\n            jackpot\n        );\n    }\n\n    function claimWinnings() public nonReentrant {\n        uint256 amount = accWinnings[msg.sender];\n        require(amount > 0, \"No amount to claim\");\n\n        // Reset the claimable amount\n        accWinnings[msg.sender] = 0;\n\n        // Send amount using call\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n\n        emit WinningsClaimed(\n            msg.sender,\n            amount,\n            block.timestamp,\n            gameId,\n            gameDeposits[gameId]\n        );\n    }\n\n    // Internal Functions\n\n    function incrementTimeLeft() internal {\n        uint256 elapsedTime = block.timestamp - lastDepositTime;\n\n        if (elapsedTime < timeLeft) {\n            uint256 newTimeLeft = timeLeft - elapsedTime + TIME_LEFT_INCREMENT;\n\n            if (newTimeLeft < MAX_TIME_LEFT) {\n                timeLeft = newTimeLeft;\n            } else {\n                timeLeft = MAX_TIME_LEFT;\n            }\n        } else {\n            timeLeft = INITIAL_TIME_LEFT; // For when contract is first deployed and jackpot is 0\n        }\n\n        // Update the last deposit time after adjusting timeLeft\n        lastDepositTime = block.timestamp;\n    }\n\n    function payoutJackpot() internal {\n        require(jackpot > 0, \"No jackpot to payout\");\n\n        uint256 amount = jackpot;\n        uint256 currentGameId = gameId;\n        address winner = lastDepositor;\n\n        lastJackpotWinner = winner;\n        lastJackpot = amount;\n\n        // Reset the jackpot and progress to next game\n        initNewGame();\n\n        // Increase user winnings\n        accWinnings[winner] += amount;\n\n        emit JackpotWon(\n            winner,\n            amount,\n            block.timestamp,\n            currentGameId,\n            gameDeposits[currentGameId]\n        );\n    }\n\n    function initNewGame() internal {\n        gameId++; // Must come before gameDeposits[gameId] = 1\n        gameDeposits[gameId] = 1;\n        jackpot = 0;\n        lastDepositor = address(0);\n        lastDepositTime = block.timestamp;\n        timeLeft = INITIAL_TIME_LEFT;\n    }\n\n    // Public View Functions\n\n    function viewTimeLeft() public view returns (uint256) {\n        if (block.timestamp > lastDepositTime + timeLeft) {\n            return 0;\n        } else {\n            return (lastDepositTime + timeLeft) - block.timestamp;\n        }\n    }\n\n    function viewGameState() public view returns (GameState memory) {\n        return\n            GameState({\n                gameId: gameId,\n                jackpot: jackpot,\n                lastJackpot: lastJackpot,\n                lastDepositTime: lastDepositTime,\n                currentDepositId: gameDeposits[gameId],\n                timeLeft: viewTimeLeft(),\n                lastDepositor: lastDepositor,\n                lastJackpotWinner: lastJackpotWinner,\n                paused: paused\n            });\n    }\n\n    function viewUserGameState() public view returns (UserGameState memory) {\n        return\n            UserGameState({\n                gameId: gameId,\n                jackpot: jackpot,\n                lastJackpot: lastJackpot,\n                lastDepositTime: lastDepositTime,\n                lastDepositId: gameDeposits[gameId],\n                timeLeft: viewTimeLeft(),\n                accWinnings: accWinnings[msg.sender],\n                lastDepositor: lastDepositor,\n                lastJackpotWinner: lastJackpotWinner,\n                paused: paused\n            });\n    }\n\n    // Receive function\n\n    receive() external payable {\n        deposit();\n    }\n}\n"
    },
    "contracts/Puushdot/Redrops/Beer.sol": {
      "content": "// FILE: Beer.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract Beer is ERC20 {\n    /**\n     * @dev Constructor that gives msg.sender all of existing tokens.\n     */\n    constructor() ERC20(\"Pure Liquid GOLD\", \"$BEER\") {\n        _mint(msg.sender, 1000000000000000000000000000); // 1 Billion tokens\n    }\n}\n"
    },
    "contracts/Puushdot/V1/PuushdotCoin.sol": {
      "content": "// FILE: PuushdotCoin.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract PuushdotCoin is ERC20 {\n    /**\n     * @dev Constructor that gives msg.sender all of existing tokens.\n     */\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _mint(msg.sender, 1000000000000000000000000000); // 1 Billion tokens\n    }\n}\n"
    },
    "contracts/Puushdot/V1/PuushdotFun.sol": {
      "content": "// FILE: PuushdotFun.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./PuushdotCoin.sol\";\nimport \"./PuushdotFunds.sol\";\n\ncontract PuushdotFun is Ownable {\n    using Math for uint256;\n\n    uint256 public coinCreationEthCost = 50 ether;\n    uint256 public coinGraduationThreshold = 200000000 ether;\n\n    address payable public feeWallet;\n    address public deadAddress = 0x000000000000000000000000000000000000dEaD;\n\n    mapping(address => address) public fundsMap; // Coin => Funds\n\n    IRouter01 public graduateRouter;\n\n    constructor(address payable _feeWallet) Ownable(msg.sender) {\n        feeWallet = _feeWallet;\n    }\n\n    event CoinCreated(\n        address coinAddress,\n        address fundsAddress,\n        address coinCreator,\n        uint256 coinToFunds,\n        string metaURI\n    );\n\n    event CoinsBought(\n        address coinAddress,\n        address userAddress,\n        uint256 ethToFund,\n        uint256 ethToFee,\n        uint256 coinsToUser,\n        uint256 newEthReserve,\n        uint256 newCoinReserve\n    );\n\n    event CoinsSold(\n        address coinAddress,\n        address userAddress,\n        uint256 coinsToFund,\n        uint256 ethToFee,\n        uint256 ethToUser,\n        uint256 newEthReserve,\n        uint256 newCoinReserve\n    );\n\n    event GraduatedAndBurned(\n        address coinAddress,\n        address fundsAddress,\n        address graduatePairAddress,\n        uint256 amountCoinsGraduated,\n        uint256 amountEthGraduated,\n        uint256 amountPairBurned\n    );\n\n    event FundsRetrieved(\n        address coinAddress,\n        address fundsAddress,\n        uint256 coinRetrieved,\n        uint256 ethRetrieved\n    );\n\n    function setCoinCreationEthCost(\n        uint256 _coinCreationEthCost\n    ) public onlyOwner {\n        require(_coinCreationEthCost > 0, \"Cost must be greater than 0\");\n        coinCreationEthCost = _coinCreationEthCost;\n    }\n\n    function setFeeWallet(address payable _feeWallet) public onlyOwner {\n        require(_feeWallet != address(0), \"Invalid fee wallet address\");\n        feeWallet = _feeWallet;\n    }\n\n    function setGraduateRouter(address _router) public onlyOwner {\n        require(_router != address(0), \"Invalid router address\");\n        graduateRouter = IRouter01(_router);\n    }\n\n    function createCoin(\n        string memory name,\n        string memory symbol,\n        string memory metaURI,\n        uint256 minCoinsToBuy\n    ) public payable {\n        require(msg.value >= coinCreationEthCost, \"Not enough Eth sent\");\n        require(minCoinsToBuy <= 400_000_000 ether, \"Max buy limit reached\");\n\n        // Require checks for name and symbol length\n        require(\n            bytes(name).length > 0 && bytes(name).length <= 32,\n            \"Name must be between 1 and 32 characters\"\n        );\n        require(\n            bytes(symbol).length > 0 && bytes(symbol).length <= 10,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n        require(\n            bytes(metaURI).length > 0 && bytes(metaURI).length <= 200,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n\n        // Transfer the fee to the PumpWallet\n        feeWallet.transfer(coinCreationEthCost);\n\n        PuushdotCoin coin = new PuushdotCoin(name, symbol);\n        uint256 coinToFunds = coin.totalSupply();\n\n        // Create the PuushdotFunds contract and add liquidity\n        PuushdotFunds funds = new PuushdotFunds(\n            address(this),\n            feeWallet,\n            address(coin)\n        );\n        fundsMap[address(coin)] = address(funds);\n\n        // Give funds contract allowance to transfer coins\n        coin.approve(address(funds), coinToFunds);\n\n        // Use the addInitialFunds function to transfer coins to the funds contract\n        funds.addInitialFunds(coinToFunds);\n\n        emit CoinCreated(\n            address(coin),\n            address(funds),\n            msg.sender,\n            coinToFunds,\n            metaURI\n        );\n\n        if (minCoinsToBuy > 0) {\n            require(\n                funds.SUPPLY_FOR_SALE() >= minCoinsToBuy + funds.coinsSold(),\n                \"Exceeds supplied amount\"\n            );\n            (uint256 totalCostWithFee, , ) = funds.getCost(\n                funds.coinsSold(),\n                minCoinsToBuy\n            );\n\n            require(\n                msg.value - coinCreationEthCost >= totalCostWithFee,\n                \"Wrong amount of Eth sent\"\n            );\n\n            (\n                uint256 amountToBuy,\n                uint256 cost,\n                uint256 fee,\n                uint256 ethReserve,\n                uint256 coinReserve\n            ) = funds.buyTokens{value: msg.value - coinCreationEthCost}(\n                    msg.sender,\n                    minCoinsToBuy\n                );\n\n            emit CoinsBought(\n                address(coin),\n                msg.sender,\n                cost,\n                fee,\n                amountToBuy,\n                ethReserve,\n                coinReserve\n            );\n        }\n    }\n\n    function buyCoins(\n        address coinAddress,\n        uint256 minAmountToBuy\n    ) public payable {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        (\n            uint256 amountToBuy,\n            uint256 cost,\n            uint256 fee,\n            uint256 ethReserve,\n            uint256 coinReserve\n        ) = PuushdotFunds(funds).buyTokens{value: msg.value}(\n                msg.sender,\n                minAmountToBuy\n            );\n\n        emit CoinsBought(\n            coinAddress,\n            msg.sender,\n            cost,\n            fee,\n            amountToBuy,\n            ethReserve,\n            coinReserve\n        );\n\n        monitorMarketCapAndGraduateCoin(coinAddress, coinReserve);\n    }\n\n    function sellCoins(\n        address coinAddress,\n        uint256 amountToSell,\n        uint256 minEthGained\n    ) public {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        (\n            uint256 ethReturn,\n            uint256 fee,\n            uint256 ethReserve,\n            uint256 coinReserve\n        ) = PuushdotFunds(funds).sellTokens(\n                msg.sender,\n                amountToSell,\n                minEthGained\n            );\n\n        emit CoinsSold(\n            coinAddress,\n            msg.sender,\n            amountToSell,\n            fee,\n            ethReturn,\n            ethReserve,\n            coinReserve\n        );\n    }\n\n    function monitorMarketCapAndGraduateCoin(\n        address coinAddress,\n        uint256 coinReserve\n    ) internal {\n        if (coinReserve > coinGraduationThreshold) return; // Coin not ready to graduate\n\n        PuushdotFunds funds = PuushdotFunds(fundsMap[coinAddress]);\n\n        // Take all liquidity from the PumpPair\n        (uint256 coinsRetrieved, uint256 ethRetrieved) = PuushdotFunds(funds)\n            .retrieveFunds();\n\n        emit FundsRetrieved(\n            coinAddress,\n            fundsMap[coinAddress],\n            coinsRetrieved,\n            ethRetrieved\n        );\n\n        if (coinsRetrieved > 0 && ethRetrieved > 0) {\n            // Calculate fees\n            // Take 5% of eth and 0.5% coin from the funds\n            uint256 coinPlatformFee = coinsRetrieved / 200;\n            uint256 ethPlatformFee = ethRetrieved / 20;\n\n            uint256 amountCoinsToGraduate = coinsRetrieved - coinPlatformFee;\n            uint256 amountEthToGraduate = ethRetrieved - ethPlatformFee;\n\n            // Send platform fees to fee wallet\n            require(\n                IERC20(coinAddress).transfer(feeWallet, coinPlatformFee),\n                \"Coin transfer failed\"\n            );\n            (bool success, ) = feeWallet.call{value: ethPlatformFee}(\"\");\n            require(success, \"ETH transfer failed\");\n\n            // Add new liquidity on graduate platform\n            graduateAndBurn(\n                coinAddress,\n                amountCoinsToGraduate,\n                amountEthToGraduate\n            );\n        }\n    }\n\n    function graduateAndBurn(\n        address coinAddress,\n        uint256 amountCoin,\n        uint256 amountETH\n    ) internal {\n        IFactory graduateFactory = IFactory(graduateRouter.factory());\n        IERC20(coinAddress).approve(address(graduateRouter), amountCoin);\n\n        graduateRouter.addLiquidityETH{value: amountETH}(\n            coinAddress,\n            amountCoin,\n            0, // Slippage is unavoidable\n            0, // Slippage is unavoidable\n            address(this),\n            block.timestamp\n        );\n\n        address pair = graduateFactory.getPair(\n            coinAddress,\n            graduateRouter.WETH()\n        );\n\n        if (pair == address(0)) {\n            revert(\"Pair not created\");\n        }\n        uint256 pairBalance = IERC20(pair).balanceOf(address(this));\n        // Burn liquidity tokens\n        IERC20(pair).transfer(deadAddress, pairBalance);\n\n        emit GraduatedAndBurned(\n            coinAddress,\n            fundsMap[coinAddress],\n            pair,\n            amountCoin,\n            amountETH,\n            pairBalance\n        );\n    }\n\n    // To receive Eth from funds contract\n    receive() external payable {}\n}\n\ninterface IFactory {\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair);\n}\n\ninterface IRouter01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint amountToken, uint amountETH, uint liquidity);\n}\n"
    },
    "contracts/Puushdot/V1/PuushdotFunds.sol": {
      "content": "// FILE: PuushdotFunds.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\"; // Importing the Math library from OpenZeppelin\n\ncontract PuushdotFunds {\n    using Math for uint256; // Using the Math library for uint256\n\n    address public puushDotFun;\n    address public feeWallet;\n\n    uint256 public ethReserve;\n    uint256 public coinReserve;\n    uint256 public initialCoinReserve;\n    uint256 public coinsSold = 0;\n\n    uint256 public constant SUPPLY_FOR_SALE = 800_000_000 * 10 ** 18;\n    uint256 public constant START_PRICE = 22_727_272_727_272;\n    uint256 public constant END_PRICE = 227_272_727_272_727;\n\n    bool public isGraduated = false;\n\n    IERC20 public coin;\n\n    constructor(\n        address _puushDotFun,\n        address _feeWallet,\n        address _coinAddress\n    ) {\n        puushDotFun = _puushDotFun;\n        feeWallet = _feeWallet;\n        coin = IERC20(_coinAddress);\n    }\n\n    modifier onlyFun() {\n        require(\n            msg.sender == puushDotFun,\n            \"Only the factory can call this function\"\n        );\n        _;\n    }\n\n    function addInitialFunds(uint256 amountCoinDesired) external onlyFun {\n        require(coin.balanceOf(address(this)) == 0, \"Funds already added\");\n        coinReserve = amountCoinDesired;\n        initialCoinReserve = amountCoinDesired;\n        coin.transferFrom(msg.sender, address(this), amountCoinDesired);\n    }\n\n    function retrieveFunds() external onlyFun returns (uint256, uint256) {\n        isGraduated = true;\n\n        uint256 coinToTransfer = coinReserve;\n        uint256 ethToTransfer = ethReserve;\n\n        uint256 coinBalance = coin.balanceOf(address(this));\n        uint256 ethBalance = address(this).balance;\n\n        if (coinBalance < coinReserve) {\n            coinToTransfer = coinBalance;\n        }\n\n        if (ethBalance > ethReserve) {\n            ethToTransfer = ethBalance;\n        }\n\n        coinReserve = 0;\n        ethReserve = 0;\n\n        // Transfer coins first to reduce potential reentrancy issues\n        if (coinToTransfer > 0) {\n            require(\n                coin.transfer(puushDotFun, coinToTransfer),\n                \"Coin transfer failed\"\n            );\n        }\n\n        // Transfer ETH\n        if (ethToTransfer > 0) {\n            (bool success, ) = puushDotFun.call{value: ethToTransfer}(\"\");\n            require(success, \"ETH transfer failed\");\n        }\n\n        return (coinToTransfer, ethToTransfer);\n    }\n\n    function getFunds() public view returns (uint256, uint256) {\n        return (coinReserve, ethReserve);\n    }\n\n    function buyTokens(\n        address user,\n        uint256 minAmountToBuy\n    )\n        public\n        payable\n        onlyFun\n        returns (uint256, uint256, uint256, uint256, uint256)\n    {\n        require(msg.value > 0, \"No ETH sent\");\n        require(!isGraduated, \"Funds are no longer for sale\");\n        if (minAmountToBuy + coinsSold > SUPPLY_FOR_SALE) {\n            minAmountToBuy = SUPPLY_FOR_SALE - coinsSold;\n        }\n\n        uint256 ethSent = msg.value;\n        uint256 amountToBuy = getAmountToBuy(coinsSold, ethSent);\n\n        require(\n            amountToBuy >= minAmountToBuy,\n            \"Slippage: Tokens received less than minimum required\"\n        );\n        require(\n            SUPPLY_FOR_SALE >= amountToBuy + coinsSold,\n            \"Exceeds supplied amount\"\n        );\n\n        (uint256 totalCostWithFee, uint256 cost, uint256 fee) = getCost(\n            coinsSold,\n            amountToBuy\n        );\n        require(totalCostWithFee <= ethSent, \"Insufficient ETH sent\");\n\n        ethReserve += cost;\n        coinReserve -= amountToBuy;\n        coinsSold += amountToBuy;\n\n        require(coin.transfer(user, amountToBuy), \"Token transfer failed\");\n\n        // Transfer the fee to the fee wallet\n        (bool feeSent, ) = feeWallet.call{value: fee}(\"\");\n        require(feeSent, \"Fee transfer failed\");\n\n        // Refund excess ETH\n        if (ethSent > totalCostWithFee) {\n            uint256 excess = ethSent - totalCostWithFee;\n            (bool refundSent, ) = user.call{value: excess}(\"\");\n            require(refundSent, \"Refund failed\");\n        }\n\n        return (amountToBuy, cost, fee, ethReserve, coinReserve);\n    }\n\n    function sellTokens(\n        address user,\n        uint256 amountToSell,\n        uint256 minEthGained\n    ) public onlyFun returns (uint256, uint256, uint256, uint256) {\n        require(amountToSell > 0, \"Amount to sell must be greater than 0\");\n        require(coinsSold >= amountToSell, \"Insufficient coins sold\");\n        require(ethReserve > 0, \"ETH reserve is empty\");\n        require(!isGraduated, \"Funds are no longer for sale\");\n\n        (uint256 ethReturnWithFee, uint256 ethReturn, uint256 fee) = getReturn(\n            coinsSold,\n            amountToSell\n        );\n        require(\n            coinReserve + amountToSell <= initialCoinReserve,\n            \"Exceeds supply limit\"\n        );\n        require(\n            ethReturn >= minEthGained,\n            \"Slippage: ETH gained is less than minimum required\"\n        );\n        require(ethReturnWithFee <= ethReserve, \"Insufficient ETH in reserve\");\n\n        ethReserve -= ethReturnWithFee;\n        coinReserve += amountToSell;\n        coinsSold -= amountToSell;\n\n        require(\n            coin.transferFrom(user, address(this), amountToSell),\n            \"Token transfer failed\"\n        );\n\n        (bool ethSent, ) = user.call{value: ethReturn}(\"\");\n        require(ethSent, \"ETH transfer failed\");\n\n        // Transfer the fee to the fee wallet\n        (bool feeSent, ) = feeWallet.call{value: fee}(\"\");\n        require(feeSent, \"Fee transfer failed\");\n\n        return (ethReturn, fee, ethReserve, coinReserve);\n    }\n\n    // Function to calculate the amount of tokens that can be bought with the given ETH\n    function getAmountToBuy(\n        uint256 currentSupplySold,\n        uint256 ethSent\n    ) public pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = SUPPLY_FOR_SALE - currentSupplySold;\n        uint256 mid;\n        uint256 cost;\n\n        while (low < high) {\n            mid = (low + high + 1) / 2;\n            (cost, , ) = getCost(currentSupplySold, mid);\n\n            if (cost <= ethSent) {\n                low = mid;\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        return roundDownToNearest(low, 100000);\n    }\n\n    // Function to round down to the nearest 100k wei\n    function roundDownToNearest(\n        uint256 value,\n        uint256 precision\n    ) internal pure returns (uint256) {\n        return (value / precision) * precision;\n    }\n\n    function getCost(\n        uint256 currentSupplySold,\n        uint256 amountToBuy\n    )\n        public\n        pure\n        returns (uint256 totalCostWithFee, uint256 cost, uint256 fee)\n    {\n        uint256 start = currentSupplySold;\n        uint256 end = currentSupplySold + amountToBuy;\n\n        uint256 startPricePerToken = interpolatePrice(start);\n        uint256 endPricePerToken = interpolatePrice(end);\n\n        uint256 avgPricePerToken = Math.mulDiv(\n            (startPricePerToken + endPricePerToken),\n            1e18,\n            2 * 1e18\n        );\n\n        cost = Math.mulDiv(avgPricePerToken, amountToBuy, 1e18); // Adjust for wei\n        fee = Math.mulDiv(cost, 1, 100); // 1% fee\n        totalCostWithFee = cost + fee;\n\n        return (totalCostWithFee, cost, fee);\n    }\n\n    function getReturn(\n        uint256 currentSupplySold,\n        uint256 amountToSell\n    )\n        public\n        view\n        returns (uint256 totalReturnWithFee, uint256 ethReturn, uint256 fee)\n    {\n        uint256 start = currentSupplySold;\n        uint256 end = currentSupplySold - amountToSell;\n\n        uint256 startPricePerToken = interpolatePrice(start);\n        uint256 endPricePerToken = interpolatePrice(end);\n\n        uint256 avgPricePerToken = Math.mulDiv(\n            (startPricePerToken + endPricePerToken),\n            1e18,\n            2 * 1e18\n        );\n\n        uint256 ethGrossReturn = Math.mulDiv(\n            avgPricePerToken,\n            amountToSell,\n            1e18\n        ); // Adjust for wei\n\n        fee = Math.mulDiv(ethGrossReturn, 1, 100); // 1% fee\n        ethReturn = ethGrossReturn - fee; // Amount user gets after fee\n        totalReturnWithFee = ethGrossReturn; // Total amount including fee\n\n        // Check if selling the remaining coins\n        if (amountToSell + coinReserve == initialCoinReserve) {\n            totalReturnWithFee = ethReserve;\n            fee = Math.mulDiv(totalReturnWithFee, 1, 100); // 1% fee\n            ethReturn = totalReturnWithFee - fee;\n        }\n\n        return (totalReturnWithFee, ethReturn, fee);\n    }\n\n    function interpolatePrice(uint256 supply) internal pure returns (uint256) {\n        uint256 price = START_PRICE +\n            Math.mulDiv((END_PRICE - START_PRICE), supply, SUPPLY_FOR_SALE);\n        return price;\n    }\n}\n"
    },
    "contracts/Puushdot/V1/PuushdotFunGradTest.sol": {
      "content": "// FILE: PuushdotFun.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./PuushdotCoin.sol\";\nimport \"./PuushdotFunds.sol\";\n\ncontract PuushdotFunGradTest is Ownable {\n    using Math for uint256;\n\n    uint256 public coinCreationEthCost = 50 ether;\n    uint256 public coinGraduationThreshold = 999901334 ether;\n\n    address payable public feeWallet;\n    address public deadAddress = 0x000000000000000000000000000000000000dEaD;\n\n    mapping(address => address) public fundsMap; // Coin => Funds\n\n    IRouter01 public graduateRouter;\n\n    constructor(address payable _feeWallet) Ownable(msg.sender) {\n        feeWallet = _feeWallet;\n    }\n\n    event CoinCreated(\n        address coinAddress,\n        address fundsAddress,\n        address coinCreator,\n        uint256 coinToFunds,\n        string metaURI\n    );\n\n    event CoinsBought(\n        address coinAddress,\n        address userAddress,\n        uint256 ethToFund,\n        uint256 ethToFee,\n        uint256 coinsToUser,\n        uint256 newEthReserve,\n        uint256 newCoinReserve\n    );\n\n    event CoinsSold(\n        address coinAddress,\n        address userAddress,\n        uint256 coinsToFund,\n        uint256 ethToFee,\n        uint256 ethToUser,\n        uint256 newEthReserve,\n        uint256 newCoinReserve\n    );\n\n    event GraduatedAndBurned(\n        address coinAddress,\n        address fundsAddress,\n        address graduatePairAddress,\n        uint256 amountCoinsGraduated,\n        uint256 amountEthGraduated,\n        uint256 amountPairBurned\n    );\n\n    event FundsRetrieved(\n        address coinAddress,\n        address fundsAddress,\n        uint256 coinRetrieved,\n        uint256 ethRetrieved\n    );\n\n    function setCoinCreationEthCost(\n        uint256 _coinCreationEthCost\n    ) public onlyOwner {\n        require(_coinCreationEthCost > 0, \"Cost must be greater than 0\");\n        coinCreationEthCost = _coinCreationEthCost;\n    }\n\n    function setFeeWallet(address payable _feeWallet) public onlyOwner {\n        require(_feeWallet != address(0), \"Invalid fee wallet address\");\n        feeWallet = _feeWallet;\n    }\n\n    function setGraduateRouter(address _router) public onlyOwner {\n        require(_router != address(0), \"Invalid router address\");\n        graduateRouter = IRouter01(_router);\n    }\n\n    function createCoin(\n        string memory name,\n        string memory symbol,\n        string memory metaURI,\n        uint256 minCoinsToBuy\n    ) public payable {\n        require(msg.value >= coinCreationEthCost, \"Not enough Eth sent\");\n        require(minCoinsToBuy <= 400_000_000 ether, \"Max buy limit reached\");\n\n        // Require checks for name and symbol length\n        require(\n            bytes(name).length > 0 && bytes(name).length <= 32,\n            \"Name must be between 1 and 32 characters\"\n        );\n        require(\n            bytes(symbol).length > 0 && bytes(symbol).length <= 10,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n        require(\n            bytes(metaURI).length > 0 && bytes(metaURI).length <= 200,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n\n        // Transfer the fee to the PumpWallet\n        feeWallet.transfer(coinCreationEthCost);\n\n        PuushdotCoin coin = new PuushdotCoin(name, symbol);\n        uint256 coinToFunds = coin.totalSupply();\n\n        // Create the PuushdotFunds contract and add liquidity\n        PuushdotFunds funds = new PuushdotFunds(\n            address(this),\n            feeWallet,\n            address(coin)\n        );\n        fundsMap[address(coin)] = address(funds);\n\n        // Give funds contract allowance to transfer coins\n        coin.approve(address(funds), coinToFunds);\n\n        // Use the addInitialFunds function to transfer coins to the funds contract\n        funds.addInitialFunds(coinToFunds);\n\n        emit CoinCreated(\n            address(coin),\n            address(funds),\n            msg.sender,\n            coinToFunds,\n            metaURI\n        );\n\n        if (minCoinsToBuy > 0) {\n            require(\n                funds.SUPPLY_FOR_SALE() >= minCoinsToBuy + funds.coinsSold(),\n                \"Exceeds supplied amount\"\n            );\n            (uint256 totalCostWithFee, , ) = funds.getCost(\n                funds.coinsSold(),\n                minCoinsToBuy\n            );\n\n            require(\n                msg.value - coinCreationEthCost >= totalCostWithFee,\n                \"Wrong amount of Eth sent\"\n            );\n\n            (\n                uint256 amountToBuy,\n                uint256 cost,\n                uint256 fee,\n                uint256 ethReserve,\n                uint256 coinReserve\n            ) = funds.buyTokens{value: msg.value - coinCreationEthCost}(\n                    msg.sender,\n                    minCoinsToBuy\n                );\n\n            emit CoinsBought(\n                address(coin),\n                msg.sender,\n                cost,\n                fee,\n                amountToBuy,\n                ethReserve,\n                coinReserve\n            );\n        }\n    }\n\n    function buyCoins(\n        address coinAddress,\n        uint256 minAmountToBuy\n    ) public payable {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        (\n            uint256 amountToBuy,\n            uint256 cost,\n            uint256 fee,\n            uint256 ethReserve,\n            uint256 coinReserve\n        ) = PuushdotFunds(funds).buyTokens{value: msg.value}(\n                msg.sender,\n                minAmountToBuy\n            );\n\n        emit CoinsBought(\n            coinAddress,\n            msg.sender,\n            cost,\n            fee,\n            amountToBuy,\n            ethReserve,\n            coinReserve\n        );\n\n        monitorMarketCapAndGraduateCoin(coinAddress, coinReserve);\n    }\n\n    function sellCoins(\n        address coinAddress,\n        uint256 amountToSell,\n        uint256 minEthGained\n    ) public {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        (\n            uint256 ethReturn,\n            uint256 fee,\n            uint256 ethReserve,\n            uint256 coinReserve\n        ) = PuushdotFunds(funds).sellTokens(\n                msg.sender,\n                amountToSell,\n                minEthGained\n            );\n\n        emit CoinsSold(\n            coinAddress,\n            msg.sender,\n            amountToSell,\n            fee,\n            ethReturn,\n            ethReserve,\n            coinReserve\n        );\n    }\n\n    function monitorMarketCapAndGraduateCoin(\n        address coinAddress,\n        uint256 coinReserve\n    ) internal {\n        if (coinReserve > coinGraduationThreshold) return; // Coin not ready to graduate\n\n        PuushdotFunds funds = PuushdotFunds(fundsMap[coinAddress]);\n\n        // Take all liquidity from the PumpPair\n        (uint256 coinsRetrieved, uint256 ethRetrieved) = PuushdotFunds(funds)\n            .retrieveFunds();\n\n        emit FundsRetrieved(\n            coinAddress,\n            fundsMap[coinAddress],\n            coinsRetrieved,\n            ethRetrieved\n        );\n\n        if (coinsRetrieved > 0 && ethRetrieved > 0) {\n            // Calculate fees\n            // Take 5% of eth and 0.5% coin from the funds\n            uint256 coinPlatformFee = coinsRetrieved / 200;\n            uint256 ethPlatformFee = ethRetrieved / 20;\n\n            uint256 amountCoinsToGraduate = coinsRetrieved - coinPlatformFee;\n            uint256 amountEthToGraduate = ethRetrieved - ethPlatformFee;\n\n            // Send platform fees to fee wallet\n            require(\n                IERC20(coinAddress).transfer(feeWallet, coinPlatformFee),\n                \"Coin transfer failed\"\n            );\n            (bool success, ) = feeWallet.call{value: ethPlatformFee}(\"\");\n            require(success, \"ETH transfer failed\");\n\n            // Add new liquidity on graduate platform\n            graduateAndBurn(\n                coinAddress,\n                amountCoinsToGraduate,\n                amountEthToGraduate\n            );\n        }\n    }\n\n    function graduateAndBurn(\n        address coinAddress,\n        uint256 amountCoin,\n        uint256 amountETH\n    ) internal {\n        IFactory graduateFactory = IFactory(graduateRouter.factory());\n        IERC20(coinAddress).approve(address(graduateRouter), amountCoin);\n\n        graduateRouter.addLiquidityETH{value: amountETH}(\n            coinAddress,\n            amountCoin,\n            0, // Slippage is unavoidable\n            0, // Slippage is unavoidable\n            address(this),\n            block.timestamp\n        );\n\n        address pair = graduateFactory.getPair(\n            coinAddress,\n            graduateRouter.WETH()\n        );\n\n        if (pair == address(0)) {\n            revert(\"Pair not created\");\n        }\n        uint256 pairBalance = IERC20(pair).balanceOf(address(this));\n        // Burn liquidity tokens\n        IERC20(pair).transfer(deadAddress, pairBalance);\n\n        emit GraduatedAndBurned(\n            coinAddress,\n            fundsMap[coinAddress],\n            pair,\n            amountCoin,\n            amountETH,\n            pairBalance\n        );\n    }\n\n    // To receive Eth from funds contract\n    receive() external payable {}\n}\n\ninterface IFactory {\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair);\n}\n\ninterface IRouter01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint amountToken, uint amountETH, uint liquidity);\n}\n"
    },
    "contracts/Puushdot/V1/PuushdotLiquidity.sol": {
      "content": "// FILE: PuushdotCoin.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IFactory {\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n}\n\ninterface IRouter01 {\n    function factory() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint amountToken, uint amountETH, uint liquidity);\n}\n\ncontract PuushdotLiquidity is IFactory, IRouter01, Ownable, ERC20 {\n    address private _factory = address(this);\n    address private _WETH;\n\n    constructor()\n        Ownable(msg.sender)\n        ERC20(\"PuushdotLiquidity\", \"PUUSHDOTLP\")\n    {}\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        override\n        returns (uint amountToken, uint amountETH, uint liquidity)\n    {\n        // Take all eth and coins from msg.sender and transfer to this contract\n        IERC20(token).transferFrom(\n            msg.sender,\n            address(this),\n            amountTokenDesired\n        );\n\n        // Mint 1 LP token to msg.sender\n        _mint(msg.sender, 1);\n    }\n\n    function withdrawERC20Liquidity(address tokenAddress) external onlyOwner {\n        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\n        require(balance > 0, \"No ERC20 tokens to withdraw\");\n        bool success = IERC20(tokenAddress).transfer(msg.sender, balance);\n        require(success, \"ERC20 transfer failed\");\n    }\n\n    function withdrawETHLiquidity()\n        external\n        onlyOwner\n        returns (uint256 balance)\n    {\n        balance = address(this).balance;\n        require(balance > 0, \"No ETH to withdraw\");\n        (bool success, ) = payable(msg.sender).call{value: balance}(\"\");\n        require(success, \"ETH transfer failed\");\n    }\n\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair) {\n        return address(this);\n    }\n\n    function factory() external view returns (address) {\n        return _factory;\n    }\n\n    function WETH() external view returns (address) {\n        return _WETH;\n    }\n}\n"
    },
    "contracts/Puushdot/V101/PuushdotFundsV101.sol": {
      "content": "// FILE: PuushdotFunds.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\"; // Importing the Math library from OpenZeppelin\n\ncontract PuushdotFundsV101 {\n    using Math for uint256; // Using the Math library for uint256\n\n    address public puushDotFun;\n    address public feeWallet;\n\n    uint256 public ethReserve;\n    uint256 public coinReserve;\n    uint256 public initialCoinReserve;\n    uint256 public coinsSold = 0;\n\n    uint256 public constant SUPPLY_FOR_SALE = 800_000_000 * 10 ** 18;\n    uint256 public constant START_PRICE = 22_727_272_727_272;\n    uint256 public constant END_PRICE = 227_272_727_272_727;\n\n    bool public isGraduated = false;\n\n    IERC20 public coin;\n\n    constructor(\n        address _puushDotFun,\n        address _feeWallet,\n        address _coinAddress\n    ) {\n        puushDotFun = _puushDotFun;\n        feeWallet = _feeWallet;\n        coin = IERC20(_coinAddress);\n    }\n\n    modifier onlyFun() {\n        require(\n            msg.sender == puushDotFun,\n            \"Only the factory can call this function\"\n        );\n        _;\n    }\n\n    function addInitialFunds(uint256 amountCoinDesired) external onlyFun {\n        require(coin.balanceOf(address(this)) == 0, \"Funds already added\");\n        coinReserve = amountCoinDesired;\n        initialCoinReserve = amountCoinDesired;\n        coin.transferFrom(msg.sender, address(this), amountCoinDesired);\n    }\n\n    function retrieveFunds() external onlyFun returns (uint256, uint256) {\n        isGraduated = true;\n\n        uint256 coinToTransfer = coinReserve;\n        uint256 ethToTransfer = ethReserve;\n\n        uint256 coinBalance = coin.balanceOf(address(this));\n        uint256 ethBalance = address(this).balance;\n\n        if (coinBalance < coinReserve) {\n            coinToTransfer = coinBalance;\n        }\n\n        if (ethBalance > ethReserve) {\n            ethToTransfer = ethBalance;\n        }\n\n        coinReserve = 0;\n        ethReserve = 0;\n\n        // Transfer coins first to reduce potential reentrancy issues\n        if (coinToTransfer > 0) {\n            require(\n                coin.transfer(puushDotFun, coinToTransfer),\n                \"Coin transfer failed\"\n            );\n        }\n\n        // Transfer ETH\n        if (ethToTransfer > 0) {\n            (bool success, ) = puushDotFun.call{value: ethToTransfer}(\"\");\n            require(success, \"ETH transfer failed\");\n        }\n\n        return (coinToTransfer, ethToTransfer);\n    }\n\n    function getFunds() public view returns (uint256, uint256) {\n        return (coinReserve, ethReserve);\n    }\n\n    function buyTokens(\n        address user,\n        uint256 minAmountToBuy\n    )\n        public\n        payable\n        onlyFun\n        returns (uint256, uint256, uint256, uint256, uint256)\n    {\n        require(msg.value > 0, \"No ETH sent\");\n        require(!isGraduated, \"Funds are no longer for sale\");\n        if (minAmountToBuy + coinsSold > SUPPLY_FOR_SALE) {\n            minAmountToBuy = SUPPLY_FOR_SALE - coinsSold;\n        }\n\n        uint256 ethSent = msg.value;\n        uint256 amountToBuy = getAmountToBuy(coinsSold, ethSent);\n\n        require(\n            amountToBuy >= minAmountToBuy,\n            \"Slippage: Tokens received less than minimum required\"\n        );\n        require(\n            SUPPLY_FOR_SALE >= amountToBuy + coinsSold,\n            \"Exceeds supplied amount\"\n        );\n\n        (uint256 totalCostWithFee, uint256 cost, uint256 fee) = getCost(\n            coinsSold,\n            amountToBuy\n        );\n        require(totalCostWithFee <= ethSent, \"Insufficient ETH sent\");\n\n        ethReserve += cost;\n        coinReserve -= amountToBuy;\n        coinsSold += amountToBuy;\n\n        require(coin.transfer(user, amountToBuy), \"Token transfer failed\");\n\n        // Transfer the fee to the fee wallet\n        (bool feeSent, ) = feeWallet.call{value: fee}(\"\");\n        require(feeSent, \"Fee transfer failed\");\n\n        // Refund excess ETH\n        if (ethSent > totalCostWithFee) {\n            uint256 excess = ethSent - totalCostWithFee;\n            (bool refundSent, ) = user.call{value: excess}(\"\");\n            require(refundSent, \"Refund failed\");\n        }\n\n        return (amountToBuy, cost, fee, ethReserve, coinReserve);\n    }\n\n    function sellTokens(\n        address user,\n        uint256 amountToSell,\n        uint256 minEthGained\n    ) public onlyFun returns (uint256, uint256, uint256, uint256) {\n        require(amountToSell > 0, \"Amount to sell must be greater than 0\");\n        require(coinsSold >= amountToSell, \"Insufficient coins sold\");\n        require(ethReserve > 0, \"ETH reserve is empty\");\n        require(!isGraduated, \"Funds are no longer for sale\");\n\n        (uint256 ethReturnWithFee, uint256 ethReturn, uint256 fee) = getReturn(\n            coinsSold,\n            amountToSell\n        );\n        require(\n            coinReserve + amountToSell <= initialCoinReserve,\n            \"Exceeds supply limit\"\n        );\n        require(\n            ethReturn >= minEthGained,\n            \"Slippage: ETH gained is less than minimum required\"\n        );\n        require(ethReturnWithFee <= ethReserve, \"Insufficient ETH in reserve\");\n\n        ethReserve -= ethReturnWithFee;\n        coinReserve += amountToSell;\n        coinsSold -= amountToSell;\n\n        require(\n            coin.transferFrom(user, address(this), amountToSell),\n            \"Token transfer failed\"\n        );\n\n        (bool ethSent, ) = user.call{value: ethReturn}(\"\");\n        require(ethSent, \"ETH transfer failed\");\n\n        // Transfer the fee to the fee wallet\n        (bool feeSent, ) = feeWallet.call{value: fee}(\"\");\n        require(feeSent, \"Fee transfer failed\");\n\n        return (ethReturn, fee, ethReserve, coinReserve);\n    }\n\n    // Function to calculate the amount of tokens that can be bought with the given ETH\n    function getAmountToBuy(\n        uint256 currentSupplySold,\n        uint256 ethSent\n    ) public pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = SUPPLY_FOR_SALE - currentSupplySold;\n        uint256 mid;\n        uint256 cost;\n\n        while (low < high) {\n            mid = (low + high + 1) / 2;\n            (cost, , ) = getCost(currentSupplySold, mid);\n\n            if (cost <= ethSent) {\n                low = mid;\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        return roundDownToNearest(low, 100000);\n    }\n\n    // Function to round down to the nearest 100k wei\n    function roundDownToNearest(\n        uint256 value,\n        uint256 precision\n    ) internal pure returns (uint256) {\n        return (value / precision) * precision;\n    }\n\n    function getCost(\n        uint256 currentSupplySold,\n        uint256 amountToBuy\n    )\n        public\n        pure\n        returns (uint256 totalCostWithFee, uint256 cost, uint256 fee)\n    {\n        uint256 start = currentSupplySold;\n        uint256 end = currentSupplySold + amountToBuy;\n\n        uint256 startPricePerToken = interpolatePrice(start);\n        uint256 endPricePerToken = interpolatePrice(end);\n\n        uint256 avgPricePerToken = Math.mulDiv(\n            (startPricePerToken + endPricePerToken),\n            1e18,\n            2 * 1e18\n        );\n\n        cost = Math.mulDiv(avgPricePerToken, amountToBuy, 1e18); // Adjust for wei\n        fee = Math.mulDiv(cost, 1, 100); // 1% fee\n        totalCostWithFee = cost + fee;\n\n        return (totalCostWithFee, cost, fee);\n    }\n\n    function getReturn(\n        uint256 currentSupplySold,\n        uint256 amountToSell\n    )\n        public\n        view\n        returns (uint256 totalReturnWithFee, uint256 ethReturn, uint256 fee)\n    {\n        // Can only sell coins divisible by 100k\n        require(\n            amountToSell % 100000 == 0,\n            \"Amount to sell must be divisible by 100k\"\n        );\n\n        uint256 start = currentSupplySold;\n        uint256 end = currentSupplySold - amountToSell;\n\n        uint256 startPricePerToken = interpolatePrice(start);\n        uint256 endPricePerToken = interpolatePrice(end);\n\n        uint256 avgPricePerToken = Math.mulDiv(\n            (startPricePerToken + endPricePerToken),\n            1e18,\n            2 * 1e18\n        );\n\n        uint256 ethGrossReturn = Math.mulDiv(\n            avgPricePerToken,\n            amountToSell,\n            1e18\n        ); // Adjust for wei\n\n        fee = Math.mulDiv(ethGrossReturn, 1, 100); // 1% fee\n        ethReturn = ethGrossReturn - fee; // Amount user gets after fee\n        totalReturnWithFee = ethGrossReturn; // Total amount including fee\n\n        // Check if selling the remaining coins\n        if (amountToSell + coinReserve == initialCoinReserve) {\n            totalReturnWithFee = ethReserve;\n            fee = Math.mulDiv(totalReturnWithFee, 1, 100); // 1% fee\n            ethReturn = totalReturnWithFee - fee;\n        }\n\n        return (totalReturnWithFee, ethReturn, fee);\n    }\n\n    function interpolatePrice(uint256 supply) internal pure returns (uint256) {\n        uint256 price = START_PRICE +\n            Math.mulDiv((END_PRICE - START_PRICE), supply, SUPPLY_FOR_SALE);\n        return price;\n    }\n}\n"
    },
    "contracts/Puushdot/V101/PuushdotFunV101.1.sol": {
      "content": "// FILE: PuushdotFun.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../V1/PuushdotCoin.sol\";\nimport \"./PuushdotFundsV101.sol\";\n\ncontract PuushdotFunV101 is Ownable {\n    using Math for uint256;\n\n    uint256 public coinCreationEthCost = 50 ether;\n    uint256 public coinGraduationThreshold = 200000000 ether;\n\n    address payable public feeWallet;\n    address public deadAddress = 0x000000000000000000000000000000000000dEaD;\n\n    mapping(address => address) public fundsMap; // Coin => Funds\n\n    IRouter01 public graduateRouter;\n\n    constructor(address payable _feeWallet) Ownable(msg.sender) {\n        feeWallet = _feeWallet;\n    }\n\n    event CoinCreated(\n        address coinAddress,\n        address fundsAddress,\n        address coinCreator,\n        uint256 coinToFunds,\n        string metaURI\n    );\n\n    event CoinsBought(\n        address coinAddress,\n        address userAddress,\n        uint256 ethToFund,\n        uint256 ethToFee,\n        uint256 coinsToUser,\n        uint256 newEthReserve,\n        uint256 newCoinReserve\n    );\n\n    event CoinsSold(\n        address coinAddress,\n        address userAddress,\n        uint256 coinsToFund,\n        uint256 ethToFee,\n        uint256 ethToUser,\n        uint256 newEthReserve,\n        uint256 newCoinReserve\n    );\n\n    event GraduatedAndBurned(\n        address coinAddress,\n        address fundsAddress,\n        address graduatePairAddress,\n        uint256 amountCoinsGraduated,\n        uint256 amountEthGraduated,\n        uint256 amountPairBurned\n    );\n\n    event FundsRetrieved(\n        address coinAddress,\n        address fundsAddress,\n        uint256 coinRetrieved,\n        uint256 ethRetrieved\n    );\n\n    // Emergency withdraw function for ETH\n    function emergencyWithdraw() public onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    // Emergency withdraw function for ERC20 tokens\n    function emergencyWithdrawERC20(address token) public onlyOwner {\n        IERC20(token).transfer(\n            msg.sender,\n            IERC20(token).balanceOf(address(this))\n        );\n    }\n\n    function emergencyRetrieveFunds(address coinAddress) public onlyOwner {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        PuushdotFundsV101(funds).retrieveFunds();\n\n        // Send funds to msg.sender\n        IERC20(coinAddress).transfer(\n            msg.sender,\n            IERC20(coinAddress).balanceOf(address(this))\n        );\n\n        // Send ETH to msg.sender\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function setCoinCreationEthCost(\n        uint256 _coinCreationEthCost\n    ) public onlyOwner {\n        require(_coinCreationEthCost > 0, \"Cost must be greater than 0\");\n        coinCreationEthCost = _coinCreationEthCost;\n    }\n\n    function setFeeWallet(address payable _feeWallet) public onlyOwner {\n        require(_feeWallet != address(0), \"Invalid fee wallet address\");\n        feeWallet = _feeWallet;\n    }\n\n    function setGraduateRouter(address _router) public onlyOwner {\n        require(_router != address(0), \"Invalid router address\");\n        graduateRouter = IRouter01(_router);\n    }\n\n    function createCoin(\n        string memory name,\n        string memory symbol,\n        string memory metaURI,\n        uint256 minCoinsToBuy\n    ) public payable {\n        require(msg.value >= coinCreationEthCost, \"Not enough Eth sent\");\n        require(minCoinsToBuy <= 400_000_000 ether, \"Max buy limit reached\");\n\n        // Require checks for name and symbol length\n        require(\n            bytes(name).length > 0 && bytes(name).length <= 32,\n            \"Name must be between 1 and 32 characters\"\n        );\n        require(\n            bytes(symbol).length > 0 && bytes(symbol).length <= 10,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n        require(\n            bytes(metaURI).length > 0 && bytes(metaURI).length <= 200,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n\n        // Transfer the fee to the PumpWallet\n        feeWallet.transfer(coinCreationEthCost);\n\n        PuushdotCoin coin = new PuushdotCoin(name, symbol);\n        uint256 coinToFunds = coin.totalSupply();\n\n        // Create the PuushdotFunds contract and add liquidity\n        PuushdotFundsV101 funds = new PuushdotFundsV101(\n            address(this),\n            feeWallet,\n            address(coin)\n        );\n        fundsMap[address(coin)] = address(funds);\n\n        // Give funds contract allowance to transfer coins\n        coin.approve(address(funds), coinToFunds);\n\n        // Use the addInitialFunds function to transfer coins to the funds contract\n        funds.addInitialFunds(coinToFunds);\n\n        emit CoinCreated(\n            address(coin),\n            address(funds),\n            msg.sender,\n            coinToFunds,\n            metaURI\n        );\n\n        if (minCoinsToBuy > 0) {\n            require(\n                funds.SUPPLY_FOR_SALE() >= minCoinsToBuy + funds.coinsSold(),\n                \"Exceeds supplied amount\"\n            );\n            (uint256 totalCostWithFee, , ) = funds.getCost(\n                funds.coinsSold(),\n                minCoinsToBuy\n            );\n\n            require(\n                msg.value - coinCreationEthCost >= totalCostWithFee,\n                \"Wrong amount of Eth sent\"\n            );\n\n            (\n                uint256 amountToBuy,\n                uint256 cost,\n                uint256 fee,\n                uint256 ethReserve,\n                uint256 coinReserve\n            ) = funds.buyTokens{value: msg.value - coinCreationEthCost}(\n                    msg.sender,\n                    minCoinsToBuy\n                );\n\n            emit CoinsBought(\n                address(coin),\n                msg.sender,\n                cost,\n                fee,\n                amountToBuy,\n                ethReserve,\n                coinReserve\n            );\n        }\n    }\n\n    function buyCoins(\n        address coinAddress,\n        uint256 minAmountToBuy\n    ) public payable {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        (\n            uint256 amountToBuy,\n            uint256 cost,\n            uint256 fee,\n            uint256 ethReserve,\n            uint256 coinReserve\n        ) = PuushdotFundsV101(funds).buyTokens{value: msg.value}(\n                msg.sender,\n                minAmountToBuy\n            );\n\n        emit CoinsBought(\n            coinAddress,\n            msg.sender,\n            cost,\n            fee,\n            amountToBuy,\n            ethReserve,\n            coinReserve\n        );\n\n        monitorMarketCapAndGraduateCoin(coinAddress, coinReserve);\n    }\n\n    function sellCoins(\n        address coinAddress,\n        uint256 amountToSell,\n        uint256 minEthGained\n    ) public {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        (\n            uint256 ethReturn,\n            uint256 fee,\n            uint256 ethReserve,\n            uint256 coinReserve\n        ) = PuushdotFundsV101(funds).sellTokens(\n                msg.sender,\n                amountToSell,\n                minEthGained\n            );\n\n        emit CoinsSold(\n            coinAddress,\n            msg.sender,\n            amountToSell,\n            fee,\n            ethReturn,\n            ethReserve,\n            coinReserve\n        );\n    }\n\n    function monitorMarketCapAndGraduateCoin(\n        address coinAddress,\n        uint256 coinReserve\n    ) internal {\n        if (coinReserve > coinGraduationThreshold) return; // Coin not ready to graduate\n\n        PuushdotFundsV101 funds = PuushdotFundsV101(fundsMap[coinAddress]);\n\n        // Take all liquidity from the PumpPair\n        (uint256 coinsRetrieved, uint256 ethRetrieved) = PuushdotFundsV101(\n            funds\n        ).retrieveFunds();\n\n        emit FundsRetrieved(\n            coinAddress,\n            fundsMap[coinAddress],\n            coinsRetrieved,\n            ethRetrieved\n        );\n\n        if (coinsRetrieved > 0 && ethRetrieved > 0) {\n            // Calculate fees\n            // Take 5% of eth and 0.5% coin from the funds\n            uint256 coinPlatformFee = coinsRetrieved / 200;\n            uint256 ethPlatformFee = ethRetrieved / 20;\n\n            uint256 amountCoinsToGraduate = coinsRetrieved - coinPlatformFee;\n            uint256 amountEthToGraduate = ethRetrieved - ethPlatformFee;\n\n            // Send platform fees to fee wallet\n            require(\n                IERC20(coinAddress).transfer(feeWallet, coinPlatformFee),\n                \"Coin transfer failed\"\n            );\n            (bool success, ) = feeWallet.call{value: ethPlatformFee}(\"\");\n            require(success, \"ETH transfer failed\");\n\n            // Add new liquidity on graduate platform\n            graduateAndBurn(\n                coinAddress,\n                amountCoinsToGraduate,\n                amountEthToGraduate\n            );\n        }\n    }\n\n    function graduateAndBurn(\n        address coinAddress,\n        uint256 amountCoin,\n        uint256 amountETH\n    ) internal {\n        IFactory graduateFactory = IFactory(graduateRouter.factory());\n        IERC20(coinAddress).approve(address(graduateRouter), amountCoin);\n\n        graduateRouter.addLiquidityETH{value: amountETH}(\n            coinAddress,\n            amountCoin,\n            0, // Slippage is unavoidable\n            0, // Slippage is unavoidable\n            address(this),\n            block.timestamp\n        );\n\n        address pair = graduateFactory.getPair(\n            coinAddress,\n            graduateRouter.WETH()\n        );\n\n        if (pair == address(0)) {\n            revert(\"Pair not created\");\n        }\n        uint256 pairBalance = IERC20(pair).balanceOf(address(this));\n        // Burn liquidity tokens\n        IERC20(pair).transfer(deadAddress, pairBalance);\n\n        emit GraduatedAndBurned(\n            coinAddress,\n            fundsMap[coinAddress],\n            pair,\n            amountCoin,\n            amountETH,\n            pairBalance\n        );\n    }\n\n    // To receive Eth from funds contract\n    receive() external payable {}\n}\n\ninterface IFactory {\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair);\n}\n\ninterface IRouter01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint amountToken, uint amountETH, uint liquidity);\n}\n"
    },
    "contracts/Puushdot/V101/PuushdotLiquidityV101.sol": {
      "content": "// FILE: PuushdotLiquidityV101.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IFactory {\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n}\n\ninterface IRouter01 {\n    function factory() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint amountToken, uint amountETH, uint liquidity);\n}\n\ncontract PuushdotLiquidityV101 is IFactory, IRouter01, Ownable, ERC20 {\n    address private _factory = address(this);\n    address private _WETH;\n    address public deadAddress = 0x000000000000000000000000000000000000dEaD;\n\n    mapping(address => bool) public isAdmin;\n    mapping(address => string) public coinTexts;\n\n    mapping(address => uint256) public coinRouterId;\n    address public vvsRouter;\n    address public ebRouter;\n    address public extraRakeReceiver;\n    uint256 public extraRake = 2_000_000 ether; // extra rake on top of the 0.1% from initial Puushdotfun contract\n\n    address public constant MANUAL_ROUTER = address(0);\n\n    constructor()\n        Ownable(msg.sender)\n        ERC20(\"PuushdotLiquidity\", \"PUUSHDOTLP\")\n    {}\n\n    // Modifiers\n\n    modifier onlyAdmin() {\n        require(isAdmin[msg.sender], \"Only admin can call this function\");\n        _;\n    }\n\n    // onlyOwner functions\n\n    function addAdmin(address admin) external onlyOwner {\n        require(!isAdmin[admin], \"Already an admin\");\n        isAdmin[admin] = true;\n    }\n\n    function removeAdmin(address admin) external onlyOwner {\n        require(isAdmin[admin], \"Not an admin\");\n        isAdmin[admin] = false;\n    }\n\n    function setVVSRouter(address _vvsRouter) external onlyOwner {\n        vvsRouter = _vvsRouter;\n    }\n\n    function setEBRouter(address _ebRouter) external onlyOwner {\n        ebRouter = _ebRouter;\n    }\n\n    function setExtraRakeReceiver(\n        address _extraRakeReceiver\n    ) external onlyOwner {\n        extraRakeReceiver = _extraRakeReceiver;\n    }\n\n    function setExtraRake(uint256 _rake) external onlyOwner {\n        require(_rake >= 1_000_000 ether, \"Must be greater than 1 million\");\n        require(_rake <= 10_000_000 ether, \"Must be less than 10 million\");\n        extraRake = _rake;\n    }\n\n    // onlyAdmin functions\n\n    function withdrawERC20Liquidity(address tokenAddress) external onlyAdmin {\n        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\n        require(balance > 0, \"No ERC20 tokens to withdraw\");\n        bool success = IERC20(tokenAddress).transfer(msg.sender, balance);\n        require(success, \"ERC20 transfer failed\");\n    }\n\n    function withdrawETHLiquidity()\n        external\n        onlyAdmin\n        returns (uint256 balance)\n    {\n        balance = address(this).balance;\n        require(balance > 0, \"No ETH to withdraw\");\n        (bool success, ) = payable(msg.sender).call{value: balance}(\"\");\n        require(success, \"ETH transfer failed\");\n    }\n\n    function setCoinGraduationRouter(\n        address coinAddress,\n        uint256 _routerID\n    ) external onlyAdmin {\n        if (_routerID == 0) {\n            // VVS\n            require(vvsRouter != address(0), \"VVS Router not set\");\n            coinRouterId[coinAddress] = 0;\n        } else if (_routerID == 1) {\n            // EB\n            require(ebRouter != address(0), \"EB Router not set\");\n            coinRouterId[coinAddress] = 1;\n        } else if (_routerID == 2) {\n            // Manual graduation\n            coinRouterId[coinAddress] = 2;\n        } else {\n            revert(\"Invalid router ID\");\n        }\n    }\n\n    function setCoinText(\n        address coinAddress,\n        string memory text\n    ) external onlyAdmin {\n        require(bytes(text).length > 0, \"Text must not be empty\");\n        require(\n            bytes(text).length <= 200,\n            \"Text must be less than 200 characters\"\n        );\n        coinTexts[coinAddress] = text;\n    }\n\n    function getCoinGraduationRouter(\n        address coinAddress\n    ) public view returns (address) {\n        if (coinRouterId[coinAddress] == 0) {\n            return vvsRouter;\n        } else if (coinRouterId[coinAddress] == 1) {\n            return ebRouter;\n        } else {\n            return MANUAL_ROUTER;\n        }\n    }\n\n    // Graduation functions\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        override\n        returns (uint amountToken, uint amountETH, uint liquidity)\n    {\n        require(extraRakeReceiver != address(0), \"Extra rake receiver not set\");\n\n        // MUST HAVE FOR FUNCTION TO WORK WITH PUUSHDOTFUN CONTRACT ===========\n        // Take all eth and coins from msg.sender and transfer to this contract\n        IERC20(token).transferFrom(\n            msg.sender,\n            address(this),\n            amountTokenDesired\n        );\n        // Mint 1 LP token to msg.sender\n        _mint(msg.sender, 1);\n\n        // NEW FUNCTIONALITY ==================================================\n        if (getCoinGraduationRouter(token) == MANUAL_ROUTER) {\n            // If manual graduation\n            return (amountTokenDesired, msg.value, 1);\n        }\n\n        // Keep extra rake in this contract\n        uint amountTokenDesiredMinusRakeRemoved = amountTokenDesired -\n            extraRake;\n\n        // Init router and factory\n        IRouter01 graduateRouter = IRouter01(getCoinGraduationRouter(token));\n        IFactory graduateFactory = IFactory(graduateRouter.factory());\n        // Check if pair already exists, do same as manual graduation if exists\n        address initialPairCheck = graduateFactory.getPair(\n            token,\n            graduateRouter.WETH()\n        );\n        if (initialPairCheck != address(0)) {\n            // If pair already exists\n            return (amountTokenDesired, msg.value, 1);\n        }\n\n        // Approve token to router\n        IERC20(token).approve(address(graduateRouter), amountTokenDesired);\n\n        // Add liquidity to router\n        (amountToken, amountETH, liquidity) = graduateRouter.addLiquidityETH{\n            value: msg.value\n        }(\n            token,\n            amountTokenDesiredMinusRakeRemoved,\n            0,\n            0,\n            address(this),\n            deadline\n        );\n\n        require(\n            amountToken == amountTokenDesiredMinusRakeRemoved,\n            \"Amount token not equal to desired amount\"\n        );\n        require(\n            amountETH == msg.value,\n            \"Amount ETH not equal to desired amount\"\n        );\n\n        // get pair address and burn balance\n        address pair = graduateFactory.getPair(token, graduateRouter.WETH());\n        if (pair == address(0)) {\n            revert(\"Pair not created\");\n        }\n        uint256 pairBalance = IERC20(pair).balanceOf(address(this));\n        require(\n            pairBalance == liquidity,\n            \"Pair balance not equal to liquidity\"\n        );\n        IERC20(pair).transfer(deadAddress, pairBalance);\n\n        // Transfer extra rake to extraRakeReceiver\n        IERC20(token).transfer(extraRakeReceiver, extraRake);\n    }\n\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair) {\n        return address(this);\n    }\n\n    function factory() external view returns (address) {\n        return _factory;\n    }\n\n    function WETH() external view returns (address) {\n        return _WETH;\n    }\n}\n"
    },
    "contracts/Puushdot/V102/PuushdotCoinV102.sol": {
      "content": "// FILE: PuushdotCoinV102.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PuushdotCoinV102 is ERC20, Ownable {\n    /**\n     * @dev Constructor that gives msg.sender all of existing tokens.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        address owner\n    ) ERC20(name, symbol) Ownable(owner) {\n        _mint(msg.sender, 1000000000000000000000000000); // 1 Billion tokens\n    }\n}\n"
    },
    "contracts/Puushdot/V102/PuushdotFundsV102.sol": {
      "content": "// FILE: PuushdotFundsV102.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\"; // Importing the Math library from OpenZeppelin\n\ncontract PuushdotFundsV102 {\n    using Math for uint256; // Using the Math library for uint256\n\n    address public puushDotFun;\n    address public feeWallet;\n\n    uint256 public ethReserve;\n    uint256 public coinReserve;\n    uint256 public initialCoinReserve;\n    uint256 public coinsSold = 0;\n\n    uint256 public constant SUPPLY_FOR_SALE = 650_000_000 * 10 ** 18;\n    uint256 public constant START_PRICE = 22_727_272_727_272;\n    uint256 public constant END_PRICE = 227_272_727_272_727;\n\n    bool public isGraduated = false;\n\n    IERC20 public coin;\n\n    constructor(\n        address _puushDotFun,\n        address _feeWallet,\n        address _coinAddress\n    ) {\n        puushDotFun = _puushDotFun;\n        feeWallet = _feeWallet;\n        coin = IERC20(_coinAddress);\n    }\n\n    modifier onlyFun() {\n        require(\n            msg.sender == puushDotFun,\n            \"Only the factory can call this function\"\n        );\n        _;\n    }\n\n    function addInitialFunds(uint256 amountCoinDesired) external onlyFun {\n        require(coin.balanceOf(address(this)) == 0, \"Funds already added\");\n        coinReserve = amountCoinDesired;\n        initialCoinReserve = amountCoinDesired;\n        coin.transferFrom(msg.sender, address(this), amountCoinDesired);\n    }\n\n    function retrieveFunds() external onlyFun returns (uint256, uint256) {\n        isGraduated = true;\n\n        uint256 coinToTransfer = coinReserve;\n        uint256 ethToTransfer = ethReserve;\n\n        uint256 coinBalance = coin.balanceOf(address(this));\n        uint256 ethBalance = address(this).balance;\n\n        if (coinBalance < coinReserve) {\n            coinToTransfer = coinBalance;\n        }\n\n        if (ethBalance > ethReserve) {\n            ethToTransfer = ethBalance;\n        }\n\n        coinReserve = 0;\n        ethReserve = 0;\n\n        // Transfer coins first to reduce potential reentrancy issues\n        if (coinToTransfer > 0) {\n            require(\n                coin.transfer(puushDotFun, coinToTransfer),\n                \"Coin transfer failed\"\n            );\n        }\n\n        // Transfer ETH\n        if (ethToTransfer > 0) {\n            (bool success, ) = puushDotFun.call{value: ethToTransfer}(\"\");\n            require(success, \"ETH transfer failed\");\n        }\n\n        return (coinToTransfer, ethToTransfer);\n    }\n\n    function getFunds() public view returns (uint256, uint256) {\n        return (coinReserve, ethReserve);\n    }\n\n    function buyTokens(\n        address user,\n        uint256 minAmountToBuy\n    )\n        public\n        payable\n        onlyFun\n        returns (uint256, uint256, uint256, uint256, uint256)\n    {\n        require(msg.value > 0, \"No ETH sent\");\n        require(!isGraduated, \"Funds are no longer for sale\");\n        if (minAmountToBuy + coinsSold > SUPPLY_FOR_SALE) {\n            minAmountToBuy = SUPPLY_FOR_SALE - coinsSold;\n        }\n\n        uint256 ethSent = msg.value;\n        uint256 amountToBuy = getAmountToBuy(coinsSold, ethSent);\n\n        require(\n            amountToBuy >= minAmountToBuy,\n            \"Slippage: Tokens received less than minimum required\"\n        );\n        require(\n            SUPPLY_FOR_SALE >= amountToBuy + coinsSold,\n            \"Exceeds supplied amount\"\n        );\n\n        (uint256 totalCostWithFee, uint256 cost, uint256 fee) = getCost(\n            coinsSold,\n            amountToBuy\n        );\n        require(totalCostWithFee <= ethSent, \"Insufficient ETH sent\");\n\n        ethReserve += cost;\n        coinReserve -= amountToBuy;\n        coinsSold += amountToBuy;\n\n        require(coin.transfer(user, amountToBuy), \"Token transfer failed\");\n\n        // Transfer the fee to the fee wallet\n        (bool feeSent, ) = feeWallet.call{value: fee}(\"\");\n        require(feeSent, \"Fee transfer failed\");\n\n        // Refund excess ETH\n        if (ethSent > totalCostWithFee) {\n            uint256 excess = ethSent - totalCostWithFee;\n            (bool refundSent, ) = user.call{value: excess}(\"\");\n            require(refundSent, \"Refund failed\");\n        }\n\n        return (amountToBuy, cost, fee, ethReserve, coinReserve);\n    }\n\n    function sellTokens(\n        address user,\n        uint256 amountToSell,\n        uint256 minEthGained\n    ) public onlyFun returns (uint256, uint256, uint256, uint256) {\n        require(amountToSell > 0, \"Amount to sell must be greater than 0\");\n        require(coinsSold >= amountToSell, \"Insufficient coins sold\");\n        require(ethReserve > 0, \"ETH reserve is empty\");\n        require(!isGraduated, \"Funds are no longer for sale\");\n\n        (uint256 ethReturnWithFee, uint256 ethReturn, uint256 fee) = getReturn(\n            coinsSold,\n            amountToSell\n        );\n        require(\n            coinReserve + amountToSell <= initialCoinReserve,\n            \"Exceeds supply limit\"\n        );\n        require(\n            ethReturn >= minEthGained,\n            \"Slippage: ETH gained is less than minimum required\"\n        );\n        require(ethReturnWithFee <= ethReserve, \"Insufficient ETH in reserve\");\n\n        ethReserve -= ethReturnWithFee;\n        coinReserve += amountToSell;\n        coinsSold -= amountToSell;\n\n        require(\n            coin.transferFrom(user, address(this), amountToSell),\n            \"Token transfer failed\"\n        );\n\n        (bool ethSent, ) = user.call{value: ethReturn}(\"\");\n        require(ethSent, \"ETH transfer failed\");\n\n        // Transfer the fee to the fee wallet\n        (bool feeSent, ) = feeWallet.call{value: fee}(\"\");\n        require(feeSent, \"Fee transfer failed\");\n\n        return (ethReturn, fee, ethReserve, coinReserve);\n    }\n\n    // Function to calculate the amount of tokens that can be bought with the given ETH\n    function getAmountToBuy(\n        uint256 currentSupplySold,\n        uint256 ethSent\n    ) public pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = SUPPLY_FOR_SALE - currentSupplySold;\n        uint256 mid;\n        uint256 cost;\n\n        while (low < high) {\n            mid = (low + high + 1) / 2;\n            (cost, , ) = getCost(currentSupplySold, mid);\n\n            if (cost <= ethSent) {\n                low = mid;\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        return roundDownToNearest(low, 100000);\n    }\n\n    // Function to round down to the nearest 100k wei\n    function roundDownToNearest(\n        uint256 value,\n        uint256 precision\n    ) internal pure returns (uint256) {\n        return (value / precision) * precision;\n    }\n\n    function getCost(\n        uint256 currentSupplySold,\n        uint256 amountToBuy\n    )\n        public\n        pure\n        returns (uint256 totalCostWithFee, uint256 cost, uint256 fee)\n    {\n        uint256 start = currentSupplySold;\n        uint256 end = currentSupplySold + amountToBuy;\n\n        uint256 startPricePerToken = interpolatePrice(start);\n        uint256 endPricePerToken = interpolatePrice(end);\n\n        uint256 avgPricePerToken = Math.mulDiv(\n            (startPricePerToken + endPricePerToken),\n            1e18,\n            2 * 1e18\n        );\n\n        cost = Math.mulDiv(avgPricePerToken, amountToBuy, 1e18); // Adjust for wei\n        fee = Math.mulDiv(cost, 1, 100); // 1% fee\n        totalCostWithFee = cost + fee;\n\n        return (totalCostWithFee, cost, fee);\n    }\n\n    function getReturn(\n        uint256 currentSupplySold,\n        uint256 amountToSell\n    )\n        public\n        view\n        returns (uint256 totalReturnWithFee, uint256 ethReturn, uint256 fee)\n    {\n        // Can only sell coins divisible by 100k\n        require(\n            amountToSell % 100000 == 0,\n            \"Amount to sell must be divisible by 100k\"\n        );\n\n        uint256 start = currentSupplySold;\n        uint256 end = currentSupplySold - amountToSell;\n\n        uint256 startPricePerToken = interpolatePrice(start);\n        uint256 endPricePerToken = interpolatePrice(end);\n\n        uint256 avgPricePerToken = Math.mulDiv(\n            (startPricePerToken + endPricePerToken),\n            1e18,\n            2 * 1e18\n        );\n\n        uint256 ethGrossReturn = Math.mulDiv(\n            avgPricePerToken,\n            amountToSell,\n            1e18\n        ); // Adjust for wei\n\n        fee = Math.mulDiv(ethGrossReturn, 1, 100); // 1% fee\n        ethReturn = ethGrossReturn - fee; // Amount user gets after fee\n        totalReturnWithFee = ethGrossReturn; // Total amount including fee\n\n        // Check if selling the remaining coins\n        if (amountToSell + coinReserve == initialCoinReserve) {\n            totalReturnWithFee = ethReserve;\n            fee = Math.mulDiv(totalReturnWithFee, 1, 100); // 1% fee\n            ethReturn = totalReturnWithFee - fee;\n        }\n\n        return (totalReturnWithFee, ethReturn, fee);\n    }\n\n    function interpolatePrice(uint256 supply) internal pure returns (uint256) {\n        uint256 price = START_PRICE +\n            Math.mulDiv((END_PRICE - START_PRICE), supply, SUPPLY_FOR_SALE);\n        return price;\n    }\n}\n"
    },
    "contracts/Puushdot/V102/PuushdotFunV102.sol": {
      "content": "// FILE: PuushdotFunV102.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./PuushdotCoinV102.sol\";\nimport \"./PuushdotFundsV102.sol\";\n\ncontract PuushdotFunV102 is Ownable {\n    using Math for uint256;\n\n    uint256 public coinCreationEthCost = 50 ether;\n    uint256 public coinGraduationThreshold = 350000000 ether;\n\n    uint256 public graduationEthFee = 5000 ether;\n    uint256 public graduationCoinFee = 1000000 ether;\n\n    address payable public feeWallet;\n    address public deadAddress = 0x000000000000000000000000000000000000dEaD;\n\n    mapping(address => address) public fundsMap; // Coin => Funds\n\n    IRouter01 public graduateRouter;\n\n    constructor(address payable _feeWallet) Ownable(msg.sender) {\n        feeWallet = _feeWallet;\n    }\n\n    event CoinCreated(\n        address coinAddress,\n        address fundsAddress,\n        address coinCreator,\n        uint256 coinToFunds,\n        string metaURI\n    );\n\n    event CoinsBought(\n        address coinAddress,\n        address userAddress,\n        uint256 ethToFund,\n        uint256 ethToFee,\n        uint256 coinsToUser,\n        uint256 newEthReserve,\n        uint256 newCoinReserve\n    );\n\n    event CoinsSold(\n        address coinAddress,\n        address userAddress,\n        uint256 coinsToFund,\n        uint256 ethToFee,\n        uint256 ethToUser,\n        uint256 newEthReserve,\n        uint256 newCoinReserve\n    );\n\n    event GraduatedAndBurned(\n        address coinAddress,\n        address fundsAddress,\n        address graduatePairAddress,\n        uint256 amountCoinsGraduated,\n        uint256 amountEthGraduated,\n        uint256 amountPairBurned\n    );\n\n    event FundsRetrieved(\n        address coinAddress,\n        address fundsAddress,\n        uint256 coinRetrieved,\n        uint256 ethRetrieved\n    );\n\n    // Emergency withdraw function for ETH\n    function emergencyWithdraw() public onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    // Emergency withdraw function for ERC20 tokens\n    function emergencyWithdrawERC20(address token) public onlyOwner {\n        IERC20(token).transfer(\n            msg.sender,\n            IERC20(token).balanceOf(address(this))\n        );\n    }\n\n    function emergencyRetrieveFunds(address coinAddress) public onlyOwner {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        PuushdotFundsV102(funds).retrieveFunds();\n\n        // Send funds to msg.sender\n        IERC20(coinAddress).transfer(\n            msg.sender,\n            IERC20(coinAddress).balanceOf(address(this))\n        );\n\n        // Send ETH to msg.sender\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function setGraduationEthFee(uint256 _graduationEthFee) public onlyOwner {\n        require(_graduationEthFee > 0, \"Fee must be greater than 0\");\n        graduationEthFee = _graduationEthFee;\n    }\n\n    function setGraduationCoinFee(uint256 _graduationCoinFee) public onlyOwner {\n        require(_graduationCoinFee > 0, \"Fee must be greater than 0\");\n        graduationCoinFee = _graduationCoinFee;\n    }\n\n    function setCoinCreationEthCost(\n        uint256 _coinCreationEthCost\n    ) public onlyOwner {\n        require(_coinCreationEthCost > 0, \"Cost must be greater than 0\");\n        coinCreationEthCost = _coinCreationEthCost;\n    }\n\n    function setFeeWallet(address payable _feeWallet) public onlyOwner {\n        require(_feeWallet != address(0), \"Invalid fee wallet address\");\n        feeWallet = _feeWallet;\n    }\n\n    function setGraduateRouter(address _router) public onlyOwner {\n        require(_router != address(0), \"Invalid router address\");\n        graduateRouter = IRouter01(_router);\n    }\n\n    function createCoin(\n        string memory name,\n        string memory symbol,\n        string memory metaURI,\n        uint256 minCoinsToBuy\n    ) public payable {\n        require(msg.value >= coinCreationEthCost, \"Not enough Eth sent\");\n        require(minCoinsToBuy <= 400_000_000 ether, \"Max buy limit reached\");\n\n        // Require checks for name and symbol length\n        require(\n            bytes(name).length > 0 && bytes(name).length <= 32,\n            \"Name must be between 1 and 32 characters\"\n        );\n        require(\n            bytes(symbol).length > 0 && bytes(symbol).length <= 10,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n        require(\n            bytes(metaURI).length > 0 && bytes(metaURI).length <= 200,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n\n        // Transfer the fee to the PumpWallet\n        feeWallet.transfer(coinCreationEthCost);\n\n        PuushdotCoinV102 coin = new PuushdotCoinV102(\n            name,\n            symbol,\n            address(this)\n        );\n\n        // Transfer ownership to zero address\n        coin.renounceOwnership();\n\n        uint256 coinToFunds = coin.totalSupply();\n\n        // Create the PuushdotFunds contract and add liquidity\n        PuushdotFundsV102 funds = new PuushdotFundsV102(\n            address(this),\n            feeWallet,\n            address(coin)\n        );\n        fundsMap[address(coin)] = address(funds);\n\n        // Give funds contract allowance to transfer coins\n        coin.approve(address(funds), coinToFunds);\n\n        // Use the addInitialFunds function to transfer coins to the funds contract\n        funds.addInitialFunds(coinToFunds);\n\n        emit CoinCreated(\n            address(coin),\n            address(funds),\n            msg.sender,\n            coinToFunds,\n            metaURI\n        );\n\n        if (minCoinsToBuy > 0) {\n            require(\n                funds.SUPPLY_FOR_SALE() >= minCoinsToBuy + funds.coinsSold(),\n                \"Exceeds supplied amount\"\n            );\n            (uint256 totalCostWithFee, , ) = funds.getCost(\n                funds.coinsSold(),\n                minCoinsToBuy\n            );\n\n            require(\n                msg.value - coinCreationEthCost >= totalCostWithFee,\n                \"Wrong amount of Eth sent\"\n            );\n\n            (\n                uint256 amountToBuy,\n                uint256 cost,\n                uint256 fee,\n                uint256 ethReserve,\n                uint256 coinReserve\n            ) = funds.buyTokens{value: msg.value - coinCreationEthCost}(\n                    msg.sender,\n                    minCoinsToBuy\n                );\n\n            emit CoinsBought(\n                address(coin),\n                msg.sender,\n                cost,\n                fee,\n                amountToBuy,\n                ethReserve,\n                coinReserve\n            );\n        }\n    }\n\n    function buyCoins(\n        address coinAddress,\n        uint256 minAmountToBuy\n    ) public payable {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        (\n            uint256 amountToBuy,\n            uint256 cost,\n            uint256 fee,\n            uint256 ethReserve,\n            uint256 coinReserve\n        ) = PuushdotFundsV102(funds).buyTokens{value: msg.value}(\n                msg.sender,\n                minAmountToBuy\n            );\n\n        emit CoinsBought(\n            coinAddress,\n            msg.sender,\n            cost,\n            fee,\n            amountToBuy,\n            ethReserve,\n            coinReserve\n        );\n\n        monitorMarketCapAndGraduateCoin(coinAddress, coinReserve);\n    }\n\n    function sellCoins(\n        address coinAddress,\n        uint256 amountToSell,\n        uint256 minEthGained\n    ) public {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        (\n            uint256 ethReturn,\n            uint256 fee,\n            uint256 ethReserve,\n            uint256 coinReserve\n        ) = PuushdotFundsV102(funds).sellTokens(\n                msg.sender,\n                amountToSell,\n                minEthGained\n            );\n\n        emit CoinsSold(\n            coinAddress,\n            msg.sender,\n            amountToSell,\n            fee,\n            ethReturn,\n            ethReserve,\n            coinReserve\n        );\n    }\n\n    function monitorMarketCapAndGraduateCoin(\n        address coinAddress,\n        uint256 coinReserve\n    ) internal {\n        if (coinReserve > coinGraduationThreshold) return; // Coin not ready to graduate\n\n        PuushdotFundsV102 funds = PuushdotFundsV102(fundsMap[coinAddress]);\n\n        // Take all liquidity from the PumpPair\n        (uint256 coinsRetrieved, uint256 ethRetrieved) = PuushdotFundsV102(\n            funds\n        ).retrieveFunds();\n\n        emit FundsRetrieved(\n            coinAddress,\n            fundsMap[coinAddress],\n            coinsRetrieved,\n            ethRetrieved\n        );\n\n        if (coinsRetrieved > 0 && ethRetrieved > 0) {\n            // Calculate fees\n            // Take graduationEthFee and graduationCoinFee\n\n            uint256 amountCoinsToGraduate = coinsRetrieved - graduationCoinFee;\n            uint256 amountEthToGraduate = ethRetrieved - graduationEthFee;\n\n            // Send platform fees to fee wallet\n            require(\n                IERC20(coinAddress).transfer(feeWallet, graduationCoinFee),\n                \"Coin transfer failed\"\n            );\n            (bool success, ) = feeWallet.call{value: graduationEthFee}(\"\");\n            require(success, \"ETH transfer failed\");\n\n            // Add new liquidity on graduate platform\n            graduateAndBurn(\n                coinAddress,\n                amountCoinsToGraduate,\n                amountEthToGraduate\n            );\n        }\n    }\n\n    function graduateAndBurn(\n        address coinAddress,\n        uint256 amountCoin,\n        uint256 amountETH\n    ) internal {\n        IFactory graduateFactory = IFactory(graduateRouter.factory());\n        IERC20(coinAddress).approve(address(graduateRouter), amountCoin);\n\n        graduateRouter.addLiquidityETH{value: amountETH}(\n            coinAddress,\n            amountCoin,\n            0, // Slippage is unavoidable\n            0, // Slippage is unavoidable\n            address(this),\n            block.timestamp\n        );\n\n        address pair = graduateFactory.getPair(\n            coinAddress,\n            graduateRouter.WETH()\n        );\n\n        if (pair == address(0)) {\n            revert(\"Pair not created\");\n        }\n        uint256 pairBalance = IERC20(pair).balanceOf(address(this));\n        // Burn liquidity tokens\n        IERC20(pair).transfer(deadAddress, pairBalance);\n\n        emit GraduatedAndBurned(\n            coinAddress,\n            fundsMap[coinAddress],\n            pair,\n            amountCoin,\n            amountETH,\n            pairBalance\n        );\n    }\n\n    // To receive Eth from funds contract\n    receive() external payable {}\n}\n\ninterface IFactory {\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair);\n}\n\ninterface IRouter01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint amountToken, uint amountETH, uint liquidity);\n}\n"
    },
    "contracts/Puushdot/V103/PuushdotFunV103.sol": {
      "content": "// FILE: PuushdotFunV103.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../V102/PuushdotCoinV102.sol\";\nimport \"../V102/PuushdotFundsV102.sol\";\n\ncontract PuushdotFunV103 is Ownable {\n    using Math for uint256;\n\n    uint256 public coinCreationEthCost = 50 ether;\n    uint256 public coinGraduationThreshold = 350000000 ether;\n\n    uint256 public graduationEthFee = 5000 ether;\n    uint256 public graduationCoinFee = 1000000 ether;\n\n    address payable public feeWallet;\n    address public deadAddress = 0x000000000000000000000000000000000000dEaD;\n\n    mapping(address => address) public fundsMap; // Coin => Funds\n\n    mapping(address => address) public coinCreators; // Coin => Creator\n\n    mapping(address => uint256) public coinCreateTimestamp; // Coin => block timestamp\n\n    mapping(address => uint256) public freeCoinCreations; // User => amount\n\n    IRouter01 public graduateRouter;\n\n    constructor(address payable _feeWallet) Ownable(msg.sender) {\n        feeWallet = _feeWallet;\n    }\n\n    event CoinCreated(\n        address coinAddress,\n        address fundsAddress,\n        address coinCreator,\n        uint256 coinToFunds,\n        string metaURI\n    );\n\n    event CoinsBought(\n        address coinAddress,\n        address userAddress,\n        uint256 ethToFund,\n        uint256 ethToFee,\n        uint256 coinsToUser,\n        uint256 newEthReserve,\n        uint256 newCoinReserve\n    );\n\n    event CoinsSold(\n        address coinAddress,\n        address userAddress,\n        uint256 coinsToFund,\n        uint256 ethToFee,\n        uint256 ethToUser,\n        uint256 newEthReserve,\n        uint256 newCoinReserve\n    );\n\n    event GraduatedAndBurned(\n        address coinAddress,\n        address fundsAddress,\n        address graduatePairAddress,\n        uint256 amountCoinsGraduated,\n        uint256 amountEthGraduated,\n        uint256 amountPairBurned\n    );\n\n    event FundsRetrieved(\n        address coinAddress,\n        address fundsAddress,\n        uint256 coinRetrieved,\n        uint256 ethRetrieved\n    );\n\n    // Emergency withdraw function for ETH\n    function emergencyWithdraw() public onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    // Emergency withdraw function for ERC20 tokens\n    function emergencyWithdrawERC20(address token) public onlyOwner {\n        IERC20(token).transfer(\n            msg.sender,\n            IERC20(token).balanceOf(address(this))\n        );\n    }\n\n    function emergencyRetrieveFunds(address coinAddress) public onlyOwner {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        PuushdotFundsV102(funds).retrieveFunds();\n\n        // Send funds to msg.sender\n        IERC20(coinAddress).transfer(\n            msg.sender,\n            IERC20(coinAddress).balanceOf(address(this))\n        );\n\n        // Send ETH to msg.sender\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function setGraduationEthFee(uint256 _graduationEthFee) public onlyOwner {\n        require(_graduationEthFee > 0, \"Fee must be greater than 0\");\n        graduationEthFee = _graduationEthFee;\n    }\n\n    function setGraduationCoinFee(uint256 _graduationCoinFee) public onlyOwner {\n        require(_graduationCoinFee > 0, \"Fee must be greater than 0\");\n        graduationCoinFee = _graduationCoinFee;\n    }\n\n    function setCoinCreationEthCost(\n        uint256 _coinCreationEthCost\n    ) public onlyOwner {\n        require(_coinCreationEthCost > 0, \"Cost must be greater than 0\");\n        coinCreationEthCost = _coinCreationEthCost;\n    }\n\n    function setFeeWallet(address payable _feeWallet) public onlyOwner {\n        require(_feeWallet != address(0), \"Invalid fee wallet address\");\n        feeWallet = _feeWallet;\n    }\n\n    function setGraduateRouter(address _router) public onlyOwner {\n        require(_router != address(0), \"Invalid router address\");\n        graduateRouter = IRouter01(_router);\n    }\n\n    function setFreeCoinCreations(\n        address[] memory user,\n        uint256[] memory amount\n    ) public onlyOwner {\n        require(user.length == amount.length, \"Array length mismatch\");\n\n        for (uint256 i = 0; i < user.length; i++) {\n            // make sure amount cant be more than 10 free coins\n            require(amount[i] <= 10, \"Amount must be less than 10\");\n            freeCoinCreations[user[i]] = amount[i];\n        }\n    }\n\n    function createCoin(\n        string memory name,\n        string memory symbol,\n        string memory metaURI,\n        uint256 minCoinsToBuy\n    ) public payable {\n        require(msg.value >= coinCreationEthCost, \"Not enough Eth sent\");\n        require(minCoinsToBuy <= 400_000_000 ether, \"Max buy limit reached\");\n\n        // Require checks for name and symbol length\n        require(\n            bytes(name).length > 0 && bytes(name).length <= 32,\n            \"Name must be between 1 and 32 characters\"\n        );\n        require(\n            bytes(symbol).length > 0 && bytes(symbol).length <= 10,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n        require(\n            bytes(metaURI).length > 0 && bytes(metaURI).length <= 200,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n\n        // Transfer the fee to the PumpWallet\n        feeWallet.transfer(coinCreationEthCost);\n\n        PuushdotCoinV102 coin = new PuushdotCoinV102(\n            name,\n            symbol,\n            address(this)\n        );\n\n        // Transfer ownership to zero address\n        coin.renounceOwnership();\n\n        uint256 coinToFunds = coin.totalSupply();\n\n        // Create the PuushdotFunds contract and add liquidity\n        PuushdotFundsV102 funds = new PuushdotFundsV102(\n            address(this),\n            feeWallet,\n            address(coin)\n        );\n        fundsMap[address(coin)] = address(funds);\n\n        // Give funds contract allowance to transfer coins\n        coin.approve(address(funds), coinToFunds);\n\n        // Use the addInitialFunds function to transfer coins to the funds contract\n        funds.addInitialFunds(coinToFunds);\n\n        // Update coinCreators and coinCreateTimestamp mapping\n        coinCreators[address(coin)] = msg.sender;\n        coinCreateTimestamp[address(coin)] = block.timestamp;\n\n        emit CoinCreated(\n            address(coin),\n            address(funds),\n            msg.sender,\n            coinToFunds,\n            metaURI\n        );\n\n        if (minCoinsToBuy > 0) {\n            require(\n                funds.SUPPLY_FOR_SALE() >= minCoinsToBuy + funds.coinsSold(),\n                \"Exceeds supplied amount\"\n            );\n            (uint256 totalCostWithFee, , ) = funds.getCost(\n                funds.coinsSold(),\n                minCoinsToBuy\n            );\n\n            require(\n                msg.value - coinCreationEthCost >= totalCostWithFee,\n                \"Wrong amount of Eth sent\"\n            );\n\n            (\n                uint256 amountToBuy,\n                uint256 cost,\n                uint256 fee,\n                uint256 ethReserve,\n                uint256 coinReserve\n            ) = funds.buyTokens{value: msg.value - coinCreationEthCost}(\n                    msg.sender,\n                    minCoinsToBuy\n                );\n\n            emit CoinsBought(\n                address(coin),\n                msg.sender,\n                cost,\n                fee,\n                amountToBuy,\n                ethReserve,\n                coinReserve\n            );\n        }\n    }\n\n    function createCoinForFree(\n        string memory name,\n        string memory symbol,\n        string memory metaURI,\n        uint256 minCoinsToBuy\n    ) public payable {\n        require(\n            freeCoinCreations[msg.sender] > 0,\n            \"User not eligible for free coin creation\"\n        );\n        freeCoinCreations[msg.sender] -= 1;\n\n        require(minCoinsToBuy <= 400_000_000 ether, \"Max buy limit reached\");\n\n        // Require checks for name and symbol length\n        require(\n            bytes(name).length > 0 && bytes(name).length <= 32,\n            \"Name must be between 1 and 32 characters\"\n        );\n        require(\n            bytes(symbol).length > 0 && bytes(symbol).length <= 10,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n        require(\n            bytes(metaURI).length > 0 && bytes(metaURI).length <= 200,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n\n        PuushdotCoinV102 coin = new PuushdotCoinV102(\n            name,\n            symbol,\n            address(this)\n        );\n\n        // Transfer ownership to zero address\n        coin.renounceOwnership();\n\n        uint256 coinToFunds = coin.totalSupply();\n\n        // Create the PuushdotFunds contract and add liquidity\n        PuushdotFundsV102 funds = new PuushdotFundsV102(\n            address(this),\n            feeWallet,\n            address(coin)\n        );\n        fundsMap[address(coin)] = address(funds);\n\n        // Give funds contract allowance to transfer coins\n        coin.approve(address(funds), coinToFunds);\n\n        // Use the addInitialFunds function to transfer coins to the funds contract\n        funds.addInitialFunds(coinToFunds);\n\n        // Update coinCreators and coinCreateTimestamp mapping\n        coinCreators[address(coin)] = msg.sender;\n        coinCreateTimestamp[address(coin)] = block.timestamp;\n\n        emit CoinCreated(\n            address(coin),\n            address(funds),\n            msg.sender,\n            coinToFunds,\n            metaURI\n        );\n\n        if (minCoinsToBuy > 0) {\n            require(\n                funds.SUPPLY_FOR_SALE() >= minCoinsToBuy + funds.coinsSold(),\n                \"Exceeds supplied amount\"\n            );\n            (uint256 totalCostWithFee, , ) = funds.getCost(\n                funds.coinsSold(),\n                minCoinsToBuy\n            );\n\n            require(msg.value >= totalCostWithFee, \"Wrong amount of Eth sent\");\n\n            (\n                uint256 amountToBuy,\n                uint256 cost,\n                uint256 fee,\n                uint256 ethReserve,\n                uint256 coinReserve\n            ) = funds.buyTokens{value: msg.value}(msg.sender, minCoinsToBuy);\n\n            emit CoinsBought(\n                address(coin),\n                msg.sender,\n                cost,\n                fee,\n                amountToBuy,\n                ethReserve,\n                coinReserve\n            );\n        }\n    }\n\n    function buyCoins(\n        address coinAddress,\n        uint256 minAmountToBuy\n    ) public payable {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        (\n            uint256 amountToBuy,\n            uint256 cost,\n            uint256 fee,\n            uint256 ethReserve,\n            uint256 coinReserve\n        ) = PuushdotFundsV102(funds).buyTokens{value: msg.value}(\n                msg.sender,\n                minAmountToBuy\n            );\n\n        emit CoinsBought(\n            coinAddress,\n            msg.sender,\n            cost,\n            fee,\n            amountToBuy,\n            ethReserve,\n            coinReserve\n        );\n\n        monitorMarketCapAndGraduateCoin(coinAddress, coinReserve);\n    }\n\n    function sellCoins(\n        address coinAddress,\n        uint256 amountToSell,\n        uint256 minEthGained\n    ) public {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        (\n            uint256 ethReturn,\n            uint256 fee,\n            uint256 ethReserve,\n            uint256 coinReserve\n        ) = PuushdotFundsV102(funds).sellTokens(\n                msg.sender,\n                amountToSell,\n                minEthGained\n            );\n\n        emit CoinsSold(\n            coinAddress,\n            msg.sender,\n            amountToSell,\n            fee,\n            ethReturn,\n            ethReserve,\n            coinReserve\n        );\n    }\n\n    function monitorMarketCapAndGraduateCoin(\n        address coinAddress,\n        uint256 coinReserve\n    ) internal {\n        if (coinReserve > coinGraduationThreshold) return; // Coin not ready to graduate\n\n        PuushdotFundsV102 funds = PuushdotFundsV102(fundsMap[coinAddress]);\n\n        // Take all liquidity from the PumpPair\n        (uint256 coinsRetrieved, uint256 ethRetrieved) = PuushdotFundsV102(\n            funds\n        ).retrieveFunds();\n\n        emit FundsRetrieved(\n            coinAddress,\n            fundsMap[coinAddress],\n            coinsRetrieved,\n            ethRetrieved\n        );\n\n        if (coinsRetrieved > 0 && ethRetrieved > 0) {\n            // Calculate fees\n            // Take graduationEthFee and graduationCoinFee\n\n            uint256 amountCoinsToGraduate = coinsRetrieved - graduationCoinFee;\n            uint256 amountEthToGraduate = ethRetrieved - graduationEthFee;\n\n            // Send platform fees to fee wallet\n            require(\n                IERC20(coinAddress).transfer(feeWallet, graduationCoinFee),\n                \"Coin transfer failed\"\n            );\n            (bool success, ) = feeWallet.call{value: graduationEthFee}(\"\");\n            require(success, \"ETH transfer failed\");\n\n            // Add new liquidity on graduate platform\n            graduateAndBurn(\n                coinAddress,\n                amountCoinsToGraduate,\n                amountEthToGraduate\n            );\n        }\n    }\n\n    function graduateAndBurn(\n        address coinAddress,\n        uint256 amountCoin,\n        uint256 amountETH\n    ) internal {\n        IFactory graduateFactory = IFactory(graduateRouter.factory());\n        IERC20(coinAddress).approve(address(graduateRouter), amountCoin);\n\n        graduateRouter.addLiquidityETH{value: amountETH}(\n            coinAddress,\n            amountCoin,\n            0, // Slippage is unavoidable\n            0, // Slippage is unavoidable\n            address(this),\n            block.timestamp\n        );\n\n        address pair = graduateFactory.getPair(\n            coinAddress,\n            graduateRouter.WETH()\n        );\n\n        if (pair == address(0)) {\n            revert(\"Pair not created\");\n        }\n        uint256 pairBalance = IERC20(pair).balanceOf(address(this));\n        // Burn liquidity tokens\n        IERC20(pair).transfer(deadAddress, pairBalance);\n\n        emit GraduatedAndBurned(\n            coinAddress,\n            fundsMap[coinAddress],\n            pair,\n            amountCoin,\n            amountETH,\n            pairBalance\n        );\n    }\n\n    // To receive Eth from funds contract\n    receive() external payable {}\n}\n\ninterface IFactory {\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair);\n}\n\ninterface IRouter01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint amountToken, uint amountETH, uint liquidity);\n}\n"
    },
    "contracts/Puushdot/V103/PuushdotLiquidityV103.sol": {
      "content": "// FILE: PuushdotLiquidityV103.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IFactory {\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n}\n\ninterface IRouter01 {\n    function factory() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint amountToken, uint amountETH, uint liquidity);\n}\n\ninterface IPuushdotFunV103 {\n    // Getter function for the coinCreators mapping\n    function coinCreators(address coin) external view returns (address);\n\n    // Getter function for the coinCreateTimestamp mapping\n    function coinCreateTimestamp(address coin) external view returns (uint256);\n}\n\ncontract PuushdotLiquidityV103 is IFactory, IRouter01, Ownable, ERC20 {\n    address private _factory = address(this);\n    address private _WETH;\n    address public deadAddress = 0x000000000000000000000000000000000000dEaD;\n\n    mapping(address => bool) public isAdmin;\n    mapping(address => string) public coinTexts;\n\n    mapping(address => uint256) public coinRouterId;\n    mapping(uint256 => address) public routers; // id => router, the address at id 0 is the default auto router\n\n    address public extraRakeReceiver;\n    uint256 public extraRake = 2_000_000 ether; // extra rake on top of the 0.1% from initial Puushdotfun contract\n\n    address public constant MANUAL_ROUTER = address(0);\n\n    // Creator Control Panel options\n    uint256 public timeLimit = 12 hours;\n    bool public creatorControlsEnabled = false;\n    address public puushdotFunV103 = address(0);\n\n    constructor()\n        Ownable(msg.sender)\n        ERC20(\"PuushdotLiquidity\", \"PUUSHDOTLP\")\n    {}\n\n    // Modifiers\n\n    modifier onlyAdmin() {\n        require(isAdmin[msg.sender], \"Only admin can call this function\");\n        _;\n    }\n\n    // onlyOwner functions\n\n    function addAdmin(address admin) external onlyOwner {\n        require(!isAdmin[admin], \"Already an admin\");\n        isAdmin[admin] = true;\n    }\n\n    function removeAdmin(address admin) external onlyOwner {\n        require(isAdmin[admin], \"Not an admin\");\n        isAdmin[admin] = false;\n    }\n\n    function setRouter(uint256 id, address router) external onlyOwner {\n        routers[id] = router;\n    }\n\n    function setPuushdotFunV103(address _puushdotFunV103) external onlyOwner {\n        puushdotFunV103 = _puushdotFunV103;\n    }\n\n    function setExtraRakeReceiver(\n        address _extraRakeReceiver\n    ) external onlyOwner {\n        extraRakeReceiver = _extraRakeReceiver;\n    }\n\n    function setExtraRake(uint256 _rake) external onlyOwner {\n        require(_rake >= 1_000_000 ether, \"Must be greater than 1 million\");\n        require(_rake <= 10_000_000 ether, \"Must be less than 10 million\");\n        extraRake = _rake;\n    }\n\n    function setCreatorControlsEnabled(bool _enabled) external onlyOwner {\n        creatorControlsEnabled = _enabled;\n    }\n\n    function setTimeLimit(uint256 _timeLimit) external onlyOwner {\n        timeLimit = _timeLimit;\n    }\n\n    // onlyAdmin functions\n\n    function withdrawERC20Liquidity(address tokenAddress) external onlyAdmin {\n        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\n        require(balance > 0, \"No ERC20 tokens to withdraw\");\n        bool success = IERC20(tokenAddress).transfer(msg.sender, balance);\n        require(success, \"ERC20 transfer failed\");\n    }\n\n    function withdrawETHLiquidity()\n        external\n        onlyAdmin\n        returns (uint256 balance)\n    {\n        balance = address(this).balance;\n        require(balance > 0, \"No ETH to withdraw\");\n        (bool success, ) = payable(msg.sender).call{value: balance}(\"\");\n        require(success, \"ETH transfer failed\");\n    }\n\n    function setCoinGraduationRouter(\n        address coinAddress,\n        uint256 id\n    ) external onlyAdmin {\n        coinRouterId[coinAddress] = id;\n    }\n\n    function setCoinText(\n        address coinAddress,\n        string memory text\n    ) external onlyAdmin {\n        require(bytes(text).length > 0, \"Text must not be empty\");\n        require(\n            bytes(text).length <= 200,\n            \"Text must be less than 200 characters\"\n        );\n        coinTexts[coinAddress] = text;\n    }\n\n    function setCoinGraduationRouterAsCoinCreator(\n        address coinAddress,\n        uint256 id\n    ) external {\n        checkCreatorControlAuthorization(coinAddress);\n        coinRouterId[coinAddress] = id;\n    }\n\n    function setCoinTextAsCoinCreator(\n        address coinAddress,\n        string memory text\n    ) external {\n        checkCreatorControlAuthorization(coinAddress);\n        require(bytes(text).length > 0, \"Text must not be empty\");\n        require(\n            bytes(text).length <= 200,\n            \"Text must be less than 200 characters\"\n        );\n        coinTexts[coinAddress] = text;\n    }\n\n    function checkCreatorControlAuthorization(\n        address coinAddress\n    ) internal view {\n        // Check controls enabled, caller is creator, and time limit has not passed\n        require(creatorControlsEnabled, \"Creator controls not enabled\");\n        require(puushdotFunV103 != address(0), \"PuushdotFun contract not set\");\n        IPuushdotFunV103 puushdotFun = IPuushdotFunV103(puushdotFunV103);\n        require(\n            puushdotFun.coinCreators(coinAddress) == msg.sender,\n            \"Not coin creator\"\n        );\n        require(\n            block.timestamp - puushdotFun.coinCreateTimestamp(coinAddress) <=\n                timeLimit,\n            \"Time limit passed\"\n        );\n    }\n\n    // Graduation functions\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        override\n        returns (uint amountToken, uint amountETH, uint liquidity)\n    {\n        require(extraRakeReceiver != address(0), \"Extra rake receiver not set\");\n\n        // MUST HAVE FOR FUNCTION TO WORK WITH PUUSHDOTFUN CONTRACT ===========\n        // Take all eth and coins from msg.sender and transfer to this contract\n        IERC20(token).transferFrom(\n            msg.sender,\n            address(this),\n            amountTokenDesired\n        );\n        // Mint 1 LP token to msg.sender\n        _mint(msg.sender, 1);\n\n        // If the router is MANUAL_ROUTER, proceed with manual graduation\n        if (routers[coinRouterId[token]] == MANUAL_ROUTER) {\n            return (amountTokenDesired, msg.value, 1);\n        }\n\n        // Keep extra rake in this contract\n        uint amountTokenDesiredMinusRakeRemoved = amountTokenDesired -\n            extraRake;\n\n        // Init router and factory\n        IRouter01 graduateRouter = IRouter01(routers[coinRouterId[token]]);\n        IFactory graduateFactory = IFactory(graduateRouter.factory());\n        // Check if pair already exists, do same as manual graduation if exists\n        address initialPairCheck = graduateFactory.getPair(\n            token,\n            graduateRouter.WETH()\n        );\n        if (initialPairCheck != address(0)) {\n            // If pair already exists\n            return (amountTokenDesired, msg.value, 1);\n        }\n\n        // Approve token to router\n        IERC20(token).approve(address(graduateRouter), amountTokenDesired);\n\n        // Add liquidity to router\n        (amountToken, amountETH, liquidity) = graduateRouter.addLiquidityETH{\n            value: msg.value\n        }(\n            token,\n            amountTokenDesiredMinusRakeRemoved,\n            0,\n            0,\n            address(this),\n            deadline\n        );\n\n        require(\n            amountToken == amountTokenDesiredMinusRakeRemoved,\n            \"Amount token not equal to desired amount\"\n        );\n        require(\n            amountETH == msg.value,\n            \"Amount ETH not equal to desired amount\"\n        );\n\n        // get pair address and burn balance\n        address pair = graduateFactory.getPair(token, graduateRouter.WETH());\n        if (pair == address(0)) {\n            revert(\"Pair not created\");\n        }\n        uint256 pairBalance = IERC20(pair).balanceOf(address(this));\n        require(\n            pairBalance == liquidity,\n            \"Pair balance not equal to liquidity\"\n        );\n        IERC20(pair).transfer(deadAddress, pairBalance);\n\n        // Transfer extra rake to extraRakeReceiver\n        IERC20(token).transfer(extraRakeReceiver, extraRake);\n    }\n\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair) {\n        return address(this);\n    }\n\n    function factory() external view returns (address) {\n        return _factory;\n    }\n\n    function WETH() external view returns (address) {\n        return _WETH;\n    }\n}\n"
    },
    "contracts/Puushdot/V104/PuushdotCoinV104.sol": {
      "content": "// FILE: PuushdotCoinV104.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PuushdotCoinV104 is ERC20, Ownable {\n    error CantTransferToUniswapBeforeGraduation(address recipient);\n\n    event Graduated();\n\n    bool public graduated;\n    address public fundsAddress;\n\n    /**\n     * @dev Constructor that gives msg.sender all of existing tokens.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        address owner\n    ) ERC20(name, symbol) Ownable(owner) {\n        _mint(msg.sender, 1000000000000000000000000000); // 1 Billion tokens\n    }\n\n    function graduateCoin() public onlyOwner {\n        graduated = true;\n        renounceOwnership();\n        emit Graduated();\n    }\n\n    function setFundsAddress(address _fundsAddress) public onlyOwner {\n        fundsAddress = _fundsAddress;\n    }\n\n    /**\n     * @dev Restrict interactions with Uniswap-like pairs before graduation,\n     *      unless the account is whitelisted (`fundsAddress` or `owner`).\n     */\n    modifier checkNotGraduatedAndUniswapPair(address account) {\n        // Skip the check if account is the whitelisted fundsAddress or the contract owner\n        if (account != fundsAddress && account != owner()) {\n            if (!graduated && _hasFactoryFunction(account)) {\n                revert CantTransferToUniswapBeforeGraduation(account);\n            }\n        }\n        _;\n    }\n\n    /**\n     * @dev Check if an address is a Uniswap-like pair by detecting the `factory()` function.\n     */\n    function _hasFactoryFunction(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        if (size == 0) return false; // Exclude externally owned accounts (EOAs)\n\n        (bool success, bytes memory result) = account.staticcall(\n            abi.encodeWithSignature(\"factory()\")\n        );\n        return success && result.length > 0;\n    }\n\n    /**\n     * @dev Override approve to restrict approvals until graduated is true.\n     */\n    function approve(\n        address spender,\n        uint256 amount\n    ) public override checkNotGraduatedAndUniswapPair(spender) returns (bool) {\n        return super.approve(spender, amount);\n    }\n\n    /**\n     * @dev Override transfer to restrict transfers to Uniswap-like pairs.\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    )\n        public\n        override\n        checkNotGraduatedAndUniswapPair(recipient)\n        returns (bool)\n    {\n        return super.transfer(recipient, amount);\n    }\n\n    /**\n     * @dev Override transferFrom to restrict transfers to Uniswap-like pairs.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    )\n        public\n        override\n        checkNotGraduatedAndUniswapPair(recipient)\n        returns (bool)\n    {\n        return super.transferFrom(sender, recipient, amount);\n    }\n}\n"
    },
    "contracts/Puushdot/V104/PuushdotFunV104.sol": {
      "content": "// FILE: PuushdotFunV104.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./PuushdotCoinV104.sol\";\nimport \"../V102/PuushdotFundsV102.sol\";\n\ninterface IPuushdotGraduaterV104 {\n    function handleGraduation(\n        address token,\n        uint256 amountTokenToPair\n    ) external payable returns (address, uint256);\n}\n\ncontract PuushdotFunV104 is Ownable {\n    using Math for uint256;\n\n    uint256 public coinCreationEthCost = 1 ether;\n    uint256 public coinGraduationThreshold = 350000000 ether;\n\n    uint256 public graduationEthFee = 5000 ether;\n    uint256 public graduationCoinFee = 3000000 ether;\n\n    address payable public feeWallet;\n    address public deadAddress = 0x000000000000000000000000000000000000dEaD;\n\n    mapping(address => address) public fundsMap; // Coin => Funds\n\n    mapping(address => address) public coinCreators; // Coin => Creator\n\n    mapping(address => uint256) public coinCreateTimestamp; // Coin => block timestamp\n\n    address public graduaterAddress;\n\n    constructor(address payable _feeWallet) Ownable(msg.sender) {\n        feeWallet = _feeWallet;\n    }\n\n    event CoinCreated(\n        address coinAddress,\n        address fundsAddress,\n        address coinCreator,\n        uint256 coinToFunds,\n        string metaURI\n    );\n\n    event CoinsBought(\n        address coinAddress,\n        address userAddress,\n        uint256 ethToFund,\n        uint256 ethToFee,\n        uint256 coinsToUser,\n        uint256 newEthReserve,\n        uint256 newCoinReserve\n    );\n\n    event CoinsSold(\n        address coinAddress,\n        address userAddress,\n        uint256 coinsToFund,\n        uint256 ethToFee,\n        uint256 ethToUser,\n        uint256 newEthReserve,\n        uint256 newCoinReserve\n    );\n\n    event GraduatedAndBurned(\n        address coinAddress,\n        address fundsAddress,\n        address graduatePairAddress,\n        uint256 amountCoinsGraduated,\n        uint256 amountEthGraduated,\n        uint256 amountPairBurned\n    );\n\n    event FundsRetrieved(\n        address coinAddress,\n        address fundsAddress,\n        uint256 coinRetrieved,\n        uint256 ethRetrieved\n    );\n\n    // Emergency withdraw function for ETH\n    function emergencyWithdraw() public onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    // Emergency withdraw function for ERC20 tokens\n    function emergencyWithdrawERC20(address token) public onlyOwner {\n        IERC20(token).transfer(\n            msg.sender,\n            IERC20(token).balanceOf(address(this))\n        );\n    }\n\n    function emergencyRetrieveFunds(address coinAddress) public onlyOwner {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        PuushdotFundsV102(funds).retrieveFunds();\n\n        // Send funds to msg.sender\n        IERC20(coinAddress).transfer(\n            msg.sender,\n            IERC20(coinAddress).balanceOf(address(this))\n        );\n\n        // Send ETH to msg.sender\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function emergencyGraduate(address coinAddress) external onlyOwner {\n        PuushdotCoinV104(coinAddress).graduateCoin();\n    }\n\n    function setGraduationEthFee(uint256 _graduationEthFee) public onlyOwner {\n        require(_graduationEthFee > 0, \"Fee must be greater than 0\");\n        graduationEthFee = _graduationEthFee;\n    }\n\n    function setGraduationCoinFee(uint256 _graduationCoinFee) public onlyOwner {\n        require(_graduationCoinFee > 0, \"Fee must be greater than 0\");\n        graduationCoinFee = _graduationCoinFee;\n    }\n\n    function setCoinCreationEthCost(\n        uint256 _coinCreationEthCost\n    ) public onlyOwner {\n        require(_coinCreationEthCost > 0, \"Cost must be greater than 0\");\n        coinCreationEthCost = _coinCreationEthCost;\n    }\n\n    function setFeeWallet(address payable _feeWallet) public onlyOwner {\n        require(_feeWallet != address(0), \"Invalid fee wallet address\");\n        feeWallet = _feeWallet;\n    }\n\n    function setGraduater(address _address) public onlyOwner {\n        require(_address != address(0), \"Invalid Graduater address\");\n        graduaterAddress = _address;\n    }\n\n    function createCoin(\n        string memory name,\n        string memory symbol,\n        string memory metaURI,\n        uint256 minCoinsToBuy\n    ) public payable {\n        require(msg.value >= coinCreationEthCost, \"Not enough Eth sent\");\n        require(minCoinsToBuy <= 400_000_000 ether, \"Max buy limit reached\");\n\n        // Require checks for name and symbol length\n        require(\n            bytes(name).length > 0 && bytes(name).length <= 32,\n            \"Name must be between 1 and 32 characters\"\n        );\n        require(\n            bytes(symbol).length > 0 && bytes(symbol).length <= 10,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n        require(\n            bytes(metaURI).length > 0 && bytes(metaURI).length <= 200,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n\n        // Transfer the fee to the PumpWallet\n        feeWallet.transfer(coinCreationEthCost);\n\n        PuushdotCoinV104 coin = new PuushdotCoinV104(\n            name,\n            symbol,\n            address(this)\n        );\n\n        uint256 coinToFunds = coin.totalSupply();\n\n        // Create the PuushdotFunds contract and add liquidity\n        PuushdotFundsV102 funds = new PuushdotFundsV102(\n            address(this),\n            feeWallet,\n            address(coin)\n        );\n\n        // Add funds address to coin contract\n        coin.setFundsAddress(address(funds));\n\n        fundsMap[address(coin)] = address(funds);\n\n        // Give funds contract allowance to transfer coins\n        coin.approve(address(funds), coinToFunds);\n\n        // Use the addInitialFunds function to transfer coins to the funds contract\n        funds.addInitialFunds(coinToFunds);\n\n        // Update coinCreators and coinCreateTimestamp mapping\n        coinCreators[address(coin)] = msg.sender;\n        coinCreateTimestamp[address(coin)] = block.timestamp;\n\n        emit CoinCreated(\n            address(coin),\n            address(funds),\n            msg.sender,\n            coinToFunds,\n            metaURI\n        );\n\n        if (minCoinsToBuy > 0) {\n            require(\n                funds.SUPPLY_FOR_SALE() >= minCoinsToBuy + funds.coinsSold(),\n                \"Exceeds supplied amount\"\n            );\n            (uint256 totalCostWithFee, , ) = funds.getCost(\n                funds.coinsSold(),\n                minCoinsToBuy\n            );\n\n            require(\n                msg.value - coinCreationEthCost >= totalCostWithFee,\n                \"Wrong amount of Eth sent\"\n            );\n\n            (\n                uint256 amountToBuy,\n                uint256 cost,\n                uint256 fee,\n                uint256 ethReserve,\n                uint256 coinReserve\n            ) = funds.buyTokens{value: msg.value - coinCreationEthCost}(\n                    msg.sender,\n                    minCoinsToBuy\n                );\n\n            emit CoinsBought(\n                address(coin),\n                msg.sender,\n                cost,\n                fee,\n                amountToBuy,\n                ethReserve,\n                coinReserve\n            );\n        }\n    }\n\n    function buyCoins(\n        address coinAddress,\n        uint256 minAmountToBuy\n    ) public payable {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        (\n            uint256 amountToBuy,\n            uint256 cost,\n            uint256 fee,\n            uint256 ethReserve,\n            uint256 coinReserve\n        ) = PuushdotFundsV102(funds).buyTokens{value: msg.value}(\n                msg.sender,\n                minAmountToBuy\n            );\n\n        emit CoinsBought(\n            coinAddress,\n            msg.sender,\n            cost,\n            fee,\n            amountToBuy,\n            ethReserve,\n            coinReserve\n        );\n\n        monitorMarketCapAndGraduateCoin(coinAddress, coinReserve);\n    }\n\n    function sellCoins(\n        address coinAddress,\n        uint256 amountToSell,\n        uint256 minEthGained\n    ) public {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        (\n            uint256 ethReturn,\n            uint256 fee,\n            uint256 ethReserve,\n            uint256 coinReserve\n        ) = PuushdotFundsV102(funds).sellTokens(\n                msg.sender,\n                amountToSell,\n                minEthGained\n            );\n\n        emit CoinsSold(\n            coinAddress,\n            msg.sender,\n            amountToSell,\n            fee,\n            ethReturn,\n            ethReserve,\n            coinReserve\n        );\n    }\n\n    function monitorMarketCapAndGraduateCoin(\n        address coinAddress,\n        uint256 coinReserve\n    ) internal {\n        if (coinReserve > coinGraduationThreshold) return; // Coin not ready to graduate\n\n        PuushdotFundsV102 funds = PuushdotFundsV102(fundsMap[coinAddress]);\n\n        // Take all liquidity from the PumpPair\n        (uint256 coinsRetrieved, uint256 ethRetrieved) = PuushdotFundsV102(\n            funds\n        ).retrieveFunds();\n\n        emit FundsRetrieved(\n            coinAddress,\n            fundsMap[coinAddress],\n            coinsRetrieved,\n            ethRetrieved\n        );\n\n        if (coinsRetrieved > 0 && ethRetrieved > 0) {\n            // Calculate fees\n            // Take graduationEthFee and graduationCoinFee\n\n            uint256 amountCoinsToGraduate = coinsRetrieved - graduationCoinFee;\n            uint256 amountEthToGraduate = ethRetrieved - graduationEthFee;\n\n            // Send platform fees to fee wallet\n            require(\n                IERC20(coinAddress).transfer(feeWallet, graduationCoinFee),\n                \"Coin transfer failed\"\n            );\n            (bool success, ) = feeWallet.call{value: graduationEthFee}(\"\");\n            require(success, \"ETH transfer failed\");\n\n            // Add new liquidity on graduate platform\n            graduateAndBurn(\n                coinAddress,\n                amountCoinsToGraduate,\n                amountEthToGraduate\n            );\n        }\n    }\n\n    function graduateAndBurn(\n        address coinAddress,\n        uint256 amountCoin,\n        uint256 amountETH\n    ) internal {\n        // Flag coin as graduated. This renounces ownership of the coin contract and flags it as graduated.\n        // We flag now so that the Graduater contract can transfer and approve the coin contract.\n        PuushdotCoinV104(coinAddress).graduateCoin();\n\n        // Approve the Graduater contract to transfer the coins\n        IERC20(coinAddress).approve(address(graduaterAddress), amountCoin);\n\n        // Call the Graduater contract to handle the graduation, sending amountETH as value\n        (\n            address pairAddress,\n            uint256 pairTokensBurned\n        ) = IPuushdotGraduaterV104(graduaterAddress).handleGraduation{\n                value: amountETH\n            }(coinAddress, amountCoin);\n\n        emit GraduatedAndBurned(\n            coinAddress,\n            fundsMap[coinAddress],\n            pairAddress,\n            amountCoin,\n            amountETH,\n            pairTokensBurned\n        );\n    }\n\n    // To receive Eth from funds contract\n    receive() external payable {}\n}\n"
    },
    "contracts/Puushdot/V104/PuushdotGraduaterV104.sol": {
      "content": "// FILE: PuushdotLiquidityV103.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IFactory {\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n}\n\ninterface IRouter01 {\n    function factory() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint amountToken, uint amountETH, uint liquidity);\n}\n\ninterface IPuushdotFunV104 {\n    // Getter function for the coinCreators mapping\n    function coinCreators(address coin) external view returns (address);\n\n    // Getter function for the coinCreateTimestamp mapping\n    function coinCreateTimestamp(address coin) external view returns (uint256);\n}\n\ncontract PuushdotGraduaterV104 is Ownable {\n    address public deadAddress = 0x000000000000000000000000000000000000dEaD;\n\n    mapping(address => bool) public isAdmin;\n    mapping(address => string) public coinTexts;\n\n    mapping(address => uint256) public coinRouterId;\n    mapping(uint256 => address) public routers; // id => router, the address at id 0 is the default auto router\n\n    address public constant MANUAL_ROUTER = address(0);\n\n    // Creator Control Panel options\n    uint256 public timeLimit = 12 hours;\n    bool public creatorControlsEnabled = false;\n    address public puushdotFunV104 = address(0);\n\n    constructor() Ownable(msg.sender) {}\n\n    // Modifiers\n\n    modifier onlyAdmin() {\n        require(isAdmin[msg.sender], \"Only admin can call this function\");\n        _;\n    }\n\n    // onlyOwner functions\n\n    function addAdmin(address admin) external onlyOwner {\n        require(!isAdmin[admin], \"Already an admin\");\n        isAdmin[admin] = true;\n    }\n\n    function removeAdmin(address admin) external onlyOwner {\n        require(isAdmin[admin], \"Not an admin\");\n        isAdmin[admin] = false;\n    }\n\n    function setRouter(uint256 id, address router) external onlyOwner {\n        routers[id] = router;\n    }\n\n    function setPuushdotFunV104(address _puushdotFunV104) external onlyOwner {\n        puushdotFunV104 = _puushdotFunV104;\n    }\n\n    function setCreatorControlsEnabled(bool _enabled) external onlyOwner {\n        creatorControlsEnabled = _enabled;\n    }\n\n    function setTimeLimit(uint256 _timeLimit) external onlyOwner {\n        timeLimit = _timeLimit;\n    }\n\n    // onlyAdmin functions\n\n    function withdrawERC20Liquidity(address tokenAddress) external onlyAdmin {\n        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\n        require(balance > 0, \"No ERC20 tokens to withdraw\");\n        bool success = IERC20(tokenAddress).transfer(msg.sender, balance);\n        require(success, \"ERC20 transfer failed\");\n    }\n\n    function withdrawETHLiquidity()\n        external\n        onlyAdmin\n        returns (uint256 balance)\n    {\n        balance = address(this).balance;\n        require(balance > 0, \"No ETH to withdraw\");\n        (bool success, ) = payable(msg.sender).call{value: balance}(\"\");\n        require(success, \"ETH transfer failed\");\n    }\n\n    function setCoinGraduationRouter(\n        address coinAddress,\n        uint256 id\n    ) external onlyAdmin {\n        coinRouterId[coinAddress] = id;\n    }\n\n    function setCoinText(\n        address coinAddress,\n        string memory text\n    ) external onlyAdmin {\n        require(bytes(text).length > 0, \"Text must not be empty\");\n        require(\n            bytes(text).length <= 200,\n            \"Text must be less than 200 characters\"\n        );\n        coinTexts[coinAddress] = text;\n    }\n\n    function setCoinGraduationRouterAsCoinCreator(\n        address coinAddress,\n        uint256 id\n    ) external {\n        checkCreatorControlAuthorization(coinAddress);\n        coinRouterId[coinAddress] = id;\n    }\n\n    function setCoinTextAsCoinCreator(\n        address coinAddress,\n        string memory text\n    ) external {\n        checkCreatorControlAuthorization(coinAddress);\n        require(bytes(text).length > 0, \"Text must not be empty\");\n        require(\n            bytes(text).length <= 200,\n            \"Text must be less than 200 characters\"\n        );\n        coinTexts[coinAddress] = text;\n    }\n\n    function checkCreatorControlAuthorization(\n        address coinAddress\n    ) internal view {\n        // Check controls enabled, caller is creator, and time limit has not passed\n        require(creatorControlsEnabled, \"Creator controls not enabled\");\n        require(puushdotFunV104 != address(0), \"PuushdotFun contract not set\");\n        IPuushdotFunV104 puushdotFun = IPuushdotFunV104(puushdotFunV104);\n        require(\n            puushdotFun.coinCreators(coinAddress) == msg.sender,\n            \"Not coin creator\"\n        );\n        require(\n            block.timestamp - puushdotFun.coinCreateTimestamp(coinAddress) <=\n                timeLimit,\n            \"Time limit passed\"\n        );\n    }\n\n    // Graduation functions\n\n    function handleGraduation(\n        address token,\n        uint256 amountTokenToPair\n    ) external payable returns (address, uint256) {\n        // Take all eth and coins from msg.sender and transfer to this contract\n        IERC20(token).transferFrom(\n            msg.sender,\n            address(this),\n            amountTokenToPair\n        );\n\n        // If the router is MANUAL_ROUTER, proceed with manual graduation\n        if (routers[coinRouterId[token]] == MANUAL_ROUTER) {\n            return (address(0), 0);\n        }\n\n        // Init router and factory\n        IRouter01 graduateRouter = IRouter01(routers[coinRouterId[token]]);\n        IFactory graduateFactory = IFactory(graduateRouter.factory());\n        // Check if pair already exists, if it does then check token balance in pair contract\n        address initialPairCheck = graduateFactory.getPair(\n            token,\n            graduateRouter.WETH()\n        );\n        if (initialPairCheck != address(0)) {\n            // If pair already exists, get erc20 token balance\n            uint256 pairTokenBalance = IERC20(token).balanceOf(\n                initialPairCheck\n            );\n\n            // If token balance is not 0, go manual - this should theoretically never happen\n            if (pairTokenBalance != 0) {\n                return (address(0), 0);\n            }\n        }\n\n        // Approve token to router\n        IERC20(token).approve(address(graduateRouter), amountTokenToPair);\n\n        // Add liquidity to router\n        (\n            uint256 amountTokenPaired,\n            uint256 amountEthPaired,\n            uint256 pairTokensReceived\n        ) = graduateRouter.addLiquidityETH{value: msg.value}(\n                token,\n                amountTokenToPair,\n                0,\n                0,\n                address(this),\n                block.timestamp\n            );\n\n        require(\n            amountTokenPaired == amountTokenToPair,\n            \"Amount token not equal to desired amount\"\n        );\n        require(\n            amountEthPaired == msg.value,\n            \"Amount ETH not equal to desired amount\"\n        );\n\n        // get pair address and burn balance\n        address pairAddress = graduateFactory.getPair(\n            token,\n            graduateRouter.WETH()\n        );\n        if (pairAddress == address(0)) {\n            revert(\"Pair not created\");\n        }\n        uint256 pairBalance = IERC20(pairAddress).balanceOf(address(this));\n        require(\n            pairBalance == pairTokensReceived,\n            \"Pair balance not equal to liquidity\"\n        );\n        IERC20(pairAddress).transfer(deadAddress, pairBalance);\n\n        return (pairAddress, pairTokensReceived);\n    }\n}\n"
    },
    "contracts/Puushdot/V2/PuushdotCreatorControlPanel.sol": {
      "content": "// FILE: PuushdotCreatorControlPanel.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PuushdotCreatorControlPanel is Ownable {\n    constructor() Ownable(msg.sender) {}\n\n    address[] public routerV2Addresses;\n\n    // Owner Functions\n\n    // Add a V2 Router contract address\n    function addRouterV2Address(address _routerV2Address) external onlyOwner {\n        // Make sure the address is not already in the array\n        for (uint256 i = 0; i < routerV2Addresses.length; i++) {\n            require(\n                routerV2Addresses[i] != _routerV2Address,\n                \"Address already exists\"\n            );\n        }\n        routerV2Addresses.push(_routerV2Address);\n    }\n\n    // Remove a V2 Router contract address\n    function removeRouterV2Address(\n        address _routerV2Address\n    ) external onlyOwner {\n        // Make sure the address is in the array\n        for (uint256 i = 0; i < routerV2Addresses.length; i++) {\n            if (routerV2Addresses[i] == _routerV2Address) {\n                routerV2Addresses[i] = routerV2Addresses[\n                    routerV2Addresses.length - 1\n                ];\n                routerV2Addresses.pop();\n                break;\n            }\n        }\n    }\n\n    // Public functions\n\n    // Allow user to set a coin address to a specific router, must be the creator of the coin\n\n    // 0x could mean Manual graduation required\n\n    // Partner program enrolement options, some options have blockchain implications, others dont. Ultimately the rug dex 2.0 will need to know how much of the coin to withhold.\n    // Ultimately what this means is we just need 1 input from the user to determine the amount of the coin to withhold.\n}\n"
    },
    "contracts/Puushdot/V2/PuushdotFundsV2.sol": {
      "content": "// FILE: PuushdotFunds.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\"; // Importing the Math library from OpenZeppelin\n\ncontract PuushdotFundsV2 {\n    using Math for uint256; // Using the Math library for uint256\n\n    address public puushDotFun;\n    address public feeWallet;\n\n    uint256 public ethReserve;\n    uint256 public coinReserve;\n    uint256 public initialCoinReserve;\n    uint256 public coinsSold = 0;\n\n    uint256 public constant TOKENWEI_SUPPLY_FOR_SALE = 800_000_000 * 10 ** 18;\n    uint256 public constant SUPPLY_FOR_SALE_WEI_COST = 100_000 * 10 ** 18;\n    uint256 public constant WEI_PER_TOKEN_START = 22_727_272_727_272;\n    uint256 public constant WEI_PER_TOKEN_END = 227_272_727_272_727;\n    uint256 public constant TOKENWEI_PER_ETH_START =\n        14_545_454_545_454_545_454_545;\n    uint256 public constant TOKENWEI_PER_ETH_END =\n        1_454_545_454_545_454_545_454;\n\n    bool public isGraduated = false;\n\n    IERC20 public coin;\n\n    constructor(\n        address _puushDotFun,\n        address _feeWallet,\n        address _coinAddress\n    ) {\n        puushDotFun = _puushDotFun;\n        feeWallet = _feeWallet;\n        coin = IERC20(_coinAddress);\n    }\n\n    modifier onlyFun() {\n        require(\n            msg.sender == puushDotFun,\n            \"Only the factory can call this function\"\n        );\n        _;\n    }\n\n    function addInitialFunds(uint256 amountCoinDesired) external onlyFun {\n        require(coin.balanceOf(address(this)) == 0, \"Funds already added\");\n        coinReserve = amountCoinDesired;\n        initialCoinReserve = amountCoinDesired;\n        coin.transferFrom(msg.sender, address(this), amountCoinDesired);\n    }\n\n    function retrieveFunds() external onlyFun returns (uint256, uint256) {\n        isGraduated = true;\n\n        uint256 coinToTransfer = coinReserve;\n        uint256 ethToTransfer = ethReserve;\n\n        uint256 coinBalance = coin.balanceOf(address(this));\n        uint256 ethBalance = address(this).balance;\n\n        if (coinBalance < coinReserve) {\n            coinToTransfer = coinBalance;\n        }\n\n        if (ethBalance > ethReserve) {\n            ethToTransfer = ethBalance;\n        }\n\n        coinReserve = 0;\n        ethReserve = 0;\n\n        // Transfer coins first to reduce potential reentrancy issues\n        if (coinToTransfer > 0) {\n            require(\n                coin.transfer(puushDotFun, coinToTransfer),\n                \"Coin transfer failed\"\n            );\n        }\n\n        // Transfer ETH\n        if (ethToTransfer > 0) {\n            (bool success, ) = puushDotFun.call{value: ethToTransfer}(\"\");\n            require(success, \"ETH transfer failed\");\n        }\n\n        return (coinToTransfer, ethToTransfer);\n    }\n\n    function getFunds() public view returns (uint256, uint256) {\n        return (coinReserve, ethReserve);\n    }\n\n    function buyTokens(\n        address user,\n        uint256 minAmountToBuy\n    )\n        public\n        payable\n        onlyFun\n        returns (uint256, uint256, uint256, uint256, uint256)\n    {\n        require(msg.value > 0, \"No ETH sent\");\n        require(!isGraduated, \"Funds are no longer for sale\");\n        if (minAmountToBuy + coinsSold > TOKENWEI_SUPPLY_FOR_SALE) {\n            minAmountToBuy = TOKENWEI_SUPPLY_FOR_SALE - coinsSold;\n        }\n\n        uint256 ethSent = msg.value;\n        (uint256 cost, uint256 fee, uint256 amountToBuy, , , ) = getAmountToBuy(\n            ethReserve,\n            ethSent\n        );\n\n        require(\n            amountToBuy >= minAmountToBuy,\n            \"Slippage: Tokens received less than minimum required\"\n        );\n        require(\n            TOKENWEI_SUPPLY_FOR_SALE >= amountToBuy + coinsSold,\n            \"Exceeds supplied amount\"\n        );\n\n        // require(totalCostWithFee <= ethSent, \"Insufficient ETH sent\");\n\n        ethReserve += cost;\n        coinReserve -= amountToBuy;\n        coinsSold += amountToBuy;\n\n        require(coin.transfer(user, amountToBuy), \"Token transfer failed\");\n\n        // Transfer the fee to the fee wallet\n        (bool feeSent, ) = feeWallet.call{value: fee}(\"\");\n        require(feeSent, \"Fee transfer failed\");\n\n        return (amountToBuy, cost, fee, ethReserve, coinReserve);\n    }\n\n    function sellTokens(\n        address user,\n        uint256 amountToSell,\n        uint256 minEthGained\n    ) public onlyFun returns (uint256, uint256, uint256, uint256) {\n        require(amountToSell > 0, \"Amount to sell must be greater than 0\");\n        require(coinsSold >= amountToSell, \"Insufficient coins sold\");\n        require(ethReserve > 0, \"ETH reserve is empty\");\n        require(!isGraduated, \"Funds are no longer for sale\");\n\n        (uint256 ethReturnWithFee, uint256 ethReturn, uint256 fee) = getReturn(\n            coinsSold,\n            amountToSell\n        );\n        require(\n            coinReserve + amountToSell <= initialCoinReserve,\n            \"Exceeds supply limit\"\n        );\n        require(\n            ethReturn >= minEthGained,\n            \"Slippage: ETH gained is less than minimum required\"\n        );\n        require(ethReturnWithFee <= ethReserve, \"Insufficient ETH in reserve\");\n\n        ethReserve -= ethReturnWithFee;\n        coinReserve += amountToSell;\n        coinsSold -= amountToSell;\n\n        require(\n            coin.transferFrom(user, address(this), amountToSell),\n            \"Token transfer failed\"\n        );\n\n        (bool ethSent, ) = user.call{value: ethReturn}(\"\");\n        require(ethSent, \"ETH transfer failed\");\n\n        // Transfer the fee to the fee wallet\n        (bool feeSent, ) = feeWallet.call{value: fee}(\"\");\n        require(feeSent, \"Fee transfer failed\");\n\n        return (ethReturn, fee, ethReserve, coinReserve);\n    }\n\n    function getAmountToBuy(\n        uint256 _ethReserve,\n        uint256 ethAmount\n    )\n        public\n        pure\n        returns (\n            uint256 cost,\n            uint256 fee,\n            uint256 amountToBuy,\n            uint256 startTokensPerEth,\n            uint256 endTokensPerEth,\n            uint256\n        )\n    {\n        uint256 start = _ethReserve;\n        uint256 end = _ethReserve + ethAmount;\n\n        startTokensPerEth = interpolatePriceBuy(start);\n        endTokensPerEth = interpolatePriceBuy(end);\n\n        uint256 avgTokenPerEth = (startTokensPerEth + endTokensPerEth) / 2;\n\n        fee = Math.mulDiv(ethAmount, 1, 100); // 1% fee\n        cost = ethAmount - fee;\n\n        amountToBuy = Math.mulDiv(cost, avgTokenPerEth, 1e18); // Adjust for wei\n\n        return (\n            cost,\n            fee,\n            amountToBuy,\n            startTokensPerEth,\n            endTokensPerEth,\n            ethAmount\n        );\n    }\n\n    function getCost(\n        uint256 currentSupplySold,\n        uint256 amountToBuy\n    )\n        public\n        pure\n        returns (uint256 totalCostWithFee, uint256 cost, uint256 fee)\n    {\n        uint256 start = currentSupplySold;\n        uint256 end = currentSupplySold + amountToBuy;\n\n        uint256 startPricePerToken = interpolatePriceSell(start);\n        uint256 endPricePerToken = interpolatePriceSell(end);\n\n        uint256 avgPricePerToken = (startPricePerToken + endPricePerToken) / 2;\n\n        cost = Math.mulDiv(avgPricePerToken, amountToBuy, 1e18); // Adjust for wei\n        fee = Math.mulDiv(cost, 1, 100); // 1% fee\n        totalCostWithFee = cost + fee;\n\n        return (totalCostWithFee, cost, fee);\n    }\n\n    function getReturn(\n        uint256 currentSupplySold,\n        uint256 amountToSell\n    )\n        public\n        view\n        returns (uint256 totalReturnWithFee, uint256 ethReturn, uint256 fee)\n    {\n        uint256 start = currentSupplySold;\n        uint256 end = currentSupplySold - amountToSell;\n\n        uint256 startPricePerToken = interpolatePriceSell(start);\n        uint256 endPricePerToken = interpolatePriceSell(end);\n\n        uint256 avgPricePerToken = Math.mulDiv(\n            (startPricePerToken + endPricePerToken),\n            1e18,\n            2 * 1e18\n        );\n\n        uint256 ethGrossReturn = Math.mulDiv(\n            avgPricePerToken,\n            amountToSell,\n            1e18\n        ); // Adjust for wei\n\n        fee = Math.mulDiv(ethGrossReturn, 1, 100); // 1% fee\n        ethReturn = ethGrossReturn - fee; // Amount user gets after fee\n        totalReturnWithFee = ethGrossReturn; // Total amount including fee\n\n        // Check if selling the remaining coins\n        if (amountToSell + coinReserve == initialCoinReserve) {\n            totalReturnWithFee = ethReserve;\n            fee = Math.mulDiv(totalReturnWithFee, 1, 100); // 1% fee\n            ethReturn = totalReturnWithFee - fee;\n        }\n\n        return (totalReturnWithFee, ethReturn, fee);\n    }\n\n    function interpolatePriceSell(\n        uint256 supply\n    ) internal pure returns (uint256) {\n        uint256 price = WEI_PER_TOKEN_START +\n            Math.mulDiv(\n                (WEI_PER_TOKEN_END - WEI_PER_TOKEN_START),\n                supply,\n                TOKENWEI_SUPPLY_FOR_SALE\n            );\n        return price;\n    }\n\n    function interpolatePriceBuy(\n        uint256 supply\n    ) internal pure returns (uint256) {\n        uint256 price = TOKENWEI_PER_ETH_START -\n            Math.mulDiv(\n                (TOKENWEI_PER_ETH_START - TOKENWEI_PER_ETH_END),\n                supply,\n                SUPPLY_FOR_SALE_WEI_COST\n            );\n        return price;\n    }\n\n    //     uint256 public constant TOKENWEI_PER_ETH_START =\n    //     14_545_454_545_454_545_454_545;\n    // uint256 public constant TOKENWEI_PER_ETH_END =\n    //     1_454_545_454_545_454_545_454;\n}\n\n// pragma solidity ^0.8.20;\n\n// import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// import \"@openzeppelin/contracts/utils/math/Math.sol\"; // Importing the Math library from OpenZeppelin\n\n// contract PuushdotFundsV2 {\n//     using Math for uint256; // Using the Math library for uint256\n\n//     address public puushDotFun;\n//     address public feeWallet;\n\n//     uint256 public ethReserve;\n//     uint256 public coinReserve;\n//     uint256 public initialCoinReserve;\n//     uint256 public coinsSold = 0;\n\n//     uint256 public constant SUPPLY_FOR_SALE = 800_000_000 * 10 ** 18;\n//     uint256 public constant START_COINS_PER_WEI = 14545; // Coins per WEI\n//     uint256 public constant END_COINS_PER_WEI = 1454; // Coins per WEI\n\n//     bool public isGraduated = false;\n\n//     IERC20 public coin;\n\n//     constructor(\n//         address _puushDotFun,\n//         address _feeWallet,\n//         address _coinAddress\n//     ) {\n//         puushDotFun = _puushDotFun;\n//         feeWallet = _feeWallet;\n//         coin = IERC20(_coinAddress);\n//     }\n\n//     modifier onlyFun() {\n//         require(\n//             msg.sender == puushDotFun,\n//             \"Only the factory can call this function\"\n//         );\n//         _;\n//     }\n\n//     function addInitialFunds(uint256 amountCoinDesired) external onlyFun {\n//         require(coin.balanceOf(address(this)) == 0, \"Funds already added\");\n//         coinReserve = amountCoinDesired;\n//         initialCoinReserve = amountCoinDesired;\n//         coin.transferFrom(msg.sender, address(this), amountCoinDesired);\n//     }\n\n//     function retrieveFunds() external onlyFun returns (uint256, uint256) {\n//         isGraduated = true;\n\n//         uint256 coinToTransfer = coinReserve;\n//         uint256 ethToTransfer = ethReserve;\n\n//         uint256 coinBalance = coin.balanceOf(address(this));\n//         uint256 ethBalance = address(this).balance;\n\n//         if (coinBalance < coinReserve) {\n//             coinToTransfer = coinBalance;\n//         }\n\n//         if (ethBalance > ethReserve) {\n//             ethToTransfer = ethBalance;\n//         }\n\n//         coinReserve = 0;\n//         ethReserve = 0;\n\n//         // Transfer coins first to reduce potential reentrancy issues\n//         if (coinToTransfer > 0) {\n//             require(\n//                 coin.transfer(puushDotFun, coinToTransfer),\n//                 \"Coin transfer failed\"\n//             );\n//         }\n\n//         // Transfer ETH\n//         if (ethToTransfer > 0) {\n//             (bool success, ) = puushDotFun.call{value: ethToTransfer}(\"\");\n//             require(success, \"ETH transfer failed\");\n//         }\n\n//         return (coinToTransfer, ethToTransfer);\n//     }\n\n//     function getFunds() public view returns (uint256, uint256) {\n//         return (coinReserve, ethReserve);\n//     }\n\n//     function buyTokens(\n//         address user,\n//         uint256 minAmountToBuy\n//     )\n//         public\n//         payable\n//         onlyFun\n//         returns (uint256, uint256, uint256, uint256, uint256)\n//     {\n//         require(msg.value > 0, \"No ETH sent\");\n//         require(!isGraduated, \"Funds are no longer for sale\");\n//         if (minAmountToBuy + coinsSold > SUPPLY_FOR_SALE) {\n//             minAmountToBuy = SUPPLY_FOR_SALE - coinsSold;\n//         }\n\n//         uint256 ethSent = msg.value;\n//         uint256 amountToBuy = getAmountToBuy(coinsSold, ethSent);\n\n//         require(\n//             amountToBuy >= minAmountToBuy,\n//             \"Slippage: Tokens received less than minimum required\"\n//         );\n//         require(\n//             SUPPLY_FOR_SALE >= amountToBuy + coinsSold,\n//             \"Exceeds supplied amount\"\n//         );\n\n//         (uint256 totalCostWithFee, uint256 cost, uint256 fee) = getCost(\n//             coinsSold,\n//             amountToBuy\n//         );\n//         require(totalCostWithFee <= ethSent, \"Insufficient ETH sent\");\n\n//         ethReserve += cost;\n//         coinReserve -= amountToBuy;\n//         coinsSold += amountToBuy;\n\n//         require(coin.transfer(user, amountToBuy), \"Token transfer failed\");\n\n//         // Transfer the fee to the fee wallet\n//         (bool feeSent, ) = feeWallet.call{value: fee}(\"\");\n//         require(feeSent, \"Fee transfer failed\");\n\n//         // Refund excess ETH\n//         if (ethSent > totalCostWithFee) {\n//             uint256 excess = ethSent - totalCostWithFee;\n//             (bool refundSent, ) = user.call{value: excess}(\"\");\n//             require(refundSent, \"Refund failed\");\n//         }\n\n//         return (amountToBuy, cost, fee, ethReserve, coinReserve);\n//     }\n\n//     function sellTokens(\n//         address user,\n//         uint256 amountToSell,\n//         uint256 minEthGained\n//     ) public onlyFun returns (uint256, uint256, uint256, uint256) {\n//         require(amountToSell > 0, \"Amount to sell must be greater than 0\");\n//         require(coinsSold >= amountToSell, \"Insufficient coins sold\");\n//         require(ethReserve > 0, \"ETH reserve is empty\");\n//         require(!isGraduated, \"Funds are no longer for sale\");\n\n//         (uint256 ethReturnWithFee, uint256 ethReturn, uint256 fee) = getReturn(\n//             coinsSold,\n//             amountToSell\n//         );\n//         require(\n//             coinReserve + amountToSell <= initialCoinReserve,\n//             \"Exceeds supply limit\"\n//         );\n//         require(\n//             ethReturn >= minEthGained,\n//             \"Slippage: ETH gained is less than minimum required\"\n//         );\n//         require(ethReturnWithFee <= ethReserve, \"Insufficient ETH in reserve\");\n\n//         ethReserve -= ethReturnWithFee;\n//         coinReserve += amountToSell;\n//         coinsSold -= amountToSell;\n\n//         require(\n//             coin.transferFrom(user, address(this), amountToSell),\n//             \"Token transfer failed\"\n//         );\n\n//         (bool ethSent, ) = user.call{value: ethReturn}(\"\");\n//         require(ethSent, \"ETH transfer failed\");\n\n//         // Transfer the fee to the fee wallet\n//         (bool feeSent, ) = feeWallet.call{value: fee}(\"\");\n//         require(feeSent, \"Fee transfer failed\");\n\n//         return (ethReturn, fee, ethReserve, coinReserve);\n//     }\n\n//     // Function to calculate the amount of tokens that can be bought with the given ETH\n//     function getAmountToBuy(\n//         uint256 currentSupplySold,\n//         uint256 ethSent\n//     ) public pure returns (uint256) {\n//         uint256 low = 0;\n//         uint256 high = SUPPLY_FOR_SALE - currentSupplySold;\n//         uint256 mid;\n//         uint256 cost;\n\n//         while (low < high) {\n//             mid = (low + high + 1) / 2;\n//             (cost, , ) = getCost(currentSupplySold, mid);\n\n//             if (cost <= ethSent) {\n//                 low = mid;\n//             } else {\n//                 high = mid - 1;\n//             }\n//         }\n\n//         return low;\n//     }\n\n//     function getCost(\n//         uint256 currentSupplySold,\n//         uint256 amountToBuy\n//     )\n//         public\n//         pure\n//         returns (uint256 totalCostWithFee, uint256 cost, uint256 fee)\n//     {\n//         uint256 start = currentSupplySold;\n//         uint256 end = currentSupplySold + amountToBuy;\n\n//         // uint256 startPricePerToken = interpolatePrice(start);\n//         // uint256 endPricePerToken = interpolatePrice(end);\n\n//         // uint256 avgPricePerToken = Math.mulDiv(\n//         //     (startPricePerToken + endPricePerToken),\n//         //     1e18,\n//         //     2 * 1e18\n//         // );\n\n//         uint256 avgCoinsPerWei = getAverageCoinsPerWei(start, end);\n\n//         // cost = Math.mulDiv(avgPricePerToken, amountToBuy, 1e18); // Adjust for wei\n//         cost = amountToBuy / avgCoinsPerWei;\n//         fee = Math.mulDiv(cost, 1, 100); // 1% fee\n//         totalCostWithFee = cost + fee;\n\n//         return (totalCostWithFee, cost, fee);\n//     }\n\n//     function getReturn(\n//         uint256 currentSupplySold,\n//         uint256 amountToSell\n//     )\n//         public\n//         view\n//         returns (uint256 totalReturnWithFee, uint256 ethReturn, uint256 fee)\n//     {\n//         uint256 start = currentSupplySold;\n//         uint256 end = currentSupplySold - amountToSell;\n\n//         // uint256 startPricePerToken = interpolatePrice(start);\n//         // uint256 endPricePerToken = interpolatePrice(end);\n\n//         // uint256 avgPricePerToken = Math.mulDiv(\n//         //     (startPricePerToken + endPricePerToken),\n//         //     1e18,\n//         //     2 * 1e18\n//         // );\n\n//         uint256 avgCoinsPerWei = getAverageCoinsPerWei(start, end);\n\n//         // uint256 ethGrossReturn = Math.mulDiv(\n//         //     avgPricePerToken,\n//         //     amountToSell,\n//         //     1e18\n//         // ); // Adjust for wei\n\n//         uint256 ethGrossReturn = amountToSell / avgCoinsPerWei;\n\n//         fee = Math.mulDiv(ethGrossReturn, 1, 100); // 1% fee\n//         ethReturn = ethGrossReturn - fee; // Amount user gets after fee\n//         totalReturnWithFee = ethGrossReturn; // Total amount including fee\n\n//         // Check if selling the remaining coins\n//         if (amountToSell + coinReserve == initialCoinReserve) {\n//             totalReturnWithFee = ethReserve;\n//             fee = Math.mulDiv(totalReturnWithFee, 1, 100); // 1% fee\n//             ethReturn = totalReturnWithFee - fee;\n//         }\n\n//         return (totalReturnWithFee, ethReturn, fee);\n//     }\n\n//     function interpolatePrice(uint256 supply) internal pure returns (uint256) {\n//         uint256 price = START_COINS_PER_WEI -\n//             Math.mulDiv(\n//                 (START_COINS_PER_WEI - END_COINS_PER_WEI),\n//                 supply,\n//                 SUPPLY_FOR_SALE\n//             );\n//         return price;\n//     }\n\n//     function getAverageCoinsPerWei(\n//         uint256 start,\n//         uint256 end\n//     ) public pure returns (uint256) {\n//         uint256 startCoinsPerWei = interpolatePrice(start);\n//         uint256 endCoinsPerWei = interpolatePrice(end);\n\n//         uint256 avgCoinsPerWei = (startCoinsPerWei + endCoinsPerWei) / 2;\n\n//         return avgCoinsPerWei;\n//     }\n// }\n"
    },
    "contracts/Puushdot/V2/PuushdotFunV2.sol": {
      "content": "// FILE: PuushdotFun.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../V1/PuushdotCoin.sol\";\nimport \"./PuushdotFundsV2.sol\";\n\ncontract PuushdotFunV2 is Ownable {\n    using Math for uint256;\n\n    uint256 public coinCreationEthCost = 50 ether;\n    uint256 public coinGraduationThreshold = 200000000 ether;\n\n    address payable public feeWallet;\n    address public deadAddress = 0x000000000000000000000000000000000000dEaD;\n\n    mapping(address => address) public fundsMap; // Coin => Funds\n\n    IRouter01 public graduateRouter;\n\n    constructor(address payable _feeWallet) Ownable(msg.sender) {\n        feeWallet = _feeWallet;\n    }\n\n    event CoinCreated(\n        address coinAddress,\n        address fundsAddress,\n        address coinCreator,\n        uint256 coinToFunds,\n        string metaURI\n    );\n\n    event CoinsBought(\n        address coinAddress,\n        address userAddress,\n        uint256 ethToFund,\n        uint256 ethToFee,\n        uint256 coinsToUser,\n        uint256 newEthReserve,\n        uint256 newCoinReserve\n    );\n\n    event CoinsSold(\n        address coinAddress,\n        address userAddress,\n        uint256 coinsToFund,\n        uint256 ethToFee,\n        uint256 ethToUser,\n        uint256 newEthReserve,\n        uint256 newCoinReserve\n    );\n\n    event GraduatedAndBurned(\n        address coinAddress,\n        address fundsAddress,\n        address graduatePairAddress,\n        uint256 amountCoinsGraduated,\n        uint256 amountEthGraduated,\n        uint256 amountPairBurned\n    );\n\n    event FundsRetrieved(\n        address coinAddress,\n        address fundsAddress,\n        uint256 coinRetrieved,\n        uint256 ethRetrieved\n    );\n\n    // Emergency withdraw function for ETH\n    function emergencyWithdraw() public onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    // Emergency withdraw function for ERC20 tokens\n    function emergencyWithdrawERC20(address token) public onlyOwner {\n        IERC20(token).transfer(\n            msg.sender,\n            IERC20(token).balanceOf(address(this))\n        );\n    }\n\n    function setCoinCreationEthCost(\n        uint256 _coinCreationEthCost\n    ) public onlyOwner {\n        require(_coinCreationEthCost > 0, \"Cost must be greater than 0\");\n        coinCreationEthCost = _coinCreationEthCost;\n    }\n\n    function setFeeWallet(address payable _feeWallet) public onlyOwner {\n        require(_feeWallet != address(0), \"Invalid fee wallet address\");\n        feeWallet = _feeWallet;\n    }\n\n    function setGraduateRouter(address _router) public onlyOwner {\n        require(_router != address(0), \"Invalid router address\");\n        graduateRouter = IRouter01(_router);\n    }\n\n    function createCoin(\n        string memory name,\n        string memory symbol,\n        string memory metaURI,\n        uint256 minCoinsToBuy\n    ) public payable {\n        require(msg.value >= coinCreationEthCost, \"Not enough Eth sent\");\n        require(minCoinsToBuy <= 400_000_000 ether, \"Max buy limit reached\");\n\n        // Require checks for name and symbol length\n        require(\n            bytes(name).length > 0 && bytes(name).length <= 32,\n            \"Name must be between 1 and 32 characters\"\n        );\n        require(\n            bytes(symbol).length > 0 && bytes(symbol).length <= 10,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n        require(\n            bytes(metaURI).length > 0 && bytes(metaURI).length <= 200,\n            \"Symbol must be between 1 and 10 characters\"\n        );\n\n        // Transfer the fee to the PumpWallet\n        feeWallet.transfer(coinCreationEthCost);\n\n        PuushdotCoin coin = new PuushdotCoin(name, symbol);\n        uint256 coinToFunds = coin.totalSupply();\n\n        // Create the PuushdotFunds contract and add liquidity\n        PuushdotFundsV2 funds = new PuushdotFundsV2(\n            address(this),\n            feeWallet,\n            address(coin)\n        );\n        fundsMap[address(coin)] = address(funds);\n\n        // Give funds contract allowance to transfer coins\n        coin.approve(address(funds), coinToFunds);\n\n        // Use the addInitialFunds function to transfer coins to the funds contract\n        funds.addInitialFunds(coinToFunds);\n\n        emit CoinCreated(\n            address(coin),\n            address(funds),\n            msg.sender,\n            coinToFunds,\n            metaURI\n        );\n\n        if (msg.value - coinCreationEthCost > 0) {\n            (\n                uint256 amountToBuy,\n                uint256 cost,\n                uint256 fee,\n                uint256 ethReserve,\n                uint256 coinReserve\n            ) = funds.buyTokens{value: msg.value - coinCreationEthCost}(\n                    msg.sender,\n                    minCoinsToBuy\n                );\n\n            emit CoinsBought(\n                address(coin),\n                msg.sender,\n                cost,\n                fee,\n                amountToBuy,\n                ethReserve,\n                coinReserve\n            );\n        }\n    }\n\n    function buyCoins(\n        address coinAddress,\n        uint256 minAmountToBuy\n    ) public payable {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        (\n            uint256 amountToBuy,\n            uint256 cost,\n            uint256 fee,\n            uint256 ethReserve,\n            uint256 coinReserve\n        ) = PuushdotFundsV2(funds).buyTokens{value: msg.value}(\n                msg.sender,\n                minAmountToBuy\n            );\n\n        emit CoinsBought(\n            coinAddress,\n            msg.sender,\n            cost,\n            fee,\n            amountToBuy,\n            ethReserve,\n            coinReserve\n        );\n\n        monitorMarketCapAndGraduateCoin(coinAddress, coinReserve);\n    }\n\n    function sellCoins(\n        address coinAddress,\n        uint256 amountToSell,\n        uint256 minEthGained\n    ) public {\n        address funds = fundsMap[coinAddress];\n        require(funds != address(0), \"Funds do not exist\");\n\n        (\n            uint256 ethReturn,\n            uint256 fee,\n            uint256 ethReserve,\n            uint256 coinReserve\n        ) = PuushdotFundsV2(funds).sellTokens(\n                msg.sender,\n                amountToSell,\n                minEthGained\n            );\n\n        emit CoinsSold(\n            coinAddress,\n            msg.sender,\n            amountToSell,\n            fee,\n            ethReturn,\n            ethReserve,\n            coinReserve\n        );\n    }\n\n    function monitorMarketCapAndGraduateCoin(\n        address coinAddress,\n        uint256 coinReserve\n    ) internal {\n        if (coinReserve > coinGraduationThreshold) return; // Coin not ready to graduate\n\n        PuushdotFundsV2 funds = PuushdotFundsV2(fundsMap[coinAddress]);\n\n        // Take all liquidity from the PumpPair\n        (uint256 coinsRetrieved, uint256 ethRetrieved) = PuushdotFundsV2(funds)\n            .retrieveFunds();\n\n        emit FundsRetrieved(\n            coinAddress,\n            fundsMap[coinAddress],\n            coinsRetrieved,\n            ethRetrieved\n        );\n\n        if (coinsRetrieved > 0 && ethRetrieved > 0) {\n            // Calculate fees\n            // Take 5% of eth and 0.5% coin from the funds\n            uint256 coinPlatformFee = coinsRetrieved / 200;\n            uint256 ethPlatformFee = ethRetrieved / 20;\n\n            uint256 amountCoinsToGraduate = coinsRetrieved - coinPlatformFee;\n            uint256 amountEthToGraduate = ethRetrieved - ethPlatformFee;\n\n            // Send platform fees to fee wallet\n            require(\n                IERC20(coinAddress).transfer(feeWallet, coinPlatformFee),\n                \"Coin transfer failed\"\n            );\n            (bool success, ) = feeWallet.call{value: ethPlatformFee}(\"\");\n            require(success, \"ETH transfer failed\");\n\n            // Add new liquidity on graduate platform\n            graduateAndBurn(\n                coinAddress,\n                amountCoinsToGraduate,\n                amountEthToGraduate\n            );\n        }\n    }\n\n    function graduateAndBurn(\n        address coinAddress,\n        uint256 amountCoin,\n        uint256 amountETH\n    ) internal {\n        IFactory graduateFactory = IFactory(graduateRouter.factory());\n        IERC20(coinAddress).approve(address(graduateRouter), amountCoin);\n\n        graduateRouter.addLiquidityETH{value: amountETH}(\n            coinAddress,\n            amountCoin,\n            0, // Slippage is unavoidable\n            0, // Slippage is unavoidable\n            address(this),\n            block.timestamp\n        );\n\n        address pair = graduateFactory.getPair(\n            coinAddress,\n            graduateRouter.WETH()\n        );\n\n        if (pair == address(0)) {\n            revert(\"Pair not created\");\n        }\n        uint256 pairBalance = IERC20(pair).balanceOf(address(this));\n        // Burn liquidity tokens\n        IERC20(pair).transfer(deadAddress, pairBalance);\n\n        emit GraduatedAndBurned(\n            coinAddress,\n            fundsMap[coinAddress],\n            pair,\n            amountCoin,\n            amountETH,\n            pairBalance\n        );\n    }\n\n    // To receive Eth from funds contract\n    receive() external payable {}\n}\n\ninterface IFactory {\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair);\n}\n\ninterface IRouter01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint amountToken, uint amountETH, uint liquidity);\n}\n"
    },
    "contracts/Puushdot/V2/PuushdotLiquidityV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IFactory {\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n}\n\ninterface IRouter01 {\n    function factory() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint amountToken, uint amountETH, uint liquidity);\n}\n\ncontract PuushdotLiquidityV2 is IFactory, IRouter01, Ownable, ERC20 {\n    address private _factory = address(this);\n    address private _WETH;\n    address[] public routerV2Addresses;\n\n    constructor()\n        Ownable(msg.sender)\n        ERC20(\"PuushdotLiquidity\", \"PUUSHDOTLP\")\n    {}\n\n    // Owner functions\n\n    function addRouterV2Address(address _routerV2Address) external onlyOwner {\n        for (uint256 i = 0; i < routerV2Addresses.length; i++) {\n            require(\n                routerV2Addresses[i] != _routerV2Address,\n                \"Address already exists\"\n            );\n        }\n        routerV2Addresses.push(_routerV2Address);\n    }\n\n    function withdrawERC20Liquidity(address tokenAddress) external onlyOwner {\n        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\n        require(balance > 0, \"No ERC20 tokens to withdraw\");\n        bool success = IERC20(tokenAddress).transfer(msg.sender, balance);\n        require(success, \"ERC20 transfer failed\");\n    }\n\n    function withdrawETHLiquidity()\n        external\n        onlyOwner\n        returns (uint256 balance)\n    {\n        balance = address(this).balance;\n        require(balance > 0, \"No ETH to withdraw\");\n        (bool success, ) = payable(msg.sender).call{value: balance}(\"\");\n        require(success, \"ETH transfer failed\");\n    }\n\n    // Public functions\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        override\n        returns (uint amountToken, uint amountETH, uint liquidity)\n    {\n        // Take all eth and coins from msg.sender and transfer to this contract\n        IERC20(token).transferFrom(\n            msg.sender,\n            address(this),\n            amountTokenDesired\n        );\n\n        // Mint 1 LP token to msg.sender\n        _mint(msg.sender, 1);\n    }\n\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair) {\n        return address(this);\n    }\n\n    function factory() external view returns (address) {\n        return _factory;\n    }\n\n    function WETH() external view returns (address) {\n        return _WETH;\n    }\n}\n"
    },
    "contracts/Puushdot/VMaker/Interface/IPuushdotCoinMaker.sol": {
      "content": "// FILE: IPuushdotCoinMaker.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IPuushdotCoinMaker {\n    function makeCoin(\n        string memory name,\n        string memory symbol\n    ) external returns (address);\n}\n"
    },
    "contracts/Puushdot/VMaker/Interface/IPuushdotFundMaker.sol": {
      "content": "// FILE: IPuushdotFundMaker.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IPuushdotFundMaker {\n    function makeFund(\n        address feeWallet,\n        address coinAddress\n    ) external returns (address);\n}\n"
    },
    "contracts/Puushdot/VMaker/PuushdotCoinMaker.sol": {
      "content": "// FILE: PuushdotCoinMaker.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../V1/PuushdotCoin.sol\";\nimport \"./Interface/IPuushdotCoinMaker.sol\";\n\ncontract PuushdotCoinMaker is IPuushdotCoinMaker {\n    address private PuushdotFunAddress;\n\n    constructor(address _PuushdotFunAddress) {\n        PuushdotFunAddress = _PuushdotFunAddress;\n    }\n\n    modifier onlyPuushdotFun() {\n        require(\n            msg.sender == PuushdotFunAddress,\n            \"Only PuushdotFun can call this function\"\n        );\n        _;\n    }\n\n    // TODO: Make coin ownable, then revoke right away\n\n    function makeCoin(\n        string memory name,\n        string memory symbol\n    ) external onlyPuushdotFun returns (address) {\n        PuushdotCoin coin = new PuushdotCoin(name, symbol);\n        return address(coin);\n    }\n}\n"
    },
    "contracts/Puushdot/VMaker/PuushdotFunCenter.sol": {
      "content": "// FILE: PuushdotFun.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract PuushdotFunCenter is Ownable {\n    uint256 public coinCreationEthCost = 50 ether;\n    uint256 public coinGraduationThreshold = 200000000 ether;\n\n    address payable public feeWallet;\n    address public deadAddress = 0x000000000000000000000000000000000000dEaD;\n\n    mapping(address => address) public fundsMap; // Coin => Funds\n    mapping(address => address) public creatorMap; // Coin => Creator\n\n    constructor() Ownable(msg.sender) {}\n\n    // event CoinCreated(\n    //     address coinAddress,\n    //     address fundsAddress,\n    //     address coinCreator,\n    //     uint256 coinToFunds,\n    //     string metaURI\n    // );\n\n    // event CoinsBought(\n    //     address coinAddress,\n    //     address userAddress,\n    //     uint256 ethToFund,\n    //     uint256 ethToFee,\n    //     uint256 coinsToUser,\n    //     uint256 newEthReserve,\n    //     uint256 newCoinReserve\n    // );\n\n    // event CoinsSold(\n    //     address coinAddress,\n    //     address userAddress,\n    //     uint256 coinsToFund,\n    //     uint256 ethToFee,\n    //     uint256 ethToUser,\n    //     uint256 newEthReserve,\n    //     uint256 newCoinReserve\n    // );\n\n    // event GraduatedAndBurned(\n    //     address coinAddress,\n    //     address fundsAddress,\n    //     address graduatePairAddress,\n    //     uint256 amountCoinsGraduated,\n    //     uint256 amountEthGraduated,\n    //     uint256 amountPairBurned\n    // );\n\n    // event FundsRetrieved(\n    //     address coinAddress,\n    //     address fundsAddress,\n    //     uint256 coinRetrieved,\n    //     uint256 ethRetrieved\n    // );\n\n    // // Emergency withdraw function for ETH\n    // function emergencyWithdraw() public onlyOwner {\n    //     payable(msg.sender).transfer(address(this).balance);\n    // }\n\n    // // Emergency withdraw function for ERC20 tokens\n    // function emergencyWithdrawERC20(address token) public onlyOwner {\n    //     IERC20(token).transfer(\n    //         msg.sender,\n    //         IERC20(token).balanceOf(address(this))\n    //     );\n    // }\n\n    // function emergencyRetrieveFunds(address coinAddress) public onlyOwner {\n    //     address funds = fundsMap[coinAddress];\n    //     require(funds != address(0), \"Funds do not exist\");\n\n    //     PuushdotFundsV101(funds).retrieveFunds();\n\n    //     // Send funds to msg.sender\n    //     IERC20(coinAddress).transfer(\n    //         msg.sender,\n    //         IERC20(coinAddress).balanceOf(address(this))\n    //     );\n\n    //     // Send ETH to msg.sender\n    //     payable(msg.sender).transfer(address(this).balance);\n    // }\n\n    // function setCoinCreationEthCost(\n    //     uint256 _coinCreationEthCost\n    // ) public onlyOwner {\n    //     require(_coinCreationEthCost > 0, \"Cost must be greater than 0\");\n    //     coinCreationEthCost = _coinCreationEthCost;\n    // }\n\n    // function setFeeWallet(address payable _feeWallet) public onlyOwner {\n    //     require(_feeWallet != address(0), \"Invalid fee wallet address\");\n    //     feeWallet = _feeWallet;\n    // }\n\n    // function setGraduateRouter(address _router) public onlyOwner {\n    //     require(_router != address(0), \"Invalid router address\");\n    //     graduateRouter = IRouter01(_router);\n    // }\n\n    // function createCoin(\n    //     string memory name,\n    //     string memory symbol,\n    //     string memory metaURI,\n    //     uint256 minCoinsToBuy\n    // ) public payable {\n    //     require(msg.value >= coinCreationEthCost, \"Not enough Eth sent\");\n    //     require(minCoinsToBuy <= 400_000_000 ether, \"Max buy limit reached\");\n\n    //     // Require checks for name and symbol length\n    //     require(\n    //         bytes(name).length > 0 && bytes(name).length <= 32,\n    //         \"Name must be between 1 and 32 characters\"\n    //     );\n    //     require(\n    //         bytes(symbol).length > 0 && bytes(symbol).length <= 10,\n    //         \"Symbol must be between 1 and 10 characters\"\n    //     );\n    //     require(\n    //         bytes(metaURI).length > 0 && bytes(metaURI).length <= 200,\n    //         \"Symbol must be between 1 and 10 characters\"\n    //     );\n\n    //     // Transfer the fee to the PumpWallet\n    //     feeWallet.transfer(coinCreationEthCost);\n\n    //     PuushdotCoin coin = new PuushdotCoin(name, symbol);\n    //     uint256 coinToFunds = coin.totalSupply();\n\n    //     // Create the PuushdotFunds contract and add liquidity\n    //     PuushdotFundsV101 funds = new PuushdotFundsV101(\n    //         address(this),\n    //         feeWallet,\n    //         address(coin)\n    //     );\n    //     fundsMap[address(coin)] = address(funds);\n\n    //     // Give funds contract allowance to transfer coins\n    //     coin.approve(address(funds), coinToFunds);\n\n    //     // Use the addInitialFunds function to transfer coins to the funds contract\n    //     funds.addInitialFunds(coinToFunds);\n\n    //     emit CoinCreated(\n    //         address(coin),\n    //         address(funds),\n    //         msg.sender,\n    //         coinToFunds,\n    //         metaURI\n    //     );\n\n    //     if (minCoinsToBuy > 0) {\n    //         require(\n    //             funds.SUPPLY_FOR_SALE() >= minCoinsToBuy + funds.coinsSold(),\n    //             \"Exceeds supplied amount\"\n    //         );\n    //         (uint256 totalCostWithFee, , ) = funds.getCost(\n    //             funds.coinsSold(),\n    //             minCoinsToBuy\n    //         );\n\n    //         require(\n    //             msg.value - coinCreationEthCost >= totalCostWithFee,\n    //             \"Wrong amount of Eth sent\"\n    //         );\n\n    //         (\n    //             uint256 amountToBuy,\n    //             uint256 cost,\n    //             uint256 fee,\n    //             uint256 ethReserve,\n    //             uint256 coinReserve\n    //         ) = funds.buyTokens{value: msg.value - coinCreationEthCost}(\n    //                 msg.sender,\n    //                 minCoinsToBuy\n    //             );\n\n    //         emit CoinsBought(\n    //             address(coin),\n    //             msg.sender,\n    //             cost,\n    //             fee,\n    //             amountToBuy,\n    //             ethReserve,\n    //             coinReserve\n    //         );\n    //     }\n    // }\n\n    // function buyCoins(\n    //     address coinAddress,\n    //     uint256 minAmountToBuy\n    // ) public payable {\n    //     address funds = fundsMap[coinAddress];\n    //     require(funds != address(0), \"Funds do not exist\");\n\n    //     (\n    //         uint256 amountToBuy,\n    //         uint256 cost,\n    //         uint256 fee,\n    //         uint256 ethReserve,\n    //         uint256 coinReserve\n    //     ) = PuushdotFundsV101(funds).buyTokens{value: msg.value}(\n    //             msg.sender,\n    //             minAmountToBuy\n    //         );\n\n    //     emit CoinsBought(\n    //         coinAddress,\n    //         msg.sender,\n    //         cost,\n    //         fee,\n    //         amountToBuy,\n    //         ethReserve,\n    //         coinReserve\n    //     );\n\n    //     monitorMarketCapAndGraduateCoin(coinAddress, coinReserve);\n    // }\n\n    // function sellCoins(\n    //     address coinAddress,\n    //     uint256 amountToSell,\n    //     uint256 minEthGained\n    // ) public {\n    //     address funds = fundsMap[coinAddress];\n    //     require(funds != address(0), \"Funds do not exist\");\n\n    //     (\n    //         uint256 ethReturn,\n    //         uint256 fee,\n    //         uint256 ethReserve,\n    //         uint256 coinReserve\n    //     ) = PuushdotFundsV101(funds).sellTokens(\n    //             msg.sender,\n    //             amountToSell,\n    //             minEthGained\n    //         );\n\n    //     emit CoinsSold(\n    //         coinAddress,\n    //         msg.sender,\n    //         amountToSell,\n    //         fee,\n    //         ethReturn,\n    //         ethReserve,\n    //         coinReserve\n    //     );\n    // }\n\n    // function monitorMarketCapAndGraduateCoin(\n    //     address coinAddress,\n    //     uint256 coinReserve\n    // ) internal {\n    //     if (coinReserve > coinGraduationThreshold) return; // Coin not ready to graduate\n\n    //     PuushdotFundsV101 funds = PuushdotFundsV101(fundsMap[coinAddress]);\n\n    //     // Take all liquidity from the PumpPair\n    //     (uint256 coinsRetrieved, uint256 ethRetrieved) = PuushdotFundsV101(\n    //         funds\n    //     ).retrieveFunds();\n\n    //     emit FundsRetrieved(\n    //         coinAddress,\n    //         fundsMap[coinAddress],\n    //         coinsRetrieved,\n    //         ethRetrieved\n    //     );\n\n    //     if (coinsRetrieved > 0 && ethRetrieved > 0) {\n    //         // Calculate fees\n    //         // Take 5% of eth and 0.5% coin from the funds\n    //         uint256 coinPlatformFee = coinsRetrieved / 200;\n    //         uint256 ethPlatformFee = ethRetrieved / 20;\n\n    //         uint256 amountCoinsToGraduate = coinsRetrieved - coinPlatformFee;\n    //         uint256 amountEthToGraduate = ethRetrieved - ethPlatformFee;\n\n    //         // Send platform fees to fee wallet\n    //         require(\n    //             IERC20(coinAddress).transfer(feeWallet, coinPlatformFee),\n    //             \"Coin transfer failed\"\n    //         );\n    //         (bool success, ) = feeWallet.call{value: ethPlatformFee}(\"\");\n    //         require(success, \"ETH transfer failed\");\n\n    //         // Add new liquidity on graduate platform\n    //         graduateAndBurn(\n    //             coinAddress,\n    //             amountCoinsToGraduate,\n    //             amountEthToGraduate\n    //         );\n    //     }\n    // }\n\n    // function graduateAndBurn(\n    //     address coinAddress,\n    //     uint256 amountCoin,\n    //     uint256 amountETH\n    // ) internal {\n    //     IFactory graduateFactory = IFactory(graduateRouter.factory());\n    //     IERC20(coinAddress).approve(address(graduateRouter), amountCoin);\n\n    //     graduateRouter.addLiquidityETH{value: amountETH}(\n    //         coinAddress,\n    //         amountCoin,\n    //         0, // Slippage is unavoidable\n    //         0, // Slippage is unavoidable\n    //         address(this),\n    //         block.timestamp\n    //     );\n\n    //     address pair = graduateFactory.getPair(\n    //         coinAddress,\n    //         graduateRouter.WETH()\n    //     );\n\n    //     if (pair == address(0)) {\n    //         revert(\"Pair not created\");\n    //     }\n    //     uint256 pairBalance = IERC20(pair).balanceOf(address(this));\n    //     // Burn liquidity tokens\n    //     IERC20(pair).transfer(deadAddress, pairBalance);\n\n    //     emit GraduatedAndBurned(\n    //         coinAddress,\n    //         fundsMap[coinAddress],\n    //         pair,\n    //         amountCoin,\n    //         amountETH,\n    //         pairBalance\n    //     );\n    // }\n\n    // // To receive Eth from funds contract\n    // receive() external payable {}\n}\n"
    },
    "contracts/Puushdot/VMaker/PuushdotFundMaker.sol": {
      "content": "// FILE: PuushdotFundMaker.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../V101/PuushdotFundsV101.sol\";\nimport \"./Interface/IPuushdotFundMaker.sol\";\n\ncontract PuushdotCoinMaker is IPuushdotFundMaker {\n    address private PuushdotFunAddress;\n\n    constructor(address _PuushdotFunAddress) {\n        PuushdotFunAddress = _PuushdotFunAddress;\n    }\n\n    modifier onlyPuushdotFun() {\n        require(\n            msg.sender == PuushdotFunAddress,\n            \"Only PuushdotFun can call this function\"\n        );\n        _;\n    }\n\n    function makeFund(\n        address feeWallet,\n        address coinAddress\n    ) external onlyPuushdotFun returns (address) {\n        PuushdotFundsV101 fund = new PuushdotFundsV101(\n            PuushdotFunAddress,\n            feeWallet,\n            coinAddress\n        );\n        return address(fund);\n    }\n}\n"
    },
    "contracts/Puushdot/VMaker/PuushdotGraduater.sol": {
      "content": "// FILE: PuushdotGraduater.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IFactory {\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n}\n\ninterface IRouter01 {\n    function factory() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint amountToken, uint amountETH, uint liquidity);\n}\n\ncontract PuushdotGraduater is IFactory, IRouter01, Ownable, ERC20 {\n    address private _factory = address(this);\n    address private _WETH;\n    address[] public routerV2Addresses;\n\n    constructor()\n        Ownable(msg.sender)\n        ERC20(\"PuushdotLiquidity\", \"PUUSHDOTLP\")\n    {}\n\n    // Owner functions\n\n    function addRouterV2Address(address _routerV2Address) external onlyOwner {\n        for (uint256 i = 0; i < routerV2Addresses.length; i++) {\n            require(\n                routerV2Addresses[i] != _routerV2Address,\n                \"Address already exists\"\n            );\n        }\n        routerV2Addresses.push(_routerV2Address);\n    }\n\n    function withdrawERC20Liquidity(address tokenAddress) external onlyOwner {\n        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\n        require(balance > 0, \"No ERC20 tokens to withdraw\");\n        bool success = IERC20(tokenAddress).transfer(msg.sender, balance);\n        require(success, \"ERC20 transfer failed\");\n    }\n\n    function withdrawETHLiquidity()\n        external\n        onlyOwner\n        returns (uint256 balance)\n    {\n        balance = address(this).balance;\n        require(balance > 0, \"No ETH to withdraw\");\n        (bool success, ) = payable(msg.sender).call{value: balance}(\"\");\n        require(success, \"ETH transfer failed\");\n    }\n\n    // Public functions\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        override\n        returns (uint amountToken, uint amountETH, uint liquidity)\n    {\n        // Take all eth and coins from msg.sender and transfer to this contract\n        IERC20(token).transferFrom(\n            msg.sender,\n            address(this),\n            amountTokenDesired\n        );\n\n        // Mint 1 LP token to msg.sender\n        _mint(msg.sender, 1);\n    }\n\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair) {\n        return address(this);\n    }\n\n    function factory() external view returns (address) {\n        return _factory;\n    }\n\n    function WETH() external view returns (address) {\n        return _WETH;\n    }\n}\n"
    },
    "contracts/TestNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\n\ncontract TestNFT is ERC721Enumerable {\n    using Strings for uint256;\n\n    constructor() ERC721(\"TestNFT\", \"TNFT\") {}\n\n    function mint(uint256 amount, address to) public {\n        require(amount > 0, \">0\");\n        for (uint256 i = 0; i < amount; i++) {\n            _safeMint(to, (super.totalSupply() + 1));\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": false,
        "constantOptimizer": true,
        "cse": true,
        "deduplicate": true,
        "inliner": true,
        "jumpdestRemover": true,
        "orderLiterals": true,
        "peephole": true
      }
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}